<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android逆向15-抓包 | Matriy's blog</title><meta name="author" content="Matriy"><meta name="copyright" content="Matriy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Android逆向15-抓包来自吾爱破解-正己 https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-1701353-1-1.html 抓包基础知识在计算机网络中，“包”通常指的是在网络上传输的数据单元，也被称为数据包。在互联网协议（IP）的语境下，数据包是由报头（Header）和载荷（Payload）组成，其中报头包含了源地址、目的地址、长度等信息，而载荷则是实际要传输的数据。 抓包具体指">
<meta property="og:type" content="article">
<meta property="og:title" content="Android逆向15-抓包">
<meta property="og:url" content="http://matriy330.github.io/f3acfce3/index.html">
<meta property="og:site_name" content="Matriy&#39;s blog">
<meta property="og:description" content="Android逆向15-抓包来自吾爱破解-正己 https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-1701353-1-1.html 抓包基础知识在计算机网络中，“包”通常指的是在网络上传输的数据单元，也被称为数据包。在互联网协议（IP）的语境下，数据包是由报头（Header）和载荷（Payload）组成，其中报头包含了源地址、目的地址、长度等信息，而载荷则是实际要传输的数据。 抓包具体指">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg">
<meta property="article:published_time" content="2025-05-06T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-13T07:47:50.442Z">
<meta property="article:author" content="Matriy">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Android逆向15-抓包",
  "url": "http://matriy330.github.io/f3acfce3/",
  "image": "https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg",
  "datePublished": "2025-05-06T16:00:00.000Z",
  "dateModified": "2025-05-13T07:47:50.442Z",
  "author": [
    {
      "@type": "Person",
      "name": "Matriy",
      "url": "http://matriy330.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/bitbug_favicon.ico"><link rel="canonical" href="http://matriy330.github.io/f3acfce3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="G-ShTqjjywiLkL87Rg0PaiSsDVYymWStdQUO1wrM_VY"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: Matriy","link":"链接: ","source":"来源: Matriy's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}
</script><link rel="stylesheet" href="/css/custom.css"><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android逆向15-抓包',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/music.css"><link rel="stylesheet" href="/css/comment.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/img/bg.jpeg);"></div><div id="an_music_bg" style="background-image: url(/img/bg.jpeg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">219</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent;"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Matriy's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Android逆向15-抓包</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Android逆向15-抓包</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-06T16:00:00.000Z" title="发表于 2025-05-07 00:00:00">2025-05-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-13T07:47:50.442Z" title="更新于 2025-05-13 15:47:50">2025-05-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">9.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/f3acfce3/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Android逆向15-抓包"><a href="#Android逆向15-抓包" class="headerlink" title="Android逆向15-抓包"></a>Android逆向15-抓包</h1><p>来自吾爱破解-正己</p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1701353-1-1.html">https://www.52pojie.cn/thread-1701353-1-1.html</a></p>
<h2 id="抓包基础知识"><a href="#抓包基础知识" class="headerlink" title="抓包基础知识"></a>抓包基础知识</h2><p>在计算机网络中，“包”通常指的是在网络上传输的数据单元，也被称为数据包。在互联网协议（IP）的语境下，数据包是由报头（Header）和载荷（Payload）组成，其中报头包含了源地址、目的地址、长度等信息，而载荷则是实际要传输的数据。</p>
<p>抓包具体指的是通过某些工具获取安卓App与服务器之间传输的网络数据，这些数据通常用于逆向分析、协议接口分析或App渗透测试，帮助安全工程师理解App与服务器之间的通信细节，如请求和响应的具体内容，从而进行安全评估或逆向工程。</p>
<ol>
<li>帮助定位加密或混淆的代码中的关键部分</li>
<li>逆向接口(比如:一些第三方影视app的解析接口、分析是否为服务器校验)</li>
<li>篡改数据包实现免重打包破解&amp;屏蔽广告</li>
<li>协议分析&amp;爬虫需求</li>
</ol>
<p>网络协议可以分层，每层都有特定的任务和责任，最著名的分层模型是OSI七层模型和TCP&#x2F;IP四层模型。常见的网络协议包括：</p>
<ul>
<li><strong>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol）</strong>：这是互联网的基础协议，包括了IP协议（用于寻址和路由数据包）、TCP协议（用于建立可靠的数据流）和UDP协议（用于不需要确认的快速数据传输）。</li>
<li><strong>HTTP（Hypertext Transfer Protocol）</strong>：用于从Web服务器向浏览器传输超文本文档（如HTML文件）。</li>
<li><strong>FTP（File Transfer Protocol）</strong>：用于在互联网上传输文件。</li>
<li><strong>SMTP（Simple Mail Transfer Protocol）</strong>：用于电子邮件的传输。</li>
<li><strong>DHCP（Dynamic Host Configuration Protocol）</strong>：自动分配IP地址和其他网络配置参数给网络上的设备。</li>
<li><strong>DNS（Domain Name System）</strong>：将域名转换为IP地址。</li>
</ul>
<p>URL 的规则定义如下：</p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/forum.php">https://www.52pojie.cn/forum.php</a></p>
<p>https 表示资源需要通过 HTTPS 这个协议才能够获取，换句话说，客户端需要通过 HTTPS这个协议请求这个资源。</p>
<p><a target="_blank" rel="noopener" href="http://www.52pojie.cn/">www.52pojie.cn</a> 表示服务器地址，在互联网中每个服务器都有一个 IP 地址，但对于用户来说 IP 地址很难记住，用户一般只会记住服务器主机（比如<a target="_blank" rel="noopener" href="http://www.52pojie.cn)名称./">www.52pojie.cn）名称。</a></p>
<p>在 HTTPS 中，客户端发送 HTTPS 请求的时候，必须通过 DNS 协议将服务器主机名转换为IP 地址，这样客户端才能找到服务器。</p>
<p>443 是 HTTPS 协议的默认端口（可以省略不输入），表示服务器通过 443 端口提供 HTTPS服务。</p>
<p>&#x2F;forum.php 表示服务器在&#x2F;根目录下有一个 forum.php 资源。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250508211354648.png" alt="image-20250508211354648"></p>
<p>数字证书是网络安全领域的一个重要组成部分，主要用于身份验证和加密通信。它基于公钥基础设施（Public Key Infrastructure, PKI）的原理，由证书颁发机构（Certificate Authority, CA）签发，用于证明公钥的所有者身份。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250508211502247.png" alt="image-20250508211502247"></p>
<table>
<thead>
<tr>
<th align="left">工具名称</th>
<th align="left">类型</th>
<th align="left">下载链接</th>
<th align="left">简介</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Charles</td>
<td align="left">代理抓包工具</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1600964-1-1.html">https://www.52pojie.cn/thread-1600964-1-1.html</a></td>
<td align="left">Charles 是一个HTTP代理&#x2F;HTTP监视器&#x2F;反向代理，它允许开发人员查看所有的HTTP和SSL&#x2F;HTTPS流量。</td>
</tr>
<tr>
<td align="left">Fiddler</td>
<td align="left">代理抓包工具</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.alipan.com/s/2W8r2ko7UWz">https://www.alipan.com/s/2W8r2ko7UWz</a></td>
<td align="left">Fiddler 是一个Web调试代理，能够记录和检查从任何浏览器和客户端到服务器的所有HTTP流量。</td>
</tr>
<tr>
<td align="left">Burp Suite</td>
<td align="left">代理抓包工具(理论上应该叫渗透必备工具)</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1544866-1-1.html">https://www.52pojie.cn/thread-1544866-1-1.html</a></td>
<td align="left">Burp Suite 是用于攻击web 应用程序的集成平台，包含了许多工具。Burp Suite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。</td>
</tr>
<tr>
<td align="left">Reqable</td>
<td align="left">代理抓包工具</td>
<td align="left"><a target="_blank" rel="noopener" href="https://reqable.com/zh-CN/download">https://reqable.com/zh-CN/download</a></td>
<td align="left">Reqable &#x3D; Fiddler + Charles + Postman<br>Reqable拥有极简的设计、丰富的功能、高效的性能和桌面手机双端平台。<br></td>
</tr>
<tr>
<td align="left">ProxyPin</td>
<td align="left">VPN抓包工具</td>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/wanghongenpin/network_proxy_flutter/releases/tag/V1.1.0">https://github.com/wanghongenpin/network_proxy_flutter/releases/tag/V1.1.0</a></td>
<td align="left">开源免费抓包工具，支持Windows、Mac、Android、IOS、Linux 全平台系统<br>可以使用它来拦截、检查和重写HTTP（S）流量，ProxyPin基于Flutter开发，UI美观易用。</td>
</tr>
<tr>
<td align="left">WireShark</td>
<td align="left">网卡抓包工具</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.wireshark.org/download.html">https://www.wireshark.org/download.html</a></td>
<td align="left">Wireshark是非常流行的网络封包分析软件，可以截取各种网络数据包，并显示数据包详细信息。常用于开发测试过程各种问题定位。</td>
</tr>
<tr>
<td align="left">r0Capture</td>
<td align="left">Hook抓包工具</td>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/r0ysue/r0capture">https://github.com/r0ysue/r0capture</a></td>
<td align="left">安卓应用层抓包通杀脚本</td>
</tr>
<tr>
<td align="left">tcpdump</td>
<td align="left">内核抓包工具</td>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/the-tcpdump-group/tcpdump">https://github.com/the-tcpdump-group/tcpdump</a></td>
<td align="left">cpdump 是一个强大的命令行网络数据包分析工具，允许用户截获并分析网络上传输的数据包，支持多种协议，包括但不限于TCP、UDP、ICMP等。tcpdump基于libpcap库，该库提供了从网络接口直接访问原始数据包的能力。</td>
</tr>
<tr>
<td align="left">eCapture(旁观者)</td>
<td align="left">内核抓包工具</td>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/gojue/ecapture/releases">https://github.com/gojue/ecapture/releases</a></td>
<td align="left">基于eBPF技术实现TLS加密的明文捕获，无需CA证书。</td>
</tr>
</tbody></table>
<p><strong>证书安装</strong></p>
<p><code>选择适合自己的方式安装证书</code></p>
<p>Reqable使用经典的中间人（MITM）技术分析HTTPS流量，当客户端与Reqable的代理服务器（下文简称<code>中间人</code>）进行通信时，中间人需要重签远程服务器的SSL证书。为了保证客户端与中间人成功进行SSL握手通信，需要将中间人的根证书（下文简称<code>CA根证书</code>）安装到客户端本地的证书管理中心。</p>
<ul>
<li><strong>状态</strong>：表示请求的状态，这里是”Completed”，意味着请求已经完成。</li>
<li><strong>方法</strong>：HTTP 请求的方法（也称为动词），这里为 “GET”，说明这是一个获取资源的请求。</li>
<li><strong>协议</strong>：使用的 HTTP 协议版本，此处为 “HTTP&#x2F;1.1”。(Reqable支持HTTP1、HTTP2和HTTP3（QUIC）协议)</li>
<li><strong>Code</strong>：HTTP 状态码，200 表示服务器成功处理了请求。</li>
<li><strong>服务器地址</strong>：请求的目标服务器的 IP 地址和端口号，这里是 “180.76.198.77:443”。</li>
<li><strong>Keep Alive</strong>：是否保持连接 alive，值为 “true” 意味着会保持连接。</li>
<li><strong>Content Type</strong>：返回内容的数据类型，这里没有指定具体的类型。</li>
<li><strong>代理协议</strong>：如果使用了代理，则显示代理协议，此例中为 “https”。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP方法</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GET</td>
<td align="left">请求指定的页面信息并返回实体主体</td>
</tr>
<tr>
<td align="left">HEAD</td>
<td align="left">类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td align="left">POST</td>
<td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。POST请求可能会导致新的资源的建立和&#x2F;或对已有资源的修改</td>
</tr>
<tr>
<td align="left">PUT</td>
<td align="left">从客户端向服务器传送的数据取代指定文档的内容</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td align="left">请求服务器删除指定的页面</td>
</tr>
</tbody></table>
<p>HTTP常见状态码</p>
<table>
<thead>
<tr>
<th align="left">名  称</th>
<th align="left">释  义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">200 OK</td>
<td align="left">服务器成功处理了请求。</td>
</tr>
<tr>
<td align="left">301 Moved Permanently</td>
<td align="left">请求的URL已被永久移动。Response应包含Location URL指向新位置。</td>
</tr>
<tr>
<td align="left">302 Moved Temporarily</td>
<td align="left">请求的URL被暂时移动。Response应包含Location URL指向临时位置。</td>
</tr>
<tr>
<td align="left">304 Not Modified</td>
<td align="left">客户端缓存的资源是最新的，无需重新发送，客户端应使用缓存。</td>
</tr>
<tr>
<td align="left">404 Not Found</td>
<td align="left">请求的资源未在服务器上找到。</td>
</tr>
<tr>
<td align="left">401 Unauthorized</td>
<td align="left">请求要求用户的身份认证。</td>
</tr>
<tr>
<td align="left">500 Internal Server Error</td>
<td align="left">服务器遇到了意外的情况，无法完成请求。</td>
</tr>
</tbody></table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250508215256945.png" alt="image-20250508215256945"></p>
<ol>
<li>第一行是请求行，包含了请求方法（GET）、请求路径以及HTTP协议版本（HTTP&#x2F;1.1）。在这个例子中，请求方法是GET，表明这是一个获取操作；请求路径是<code>/ZJ2595/wuaijie/raw/master/movie/list1.json</code>，这意味着请求的目标资源位于gitee.com网站的某个特定目录下，具体来说是在<code>ZJ2595/wuaijie</code>仓库下的master分支中的<code>movie/list1.json</code>文件；HTTP&#x2F;1.1表示使用的HTTP协议版本。</li>
<li>第二行 <code>Host: gitee.com</code> 是一个HTTP头字段，指明了请求要访问的具体主机名，即gitee.com。</li>
<li>第三行 <code>Connection: Keep-Alive</code> 表示客户端希望保持持久连接。这意味着一旦TCP连接建立之后，可以重复使用该连接来发送多个HTTP请求，而不需要为每个请求单独建立一个新的连接。</li>
<li>第四行 <code>Accept-Encoding: gzip</code> 告诉服务器客户端支持的压缩编码类型。在这个例子中，客户端表示它可以接受gzip压缩编码的内容。</li>
<li>最后一行 <code>User-Agent: okhttp/3.12.0</code> 提供了关于发起请求的应用程序的信息。User-Agent头字段通常用于标识发出请求的浏览器或应用程序的类型、版本和其他相关信息。在这里，User-Agent是okhttp&#x2F;3.12.0，这表示请求是由OkHttp库的一个版本3.12.0发出的。</li>
</ol>
<p>请求头 (Request Headers)</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept</td>
<td align="left">指定客户端能接收的媒体类型。</td>
</tr>
<tr>
<td align="left">Accept-Charset</td>
<td align="left">指定客户端能接收的字符集。</td>
</tr>
<tr>
<td align="left">Accept-Encoding</td>
<td align="left">指定客户端能解码的编码方式，如gzip或deflate。</td>
</tr>
<tr>
<td align="left">Accept-Language</td>
<td align="left">指定客户端首选的语言。</td>
</tr>
<tr>
<td align="left">Authorization</td>
<td align="left">包含用于访问资源的认证信息。</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">控制缓存行为，如no-cache或max-age。</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">控制HTTP连接是否保持活动状态，如keep-alive或close。</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">指明请求体的长度。</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">指明请求体的数据类型，如application&#x2F;json。</td>
</tr>
<tr>
<td align="left">Cookie</td>
<td align="left">包含客户端的cookie信息。</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">请求生成的时间。</td>
</tr>
<tr>
<td align="left">Expect</td>
<td align="left">指定客户端期望服务器执行的操作。</td>
</tr>
<tr>
<td align="left">From</td>
<td align="left">发送请求的用户邮箱地址。</td>
</tr>
<tr>
<td align="left">Host</td>
<td align="left">请求的目标服务器的域名和端口号。</td>
</tr>
<tr>
<td align="left">If-Modified-Since</td>
<td align="left">用于条件性GET，如果资源自指定日期后未被修改则返回304。</td>
</tr>
<tr>
<td align="left">If-None-Match</td>
<td align="left">用于条件性GET，如果资源的ETag与提供的不匹配则返回资源。</td>
</tr>
<tr>
<td align="left">Origin</td>
<td align="left">指明请求来源的源站地址，常用于跨域资源共享（CORS）。</td>
</tr>
<tr>
<td align="left">Pragma</td>
<td align="left">包含与特定代理有关的指令。</td>
</tr>
<tr>
<td align="left">Referer</td>
<td align="left">指明请求前一个页面的URL，可用于跟踪引用页面。</td>
</tr>
<tr>
<td align="left">TE</td>
<td align="left">表示客户端能处理的传输编码方式。</td>
</tr>
<tr>
<td align="left">Trailer</td>
<td align="left">指明报文主体之后的尾部字段。</td>
</tr>
<tr>
<td align="left">Transfer-Encoding</td>
<td align="left">指明报文主体的传输编码方式，如chunked。</td>
</tr>
<tr>
<td align="left">Upgrade</td>
<td align="left">指示客户端希望升级到另一种协议。</td>
</tr>
<tr>
<td align="left">User-Agent</td>
<td align="left">包含客户端软件的名称和版本信息。</td>
</tr>
<tr>
<td align="left">Via</td>
<td align="left">记录请求经过的中间节点，用于追踪和诊断。</td>
</tr>
<tr>
<td align="left">Warning</td>
<td align="left">包含非致命问题的警告信息。</td>
</tr>
</tbody></table>
<p>响应头 (Response Headers)</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Age</td>
<td align="left">响应对象在代理或缓存中的存储时间。</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">控制缓存行为，如public、private、no-store、no-cache等。</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">指示连接是否保持打开，如keep-alive或close。</td>
</tr>
<tr>
<td align="left">Content-Encoding</td>
<td align="left">指明响应体的编码方式，如gzip或deflate。</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">响应体的长度。</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">响应体的数据类型，如text&#x2F;html。</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">服务器生成响应的时间。</td>
</tr>
<tr>
<td align="left">ETag</td>
<td align="left">响应资源的实体标签，用于判断资源是否已被修改。</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">响应过期时间，之后缓存不应再使用。</td>
</tr>
<tr>
<td align="left">Last-Modified</td>
<td align="left">资源最后修改的时间。</td>
</tr>
<tr>
<td align="left">Location</td>
<td align="left">用于重定向，包含资源的新位置。</td>
</tr>
<tr>
<td align="left">Pragma</td>
<td align="left">与特定代理有关的指令。</td>
</tr>
<tr>
<td align="left">Proxy-Authenticate</td>
<td align="left">当代理服务器需要认证时使用。</td>
</tr>
<tr>
<td align="left">Retry-After</td>
<td align="left">在重试之前等待的时间。</td>
</tr>
<tr>
<td align="left">Server</td>
<td align="left">服务器软件的名称和版本。</td>
</tr>
<tr>
<td align="left">Set-Cookie</td>
<td align="left">用于设置或更新客户端的cookie。</td>
</tr>
<tr>
<td align="left">Trailer</td>
<td align="left">指明响应尾部字段。</td>
</tr>
<tr>
<td align="left">Transfer-Encoding</td>
<td align="left">响应体的传输编码方式，如chunked。</td>
</tr>
<tr>
<td align="left">Upgrade</td>
<td align="left">用于协议升级。</td>
</tr>
<tr>
<td align="left">Vary</td>
<td align="left">指明哪些请求头会影响响应的内容，用于缓存控制。</td>
</tr>
<tr>
<td align="left">WWW-Authenticate</td>
<td align="left">当服务器需要认证时使用。</td>
</tr>
<tr>
<td align="left">X-Frame-Options</td>
<td align="left">控制页面是否可以在iframe中显示。</td>
</tr>
</tbody></table>
<h2 id="抓包检测"><a href="#抓包检测" class="headerlink" title="抓包检测"></a>抓包检测</h2><p>代理检测</p>
<p><code>定义</code></p>
<p>代理检测是用于检测设备是否设置了网络代理。这种检测的目的是识别出设备是否尝试通过代理服务器（如抓包工具）来转发网络流量，从而可能截获和分析App的网络通信。</p>
<p><code>原理</code></p>
<p>App会检查系统设置或网络配置，以确定是否有代理服务器被设置为转发流量。例如，它可能会检查系统属性或调用特定的网络信息API来获取当前的网络代理状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return System.getProperty(&quot;http.proxyHost&quot;) == null &amp;&amp; System.getProperty(&quot;http.proxyPort&quot;)  == null</span><br><span class="line"></span><br><span class="line">Port跟设置有关，例如Charles默认是8888</span><br></pre></td></tr></table></figure>

<p>强制不走代理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connection = (HttpURLConnection) url.openConnection(Proxy.NO_PROXY);</span><br><span class="line"></span><br><span class="line">OkHttpClient.Builder()  </span><br><span class="line">    .proxy(Proxy.NO_PROXY)  </span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>

<p>Charles安装与配置</p>
<p>证书安装的问题：<a target="_blank" rel="noopener" href="https://ask.csdn.net/questions/8183901">WIN 11的 charles 安装SSL证书提示 此文件作为下列运行是无效的：安全证书_测试-CSDN问答</a></p>
<p>安装教程：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45005145/article/details/141132846">https://blog.csdn.net/qq_45005145/article/details/141132846</a></p>
<p>key：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registered Name:        52pojie</span><br><span class="line">License Key:        d43c11e6697bbe07a8</span><br></pre></td></tr></table></figure>

<p>anti脚本:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">anti_proxy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">GetProperty</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.System&quot;</span>);</span><br><span class="line">    <span class="title class_">GetProperty</span>.<span class="property">getProperty</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.lang.String&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">getprop</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getprop.<span class="title function_">indexOf</span>(<span class="string">&quot;http.proxyHost&quot;</span>) &gt;= <span class="number">0</span> || getprop.<span class="title function_">indexOf</span>(<span class="string">&quot;http.proxyPort&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getProperty</span>(getprop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>透明代理</code></p>
<p>透明代理（Transparent Proxy）是一种特殊的代理服务类型，它可以在客户端（如浏览器或应用程序）不知道的情况下拦截、转发和处理网络请求。与传统的代理服务不同，透明代理不需要客户端进行任何配置就能工作。</p>
<p>[<a target="_blank" rel="noopener" href="https://blog.seeflower.dev/archives/296/">Clash版]安卓上基于透明代理实现热点抓包</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.seeflower.dev/archives/207/">安卓上基于透明代理对特定APP抓包</a></p>
<h2 id="VPN检测"><a href="#VPN检测" class="headerlink" title="VPN检测"></a>VPN检测</h2><p><code>定义</code></p>
<p>VPN检测是指应用程序或系统检查用户是否正在使用虚拟专用网络（Virtual Private Network, VPN）的一种技术。当用户使用VPN时，他们的网络流量会被加密并通过一个远程服务器路由，这可以隐藏用户的实际IP地址和位置信息，同时保护数据的安全性和隐私。</p>
<p><code>原理</code></p>
<p>当客户端运行VPN虚拟隧道协议时，会在当前节点创建基于<code>eth</code>之上的<code>tun0</code>接口或<code>ppp0</code>接口。这些接口是用于建立虚拟网络连接的特殊网络接口。</p>
<p>根据OSI七层模型，二者分别支持的协议:</p>
<table>
<thead>
<tr>
<th align="left">VPN</th>
<th align="left">OpvenVPN、IPsec、IKEv2、PPTP、L2TP、WireGuard等</th>
</tr>
</thead>
<tbody><tr>
<td align="left">代理</td>
<td align="left">HTTP、HTTPS、SOCKS、FTP、RTSP等</td>
</tr>
</tbody></table>
<p>VPN 协议大多是作用在 OSI 的第二层和第三层之间，由此可见VPN能抓到代理方式的所有的包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public final boolean Check_Vpn1() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">            if (networkInterfaces == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            Iterator it = Collections.list(networkInterfaces).iterator();</span><br><span class="line">            while (it.hasNext()) &#123;</span><br><span class="line">                NetworkInterface networkInterface = (NetworkInterface) it.next();</span><br><span class="line">                if (networkInterface.isUp() &amp;&amp; !networkInterface.getInterfaceAddresses().isEmpty()) &#123;</span><br><span class="line">                    Log.d(&quot;zj595&quot;, &quot;isVpn NetworkInterface Name: &quot; + networkInterface.getName());</span><br><span class="line">                    if (Intrinsics.areEqual(networkInterface.getName(), &quot;tun0&quot;) || Intrinsics.areEqual(networkInterface.getName(), &quot;ppp0&quot;) || Intrinsics.areEqual(networkInterface.getName(), &quot;p2p0&quot;) || Intrinsics.areEqual(networkInterface.getName(), &quot;ccmni0&quot;)) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; catch (Throwable th) &#123;</span><br><span class="line">            th.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> public final boolean Check_Vpn2() &#123;</span><br><span class="line">        boolean z;</span><br><span class="line">        String networkCapabilities;</span><br><span class="line">        try &#123;</span><br><span class="line">            Object systemService = getApplicationContext().getSystemService(&quot;connectivity&quot;);</span><br><span class="line">            Intrinsics.checkNotNull(systemService, &quot;null cannot be cast to non-null type android.net.ConnectivityManager&quot;);</span><br><span class="line">            ConnectivityManager connectivityManager = (ConnectivityManager) systemService;</span><br><span class="line">            NetworkCapabilities networkCapabilities2 = connectivityManager.getNetworkCapabilities(connectivityManager.getActiveNetwork());</span><br><span class="line">            Log.i(&quot;zj595&quot;, &quot;networkCapabilities -&gt; &quot; + networkCapabilities2);</span><br><span class="line">            boolean z2 = networkCapabilities2 != null &amp;&amp; networkCapabilities2.hasTransport(4);</span><br><span class="line">            // 检查网络能力是否包含 &quot;WIFI|VPN&quot; </span><br><span class="line">            if (networkCapabilities2 != null &amp;&amp; (networkCapabilities = networkCapabilities2.toString()) != null) &#123;</span><br><span class="line">                if (StringsKt.contains$default((CharSequence) networkCapabilities, (CharSequence) &quot;WIFI|VPN&quot;, false, 2, (Object) null)) &#123;</span><br><span class="line">                    z = true;</span><br><span class="line">                    return !z || z2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            z = false;</span><br><span class="line">            if (z) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>anti</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hook_vpn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">NetworkInterface</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.net.NetworkInterface&quot;</span>);</span><br><span class="line">        <span class="title class_">NetworkInterface</span>.<span class="property">getName</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> name = <span class="variable language_">this</span>.<span class="title function_">getName</span>();  <span class="comment">//hook java层的getName方法</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name: &quot;</span> + name);</span><br><span class="line">            <span class="keyword">if</span> (name === <span class="string">&quot;tun0&quot;</span> || name === <span class="string">&quot;ppp0&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;rmnet_data0&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">NetworkCapabilities</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.net.NetworkCapabilities&quot;</span>);</span><br><span class="line">        <span class="title class_">NetworkCapabilities</span>.<span class="property">hasTransport</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title class_">NetworkCapabilities</span>.<span class="property">appendStringRepresentationOfBitMaskToStringBuilder</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">sb, bitMask, nameFetcher, separator</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bitMask == <span class="number">18</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bitMask&quot;</span>, bitMask);</span><br><span class="line">                sb.<span class="title function_">append</span>(<span class="string">&quot;WIFI&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(sb, bitMask);</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">appendStringRepresentationOfBitMaskToStringBuilder</span>(sb, bitMask, nameFetcher, separator);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SSL-Pinning"><a href="#SSL-Pinning" class="headerlink" title="SSL Pinning"></a>SSL Pinning</h2><p>SSL Pinning<code> 也称为证书锁定，是Google官方推荐的检验方式，意思是将服务器提供的SSL/TLS证书内置到移动客户端，当客户端发起请求的时候，通过对比内置的证书与服务器的证书是否一致，来确认这个连接的合法性。 PS:这里还要提到一个概念:</code>单向校验<code>，本质上二者没区别，</code>SSL Pinning<code>可以理解为加强版的</code>单向校验</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250509204346269.png" alt="image-20250509204346269"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</span><br><span class="line">2.服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</span><br><span class="line">3.客户端使用服务端返回的信息验证服务器的合法性，包括：</span><br><span class="line">    (1)证书是否过期</span><br><span class="line">    (2)发型服务器证书的CA是否可靠</span><br><span class="line">    (3)返回的公钥是否能正确解开返回证书中的数字签名</span><br><span class="line">    (4)服务器证书上的域名是否和服务器的实际域名相匹配、验证通过后，将继续进行通信，否则，终止通信</span><br><span class="line">4.客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</span><br><span class="line">5.服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。</span><br><span class="line">6.服务器将选择好的加密方案通过明文方式返回给客户端</span><br><span class="line">7.客户端接收服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器</span><br><span class="line">8.服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全</span><br></pre></td></tr></table></figure>

<p><code>SSL Pinning</code>主流的三套方案:<code>公钥校验</code>、<code>证书校验</code>、<code>Host校验</code></p>
<p>因为是客户端做的校验，所以可以在本地进行hook对抗，参考以下的两个项目:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Fuzion24/JustTrustMe">JustTrustMe</a>、<a target="_blank" rel="noopener" href="https://github.com/ac-pm/SSLUnpinning_Xposed">sslunpining</a></p>
<h3 id="指纹校验"><a href="#指纹校验" class="headerlink" title="指纹校验"></a>指纹校验</h3><p>在网站中我们可以看到网站的证书相关信息，其中就包含了指纹信息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250509204426702.png" alt="image-20250509204426702"></p>
<p>常见安卓网络开发框架</p>
<table>
<thead>
<tr>
<th align="left">框架名称</th>
<th align="left">描述</th>
<th align="left">GitHub 地址</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Volley</td>
<td align="left">由Google开源的轻量级网络库，支持网络请求处理、小图片的异步加载和缓存等功能</td>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/google/volley">https://github.com/google/volley</a></td>
</tr>
<tr>
<td align="left">Android-async-http</td>
<td align="left">基于Apache HttpClient的一个异步网络请求处理库</td>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/android-async-http/android-async-http">https://github.com/android-async-http/android-async-http</a></td>
</tr>
<tr>
<td align="left">xUtils</td>
<td align="left">类似于Afinal，但被认为是Afinal的一个升级版，提供了HTTP请求的支持</td>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/wyouflf/xUtils3">https://github.com/wyouflf/xUtils3</a></td>
</tr>
<tr>
<td align="left">OkHttp</td>
<td align="left">一个高性能的网络框架，已经被Google官方认可，在Android 6.0中底层源码已经使用了OkHttp来替代HttpURLConnection</td>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/square/okhttp">https://github.com/square/okhttp</a></td>
</tr>
<tr>
<td align="left">Retrofit</td>
<td align="left">提供了一种类型安全的HTTP客户端接口，简化了HTTP请求的编写，通常与OkHttp配合使用</td>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/square/retrofit">https://github.com/square/retrofit</a></td>
</tr>
</tbody></table>
<p>OkHttp和Retrofit是非常流行的组合，被广泛应用于现代Android应用开发中</p>
<p><code>原理(以okhttp框架为例):</code></p>
<p>在CertificatePinner类里有一个check方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查指定主机名的证书链是否符合预设的哈希值（证书固定）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> hostname         要验证的主机名。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> peerCertificates 待验证的证书列表。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SSLPeerUnverifiedException 如果证书不符合预设的哈希值，则抛出此异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(String hostname, List&lt;Certificate&gt; peerCertificates)</span></span><br><span class="line">      <span class="keyword">throws</span> SSLPeerUnverifiedException &#123;</span><br><span class="line">    <span class="comment">// 查找与主机名匹配的哈希值列表（证书固定列表）。</span></span><br><span class="line">    List&lt;Pin&gt; pins = findMatchingPins(hostname);</span><br><span class="line">    <span class="comment">// 如果没有找到任何匹配的哈希值，则直接返回，表示无需进一步检查。</span></span><br><span class="line">    <span class="keyword">if</span> (pins.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在证书链清理器，则先清理证书链中的冗余证书。</span></span><br><span class="line">    <span class="keyword">if</span> (certificateChainCleaner != <span class="literal">null</span>) &#123;</span><br><span class="line">      peerCertificates = certificateChainCleaner.clean(peerCertificates, hostname);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历每一个证书进行检查。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>, certsSize = peerCertificates.size(); c &lt; certsSize; c++) &#123;</span><br><span class="line">      <span class="comment">// 获取当前证书。</span></span><br><span class="line">      <span class="type">X509Certificate</span> <span class="variable">x509Certificate</span> <span class="operator">=</span> (X509Certificate) peerCertificates.get(c);</span><br><span class="line">      <span class="comment">// 懒加载计算每个证书的SHA-1和SHA-256哈希值。</span></span><br><span class="line">      <span class="type">ByteString</span> <span class="variable">sha1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">ByteString</span> <span class="variable">sha256</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 遍历预设的哈希值列表。</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, pinsSize = pins.size(); p &lt; pinsSize; p++) &#123;</span><br><span class="line">        <span class="type">Pin</span> <span class="variable">pin</span> <span class="operator">=</span> pins.get(p);</span><br><span class="line">        <span class="comment">// 根据预设的哈希算法进行检查。</span></span><br><span class="line">        <span class="keyword">if</span> (pin.hashAlgorithm.equals(<span class="string">&quot;sha256/&quot;</span>)) &#123;</span><br><span class="line">          <span class="comment">// 如果尚未计算SHA-256哈希值，则进行计算。</span></span><br><span class="line">          <span class="keyword">if</span> (sha256 == <span class="literal">null</span>) sha256 = sha256(x509Certificate);</span><br><span class="line">          <span class="comment">// 如果证书的SHA-256哈希值与预设值相同，则返回成功。</span></span><br><span class="line">          <span class="keyword">if</span> (pin.hash.equals(sha256)) <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pin.hashAlgorithm.equals(<span class="string">&quot;sha1/&quot;</span>)) &#123;</span><br><span class="line">          <span class="comment">// 如果尚未计算SHA-1哈希值，则进行计算。</span></span><br><span class="line">          <span class="keyword">if</span> (sha1 == <span class="literal">null</span>) sha1 = sha1(x509Certificate);</span><br><span class="line">          <span class="comment">// 如果证书的SHA-1哈希值与预设值相同，则返回成功。</span></span><br><span class="line">          <span class="keyword">if</span> (pin.hash.equals(sha1)) <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果遇到不支持的哈希算法，则抛出错误。</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;unsupported hashAlgorithm: &quot;</span> + pin.hashAlgorithm);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果遍历完所有证书和哈希值都没有匹配，则抛出异常。</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SSLPeerUnverifiedException</span>(<span class="string">&quot;No matching certificate found.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现方案:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指纹检测  </span></span><br><span class="line">fun <span class="title function_">check_SSL_PINNING_key</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用CoroutineScope和Dispatchers.IO在后台线程中执行网络操作</span></span><br><span class="line">    <span class="title class_">CoroutineScope</span>(<span class="title class_">Dispatchers</span>.<span class="property">IO</span>).<span class="property">launch</span> &#123;</span><br><span class="line">        <span class="comment">// 定义需要固定证书的域名</span></span><br><span class="line">        val caDomain = <span class="string">&quot;www.52pojie.cn&quot;</span></span><br><span class="line">        <span class="comment">// 使用CertificatePinner.Builder构建一个证书固定器</span></span><br><span class="line">        <span class="comment">// 添加一个sha256哈希值，这个哈希值是服务器证书的指纹</span></span><br><span class="line">        <span class="comment">// 这个值需要通过openssl工具获取</span></span><br><span class="line">        val pinner = <span class="title class_">CertificatePinner</span>.<span class="title class_">Builder</span>()</span><br><span class="line">            .<span class="title function_">add</span>(caDomain, <span class="string">&quot;sha256/WnsD5UGdP5/a65xO1rpH8ru2EjyxkmPEaiNtKixhJLU=&quot;</span>) <span class="comment">// 添加证书指纹</span></span><br><span class="line">            .<span class="title function_">build</span>() <span class="comment">// 构建完成证书固定器</span></span><br><span class="line">        <span class="comment">// 使用newBuilder创建一个新的OkHttpClient实例，用于覆盖默认的客户端配置</span></span><br><span class="line">        val pClient = client.<span class="title function_">newBuilder</span>()</span><br><span class="line">            .<span class="title function_">certificatePinner</span>(pinner) <span class="comment">// 设置证书固定器</span></span><br><span class="line">            .<span class="title function_">build</span>() <span class="comment">// 构建新的OkHttpClient实例</span></span><br><span class="line">        <span class="comment">// 构建一个网络请求，访问指定的URL</span></span><br><span class="line">        val request = <span class="title class_">Request</span>.<span class="title class_">Builder</span>()</span><br><span class="line">            .<span class="title function_">url</span>(<span class="string">&quot;https://www.52pojie.cn/?q=SSLPinningCode&quot;</span>) <span class="comment">// 设置请求的URL</span></span><br><span class="line">            .<span class="title function_">build</span>() <span class="comment">// 构建请求对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行网络请求，并获取响应</span></span><br><span class="line">            val response = pClient.<span class="title function_">newCall</span>(request).<span class="title function_">execute</span>()</span><br><span class="line">            <span class="comment">// 如果响应状态码是200，表示指纹检测通过</span></span><br><span class="line">            <span class="title class_">Log</span>.<span class="title function_">d</span>(<span class="variable constant_">TAG</span>, <span class="string">&quot;指纹检测通过，状态码:$&#123;response.code()&#125;&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="attr">e</span>: <span class="title class_">IOException</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果发生IOException，表示指纹检测不通过</span></span><br><span class="line">            <span class="title class_">Log</span>.<span class="title function_">d</span>(<span class="variable constant_">TAG</span>, <span class="string">&quot;指纹检测不通过&quot;</span>)</span><br><span class="line">            e.<span class="title function_">printStackTrace</span>() <span class="comment">// 打印异常堆栈信息，用于调试</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装openssl，<a target="_blank" rel="noopener" href="https://slproweb.com/products/Win32OpenSSL.html?spm=5176.28103460.0.0.3a32572c9fMUi9">OpenSSL Windows 版本</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250509205625373.png" alt="image-20250509205625373"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250509205632298.png" alt="image-20250509205632298"></p>
<p>cmd窗口输入以下命令获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl s_client -connect www.52pojie.cn:443 -servername www.52pojie.cn | openssl x509 -pubkey -noout | openssl rsa -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250509205658451.png" alt="image-20250509205658451"></p>
<p>anti脚本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">anti_ssl_key</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//check方法置空即可</span></span><br><span class="line">    <span class="keyword">var</span> okhttp3_Activity_1 = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;okhttp3.CertificatePinner&#x27;</span>);   </span><br><span class="line">    okhttp3_Activity_1.<span class="property">check</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.util.List&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;                             </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[+] Bypassing SSL key pinning: &#x27;</span> + a);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="证书校验"><a href="#证书校验" class="headerlink" title="证书校验"></a>证书校验</h3><p>通过<code>trustManager</code> 类实现的checkServerTrusted接口，核心在于验证服务器证书的公钥。具体步骤包括：获取服务器返回的证书，将其公钥编码为 Base64 字符串；同时从本地资源加载预存的可信客户端证书，并将其公钥也编码为 Base64 字符串。然后，比较这两个公钥是否匹配，以此确认服务器的身份是否合法。最后，使用自定义的 <code>SSLSocketFactory</code> 发起 HTTPS 请求，确保通信过程中只信任预定义的服务器证书，从而有效抵御中间人攻击。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数用于检查SSL证书</span></span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">check_SSL_PINNING_CA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个X509TrustManager的匿名对象，用于自定义信任管理器</span></span><br><span class="line">    val trustManager: X509TrustManager = object : X509TrustManager &#123;</span><br><span class="line">        <span class="comment">// 客户端证书信任检查，这里不实现任何逻辑</span></span><br><span class="line">        <span class="meta">@Throws(CertificateException::class)</span></span><br><span class="line">        override fun <span class="title function_">checkClientTrusted</span><span class="params">(chain: Array&lt;X509Certificate?&gt;?, authType: String?)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 服务器证书信任检查</span></span><br><span class="line">        <span class="meta">@Throws(CertificateException::class)</span></span><br><span class="line">        override fun <span class="title function_">checkServerTrusted</span><span class="params">(chain: Array&lt;X509Certificate&gt;, authType: String?)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取服务器返回的第一个证书</span></span><br><span class="line">            val cf: X509Certificate = chain[<span class="number">0</span>]</span><br><span class="line">            <span class="comment">// 将服务器证书的公钥编码为Base64字符串</span></span><br><span class="line">            val ServerPubkey: String = Base64.encodeToString(cf.publicKey.encoded, <span class="number">0</span>)</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;服务器端返回的证书:&quot;</span> + ServerPubkey)</span><br><span class="line">            <span class="comment">// 从客户端资源中读取证书</span></span><br><span class="line">            <span class="type">val</span> <span class="variable">client_input</span> <span class="operator">=</span> resources.openRawResource(R.raw.wuai)</span><br><span class="line">            <span class="type">val</span> <span class="variable">certificateFactory</span> <span class="operator">=</span> CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>)</span><br><span class="line">            <span class="comment">// 生成客户端证书</span></span><br><span class="line">            val realCertificate: X509Certificate = certificateFactory.generateCertificate(client_input) as X509Certificate</span><br><span class="line">            <span class="comment">// 将客户端证书的公钥编码为Base64字符串</span></span><br><span class="line">            val realPubkey: String = Base64.encodeToString(realCertificate.publicKey.encoded, <span class="number">0</span>)</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;客户端资源目录中的证书:&quot;</span> + realPubkey)</span><br><span class="line">            <span class="comment">// 检查证书有效期</span></span><br><span class="line">            cf.checkValidity()</span><br><span class="line">            <span class="comment">// 比较服务器证书和客户端证书的公钥是否相同</span></span><br><span class="line">            <span class="type">val</span> <span class="variable">expected</span> <span class="operator">=</span> realPubkey.equals(ServerPubkey, ignoreCase = <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">if</span> (!expected) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;证书检测不通过&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;证书检测通过&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回受信任的CA证书数组，这里返回空数组</span></span><br><span class="line">        override fun <span class="title function_">getAcceptedIssuers</span><span class="params">()</span>: Array&lt;X509Certificate?&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> arrayOfNulls&lt;X509Certificate&gt;(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 声明SSLSocketFactory变量</span></span><br><span class="line">    <span class="keyword">var</span> factory: SSLSocketFactory? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取SSL上下文</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">sslContext</span> <span class="operator">=</span> SSLContext.getInstance(<span class="string">&quot;SSL&quot;</span>)</span><br><span class="line">        <span class="comment">// 初始化SSL上下文，使用自定义的信任管理器</span></span><br><span class="line">        sslContext.init(<span class="literal">null</span>, arrayOf&lt;TrustManager&gt;(trustManager), SecureRandom())</span><br><span class="line">        <span class="comment">// 获取SSLSocketFactory</span></span><br><span class="line">        factory = sslContext.socketFactory</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: java.lang.Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确保factory不为空</span></span><br><span class="line">    val finalFactory: SSLSocketFactory? = factory</span><br><span class="line">    <span class="comment">// 创建并启动一个新线程来执行网络请求</span></span><br><span class="line">    object : Thread() &#123;</span><br><span class="line">        override fun <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用自定义的SSLSocketFactory创建OkHttpClient</span></span><br><span class="line">                <span class="type">val</span> <span class="variable">client</span> <span class="operator">=</span></span><br><span class="line">                    OkHttpClient.Builder().sslSocketFactory(finalFactory, trustManager).build()</span><br><span class="line">                <span class="comment">// 构建请求</span></span><br><span class="line">                <span class="type">val</span> <span class="variable">req</span> <span class="operator">=</span> Request.Builder().url(<span class="string">&quot;https://www.52pojie.cn/forum.php&quot;</span>).build()</span><br><span class="line">                <span class="comment">// 发送请求并获取响应</span></span><br><span class="line">                val call: okhttp3.Call = client.newCall(req)</span><br><span class="line">                val res: Response = call.execute()</span><br><span class="line">                <span class="comment">// 打印响应状态码</span></span><br><span class="line">                Log.e(<span class="string">&quot;请求发送成功&quot;</span>, <span class="string">&quot;状态码：&quot;</span> + res.code())</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="comment">// 打印网络异常信息</span></span><br><span class="line">                Log.e(<span class="string">&quot;请求发送失败&quot;</span>, <span class="string">&quot;网络异常$e&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cmd窗口输入以下命令获取证书信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl s_client -connect 52pojie.cn:443 -servername 52pojie.cn | openssl x509 -out wuai.pem</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">证书信知识补充:</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">名词</th>
<th align="left">含义</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">X.509</td>
<td align="left">一种通用的证书格式，包含证书持有人的公钥、加密算法等信息</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">PKCS1~PKCS12</td>
<td align="left">公钥加密（非对称加密）的一系列标准（Public Key Cryptography Standards），.p12 是包含证书和密钥的封装格式</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">*.der</td>
<td align="left">证书的二进制存储格式（不常用）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">*.pem</td>
<td align="left">证书或密钥的 Base64 文本存储格式，可以单独存放证书或密钥，也可以同时存放证书和密钥</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">*.key</td>
<td align="left">单独存放的 pem 格式的私钥文件，一般保存为 *.key</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><em>.cer &#x2F;</em> .crt</td>
<td align="left">两者指的都是证书，Linux 下叫 crt，Windows 下叫 cer；存储格式可以是 pem，也可以是 der</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">*.csr</td>
<td align="left">证书签名请求（Certificate Signing Request），包含证书持有人的信息，如：国家、邮件、域名等</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">*.pfx</td>
<td align="left">微软 IIS 的实现，包含证书和私钥</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>有的证书内容是只包含公钥（服务器的公钥），如.crt、.cer、.pem</p>
<p>有的证书既包含公钥又包含私钥（服务器的私钥），如.pfx、.p12</p>
<p>另外有些app的证书不走寻常路，不是上面所罗列到的格式，它有可能伪装成png等其他格式</p>
<p><code>anti脚本</code></p>
<p>思路：实例化一个trustManager类，然后里面什么都不写，当上面两处调用到这个类时hook这两个地方，把自己定义的空trustManager类放进去</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">anti_ssl_cert</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 使用Frida获取Java类X509TrustManager的引用</span></span><br><span class="line">    <span class="keyword">var</span> X509TrustManager = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;javax.net.ssl.X509TrustManager&#x27;</span>);</span><br><span class="line">    <span class="comment">// 使用Frida获取Java类SSLContext的引用</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">SSLContext</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;javax.net.ssl.SSLContext&#x27;</span>);</span><br><span class="line">    <span class="comment">// 注册一个自定义的TrustManager类</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">TrustManager</span> = <span class="title class_">Java</span>.<span class="title function_">registerClass</span>(&#123;</span><br><span class="line">        <span class="comment">// 指定自定义TrustManager的全名</span></span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;dev.asd.test.TrustManager&#x27;</span>,</span><br><span class="line">        <span class="comment">// 指定自定义TrustManager实现的接口</span></span><br><span class="line">        <span class="attr">implements</span>: [X509TrustManager],</span><br><span class="line">        <span class="comment">// 定义自定义TrustManager的方法实现</span></span><br><span class="line">        <span class="attr">methods</span>: &#123;</span><br><span class="line">            <span class="comment">// 客户端证书信任检查，这里不实现任何逻辑</span></span><br><span class="line">            <span class="attr">checkClientTrusted</span>: <span class="keyword">function</span>(<span class="params">chain, authType</span>) &#123;&#125;,</span><br><span class="line">            <span class="comment">// 服务器证书信任检查，这里不实现任何逻辑</span></span><br><span class="line">            <span class="attr">checkServerTrusted</span>: <span class="keyword">function</span>(<span class="params">chain, authType</span>) &#123;&#125;,</span><br><span class="line">            <span class="comment">// 返回受信任的CA证书数组，这里返回空数组</span></span><br><span class="line">            <span class="attr">getAcceptedIssuers</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> []; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 准备一个TrustManager数组，用于传递给SSLContext.init()方法</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">TrustManagers</span> = [<span class="title class_">TrustManager</span>.$new()];</span><br><span class="line">    <span class="comment">// 获取SSLContext.init()方法的引用，该方法用于初始化SSL上下文</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">SSLContext</span>_init = <span class="title class_">SSLContext</span>.<span class="property">init</span>.<span class="title function_">overload</span>(</span><br><span class="line">        <span class="string">&#x27;[Ljavax.net.ssl.KeyManager;&#x27;</span>, <span class="string">&#x27;[Ljavax.net.ssl.TrustManager;&#x27;</span>, <span class="string">&#x27;java.security.SecureRandom&#x27;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 覆盖init方法的实现，指定使用自定义的TrustManager</span></span><br><span class="line">        <span class="title class_">SSLContext</span>_init.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">keyManager, trustManager, secureRandom</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[+] Bypassing Trustmanager (Android &lt; 7) pinner&#x27;</span>);</span><br><span class="line">            <span class="comment">// 调用原始的init方法，并使用自定义的TrustManager数组</span></span><br><span class="line">            <span class="title class_">SSLContext</span>_init.<span class="title function_">call</span>(<span class="variable language_">this</span>, keyManager, <span class="title class_">TrustManagers</span>, secureRandom);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 如果覆盖init方法失败，打印错误信息</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[-] TrustManager (Android &lt; 7) pinner not found&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err); <span class="comment">// 可以取消注释来打印异常的详细信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h2><p>双向验证，顾名思义就是客户端验证服务器端证书的正确性，服务器端也验证客户端的证书正确性</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250509205853538.png" alt="image-20250509205853538"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</span><br><span class="line">2.服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</span><br><span class="line">3.客户端使用服务端返回的信息验证服务器的合法性，包括：</span><br><span class="line">    (1)证书是否过期</span><br><span class="line">    (2)发型服务器证书的CA是否可靠</span><br><span class="line">    (3)返回的公钥是否能正确解开返回证书中的数字签名</span><br><span class="line">    (4)服务器证书上的域名是否和服务器的实际域名相匹配、验证通过后，将继续进行通信，否则，终止通信</span><br><span class="line">4.服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端</span><br><span class="line">5.验证客户端的证书，通过验证后，会获得客户端的公钥</span><br><span class="line">6.客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</span><br><span class="line">7.服务器端在客户端提供的加密方案中选择加密程度最高的加密方式</span><br><span class="line">8.将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</span><br><span class="line">9.客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端</span><br><span class="line">10.服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</span><br></pre></td></tr></table></figure>

<p><code>实现方案:</code></p>
<ol>
<li>首先借助openssl生成<strong>服务端证书</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 生成CA私钥 </span><br><span class="line">openssl genrsa -out ca.key 2048</span><br><span class="line"></span><br><span class="line"># 生成CA自签名证书 </span><br><span class="line">openssl req -x509 -new -nodes -key ca.key -sha256 -days 1024 -out ca.crt</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>生成<strong>服务端证书</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server.key 2048</span><br></pre></td></tr></table></figure>

<p>这个指令生成一个2048位的RSA私钥，并将其保存到名为<code>server.key</code>的文件中</p>
<p>这个指令基于第一步生成的私钥创建一个新的证书签名请求（CSR）。CSR包含了公钥和一些身份信息，这些信息在证书颁发过程中用于识别证书持有者。<code>-out server.csr</code>指定了CSR的输出文件名。</p>
<p>执行这个指令时，系统会提示你输入一些身份信息，如国家代码、组织名等，这些信息将被包含在CSR中。(我们这边测试直接全部按回车键默认即可)</p>
<table>
<thead>
<tr>
<th align="left">字段名称</th>
<th align="left">描述</th>
<th align="left">默认值&#x2F;示例值</th>
<th align="left">是否必填</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Country Name (2 letter code)</td>
<td align="left">国家代码，两位字母代码。</td>
<td align="left">AU</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">State or Province Name</td>
<td align="left">州或省份的全名。</td>
<td align="left"></td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">Locality Name (eg, city)</td>
<td align="left">城市或地区名称。</td>
<td align="left"></td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">Organization Name</td>
<td align="left">组织名称，通常是公司或机构的名称。</td>
<td align="left"></td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">Organizational Unit Name (eg, section)</td>
<td align="left">组织单位名称，可以是部门或团队的名称。</td>
<td align="left"></td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">Common Name (CN)</td>
<td align="left">完全限定的域名（FQDN）或个人名称，用于标识证书持有者。</td>
<td align="left"></td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">Email Address</td>
<td align="left">与证书持有者关联的电子邮件地址。</td>
<td align="left"></td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">Challenge Password</td>
<td align="left">挑战密码，用于CSR的额外安全措施。</td>
<td align="left"></td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">Optional Company Name</td>
<td align="left">可选的公司名称字段。</td>
<td align="left"></td>
<td align="left">否</td>
</tr>
</tbody></table>
<p><code>-config server_cert.conf</code>创建一个OpenSSL配置文件（如 <code>server_cert.conf</code>）并指定IP地址，具体的ip地址可以由ipconfig获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">这个指令基于第一步生成的私钥创建一个新的证书签名请求（CSR）。CSR包含了公钥和一些身份信息，这些信息在证书颁发过程中用于识别证书持有者。-out server.csr指定了CSR的输出文件名。</span><br><span class="line">执行这个指令时，系统会提示你输入一些身份信息，如国家代码、组织名等，这些信息将被包含在CSR中。(我们这边测试直接全部按回车键默认即可)</span><br><span class="line"></span><br><span class="line">字段名称	描述	默认值/示例值	是否必填</span><br><span class="line">Country Name (2 letter code)	国家代码，两位字母代码。	AU	否</span><br><span class="line">State or Province Name	州或省份的全名。		否</span><br><span class="line">Locality Name (eg, city)	城市或地区名称。		否</span><br><span class="line">Organization Name	组织名称，通常是公司或机构的名称。		否</span><br><span class="line">Organizational Unit Name (eg, section)	组织单位名称，可以是部门或团队的名称。		否</span><br><span class="line">Common Name (CN)	完全限定的域名（FQDN）或个人名称，用于标识证书持有者。		是</span><br><span class="line">Email Address	与证书持有者关联的电子邮件地址。		否</span><br><span class="line">Challenge Password	挑战密码，用于CSR的额外安全措施。		否</span><br><span class="line">Optional Company Name	可选的公司名称字段。		否</span><br><span class="line">-config server_cert.conf创建一个OpenSSL配置文件（如 server_cert.conf）并指定IP地址，具体的ip地址可以由ipconfig获取</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 365 -extfile server_cert.conf -extensions v3_req</span><br><span class="line">openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.cer</span><br></pre></td></tr></table></figure>

<p>使用CA证书签发服务器证书。</p>
<p>生成cer证书供服务端验证。</p>
<p><strong>客户端证书：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out client.key 2048</span><br><span class="line">openssl req -new -out client.csr -key client.key</span><br><span class="line">openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out client.crt -days 500 -sha256</span><br></pre></td></tr></table></figure>

<p>生成客户端带密码的p12证书（这步很重要，双向认证的话，浏览器访问时候要导入该证书才行；可能某些Android系统版本请求的时候需要把它转成bks来请求双向认证）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -out client.p12 -inkey client.key -in client.crt -certfile ca.crt</span><br></pre></td></tr></table></figure>

<p>到这一步的时候，设置密码和验证密码光标不会显示，直接输入即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250509210036558.png" alt="image-20250509210036558"></p>
<p><strong>环境配置</strong></p>
<p>PS:因为双向认证是本地搭建，所以需要完成几个前置条件:</p>
<ol>
<li>确保电脑和手机处于同一wifi连接下</li>
<li>重打包替换生成的server.cer(路径在res&#x2F;raw)，替换ssl_verify方法里的ip地址以及res&#x2F;xml&#x2F;network_config.xml的ip地址(通过ipconfig获取实际的ipv4地址)</li>
<li>运行服务端代码，然后再请求看看是否能正常输出</li>
</ol>
<p><strong>服务端代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify  </span><br><span class="line"><span class="keyword">import</span> ssl  </span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ssl 证书校验  </span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/ca&#x27;</span></span>)  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssl_verify</span>():  </span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;HTTPS server with mutual SSL verification started.&quot;</span>&#125;)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置ssl上下文，关键函数  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_ssl_context</span>():  </span><br><span class="line">    <span class="comment"># CA根证书路径  </span></span><br><span class="line">    ca_crt_path = <span class="string">&#x27;certs/ca.crt&#x27;</span>  </span><br><span class="line">    <span class="comment"># 服务端证书和密钥路径  </span></span><br><span class="line">    server_crt_path = <span class="string">&#x27;certs/server.crt&#x27;</span>  </span><br><span class="line">    server_key_path = <span class="string">&#x27;certs/server.key&#x27;</span>  </span><br><span class="line">    <span class="comment"># 创建SSL上下文，使用TLS服务器模式  </span></span><br><span class="line">    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)  </span><br><span class="line">    <span class="comment"># 设置验证模式为需要客户端证书  </span></span><br><span class="line">    ssl_context.verify_mode = ssl.CERT_REQUIRED  </span><br><span class="line">    <span class="comment"># 启用主机名检查（根据需要设置）  </span></span><br><span class="line">    ssl_context.check_hostname = <span class="literal">False</span>  </span><br><span class="line">    <span class="comment"># 设置加密套件  </span></span><br><span class="line">    ssl_context.set_ciphers(<span class="string">&quot;HIGH:!SSLv3:!TLSv1:!aNULL:@STRENGTH&quot;</span>)  </span><br><span class="line">    <span class="comment"># 加载CA根证书，用于验证客户端证书  </span></span><br><span class="line">    ssl_context.load_verify_locations(cafile=ca_crt_path)  </span><br><span class="line">    <span class="comment"># 加载服务端证书和私钥  </span></span><br><span class="line">    ssl_context.load_cert_chain(certfile=server_crt_path, keyfile=server_key_path)  </span><br><span class="line">    <span class="keyword">return</span> ssl_context  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    ssl_context = get_ssl_context()  </span><br><span class="line">    app.run(host=<span class="string">&quot;192.168.124.21&quot;</span>, port=<span class="number">8088</span>,ssl_context=ssl_context)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>dump内置证书:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hook_KeyStore_load</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">ByteString</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.android.okhttp.okio.ByteString&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> myArray=<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; myArray.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            myArray[i]= <span class="number">0x0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">var</span> buffer = <span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&#x27;byte&#x27;</span>,myArray);</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">StringClass</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">KeyStore</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.security.KeyStore&quot;</span>);</span><br><span class="line">        <span class="title class_">KeyStore</span>.<span class="property">load</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.security.KeyStore$LoadStoreParameter&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arg0</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()));</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;KeyStore.load1:&quot;</span>, arg0);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">load</span>(arg0);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="title class_">KeyStore</span>.<span class="property">load</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.io.InputStream&#x27;</span>, <span class="string">&#x27;[C&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arg0, arg1</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()));</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;KeyStore.load2:&quot;</span>, arg0, arg1 ? <span class="title class_">StringClass</span>.$new(arg1) : <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (arg0)&#123;</span><br><span class="line">                <span class="keyword">var</span> file =  <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.io.File&quot;</span>).$new(<span class="string">&quot;/data/user/0/com.zj.wuaipojie/files/client&quot;</span>+<span class="string">&quot;.p12&quot;</span>);</span><br><span class="line">                <span class="keyword">var</span> out = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.io.FileOutputStream&quot;</span>).$new(file);</span><br><span class="line">                <span class="keyword">var</span> r;</span><br><span class="line">                <span class="keyword">while</span>( (r = arg0.<span class="title function_">read</span>(buffer)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    out.<span class="title function_">write</span>(buffer,<span class="number">0</span>,r)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;证书保存成功!&quot;</span>)</span><br><span class="line">                out.<span class="title function_">close</span>()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">load</span>(arg0, arg1);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://matriy330.github.io">Matriy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://matriy330.github.io/f3acfce3/">http://matriy330.github.io/f3acfce3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://matriy330.github.io" target="_blank">Matriy's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><div class="post-share"><div class="social-share" data-image="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/zsm.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/zsm.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/zfb.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/zfb.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/b20671e0/" title="Android逆向1-smali"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-25</div><div class="info-item-2">Android逆向1-smali</div></div><div class="info-2"><div class="info-item-1">Android逆向1-smali来自吾爱破解-正己 https://www.52pojie.cn/thread-1701353-1-1.html 1. JVM、Dalvik、ART JVM是JAVA虚拟机，运行JAVA字节码程序 Dalvik是Google专门为Android设计的一个虚拟机，Dalvik有专属的文件执行格式dex(Dalvik executable) Art(Android Runtime)相当于Dalvik的升级版，本质与Dalvik无异  2. smali及其语法smali是Dalvik的寄存器语言，smali代码是dex反编译而来的。 关键字    名称 注释    .class 类名   .super 父类名，继承的上级类名名称   .source 源名   .field 变量   .method 方法名   .register 寄存器   .end...</div></div></div></a><a class="pagination-related" href="/c47c9f7e/" title="Android逆向10-Frida_Native"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-28</div><div class="info-item-2">Android逆向10-Frida_Native</div></div><div class="info-2"><div class="info-item-1">Android逆向10-Frida_Native来自吾爱破解-正己 https://www.52pojie.cn/thread-1701353-1-1.html Process、Module、MemoryProcess 对象代表当前被Hook的进程，能获取进程的信息，枚举模块，枚举范围等    API 含义    Process.id 返回附加目标进程的 PID   Process.isDebuggerAttached() 检测当前是否对目标程序已经附加   Process.enumerateModules() 枚举当前加载的模块，返回模块对象的数组   Process.enumerateThreads() 枚举当前所有的线程，返回包含 id, state, context 等属性的对象数组   Module 对象代表一个加载到进程的模块(例如，在 Windows 上的 DLL，或在 Linux&#x2F;Android 上的 .so...</div></div></div></a><a class="pagination-related" href="/3761fa33/" title="Android逆向11-Frida进阶"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-29</div><div class="info-item-2">Android逆向11-Frida进阶</div></div><div class="info-2"><div class="info-item-1">Android逆向11-Frida进阶来自吾爱破解-正己 https://www.52pojie.cn/thread-1701353-1-1.html Frida写数据12345678//一般写在app的私有目录里，不然会报错:failed to open file (Permission denied)(实际上就是权限不足)var file_path = &quot;/data/user/0/com.zj.wuaipojie/test.txt&quot;;var file_handle = new File(file_path, &quot;wb&quot;);if (file_handle &amp;&amp; file_handle != null) &#123;        file_handle.write(data); //写入数据        file_handle.flush(); //刷新        file_handle.close(); //关闭&#125;  Frida_inlineHook与读写汇编什么是inlinehook？ Inline...</div></div></div></a><a class="pagination-related" href="/3fc95872/" title="Android逆向12-RPC"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-30</div><div class="info-item-2">Android逆向12-RPC</div></div><div class="info-2"><div class="info-item-1">Android逆向12-RPC来自吾爱破解-正己 https://www.52pojie.cn/thread-1701353-1-1.html RPC（Remote Procedure Call Protocol） 是一种远程过程调用协议，允许程序在不同的计算机上请求服务，而无需了解底层网络技术。RPC的主要作用是使不同服务之间的方法调用像本地调用一样便捷 Hook_Libartlibart.so: 在 Android 5.0（Lollipop）及更高版本中，libart.so 是 Android 运行时（ART，Android Runtime）的核心组件，它取代了之前的 Dalvik 虚拟机。可以在 libart.so 里找到 JNI 相关的实现。 PS:在高于安卓10的系统里，so的路径是&#x2F;apex&#x2F;com.android.runtime&#x2F;lib64&#x2F;libart.so，低于10的则在system&#x2F;lib64&#x2F;libart.so    函数名称 参数 描述 返回值    RegisterNatives JNIEnv...</div></div></div></a><a class="pagination-related" href="/d81ca9c8/" title="Android逆向13-例题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-01</div><div class="info-item-2">Android逆向13-例题</div></div><div class="info-2"><div class="info-item-1">Android逆向13-例题初级112345方法1:var ClassName=Java.use(&quot;com.zj.wuaipojie2024_1.YSQDActivity&quot;); console.log(ClassName.extractDataFromFile(&quot;/data/user/0/com.zj.wuaipojie2024_1/files/ys.mp4&quot;));方法2:android intent launch_activity com.zj.wuaipojie2024_1.YSQDActivity  初级2123456789101112131415161718方法1:android intent launch_activity com.kbtx.redpack_simple.FlagActivity方法2:function hookTest1()&#123;    var Arrays = Java.use(&quot;java.util.Arrays&quot;);   ...</div></div></div></a><a class="pagination-related" href="/ac0392ad/" title="Android逆向16-Flutter"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-08</div><div class="info-item-2">Android逆向16-Flutter</div></div><div class="info-2"><div class="info-item-1">Android逆向16-FlutterFlutter是Google构建在开源的Dart VM之上，使用Dart语言开发的移动应用开发框架，可以帮助开发者使用一套Dart代码就能快速在移动iOS 、Android上构建高质量的原生用户界面，同时还支持开发Web和桌面应用。 Flutter引擎是一个用于高质量跨平台应用的可移植运行时，由C/C++编写。它实现了Flutter的核心库，包括动画和图形、文件和网络I&#x2F;O、辅助功能支持、插件架构，以及用于开发、编译和运行Flutter应用程序的Dart运行时和工具链。引擎将底层C++代码包装成 Dart代码，通过dart:ui暴露给 Flutter框架层。 flutter开源地址 flutter官网 原创]Flutter概述和逆向技术发展时间线，带你快速了解 在逆向分析前，我们首先要确定测试目标是否用Flutter开发的。当使用Flutter构建Android...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Matriy</div><div class="author-info-description">不积硅步，无以至千里</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">219</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Matriy330"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">正在学习安卓逆向 (*^_^*)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Android%E9%80%86%E5%90%9115-%E6%8A%93%E5%8C%85"><span class="toc-text">Android逆向15-抓包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">抓包基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%93%E5%8C%85%E6%A3%80%E6%B5%8B"><span class="toc-text">抓包检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VPN%E6%A3%80%E6%B5%8B"><span class="toc-text">VPN检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSL-Pinning"><span class="toc-text">SSL Pinning</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E7%BA%B9%E6%A0%A1%E9%AA%8C"><span class="toc-text">指纹校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C"><span class="toc-text">证书校验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81"><span class="toc-text">双向认证</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2ade85f8/" title="DASCTF 2023 10 wp">DASCTF 2023 10 wp</a><time datetime="2025-10-02T16:00:00.000Z" title="发表于 2025-10-03 00:00:00">2025-10-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/41a159b6/" title="Angr 学习">Angr 学习</a><time datetime="2025-10-01T16:00:00.000Z" title="发表于 2025-10-02 00:00:00">2025-10-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/d932918b/" title="ios逆向初探">ios逆向初探</a><time datetime="2025-09-26T16:00:00.000Z" title="发表于 2025-09-27 00:00:00">2025-09-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/3a852357/" title="MoeCTF 2025 wp">MoeCTF 2025 wp</a><time datetime="2025-09-24T16:00:00.000Z" title="发表于 2025-09-25 00:00:00">2025-09-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/947a6269/" title="TSCTF 2022 wp">TSCTF 2022 wp</a><time datetime="2025-09-22T16:00:00.000Z" title="发表于 2025-09-23 00:00:00">2025-09-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Matriy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank" href="https://hexo.io/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px"target="_blank" href="https://www.jsdelivr.com/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px"target="_blank" href="https://github.com/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p> <p>Hi, welcome to Matriy's <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.open-ctf.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo.open-ctf.top/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script async data-pjax src="/js/anzhiyu.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href="/music/"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>