<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android逆向14-Frida检测 | Matriy's blog</title><meta name="author" content="Matriy"><meta name="copyright" content="Matriy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Android逆向14-Frida检测来自吾爱破解-正己 https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-1701353-1-1.html 检测文件名、端口名、双进程保护、失效的检测点检测&#x2F;data&#x2F;local&#x2F;tmp路径下的是否有frida特征文件，server端改名，例如:fr 指定端口转发 123.&#x2F;fs1 -l 0.0.0.0:6666adb fo">
<meta property="og:type" content="article">
<meta property="og:title" content="Android逆向14-Frida检测">
<meta property="og:url" content="http://matriy330.github.io/4152d38e/index.html">
<meta property="og:site_name" content="Matriy&#39;s blog">
<meta property="og:description" content="Android逆向14-Frida检测来自吾爱破解-正己 https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-1701353-1-1.html 检测文件名、端口名、双进程保护、失效的检测点检测&#x2F;data&#x2F;local&#x2F;tmp路径下的是否有frida特征文件，server端改名，例如:fr 指定端口转发 123.&#x2F;fs1 -l 0.0.0.0:6666adb fo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg">
<meta property="article:published_time" content="2025-05-01T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-13T07:47:50.440Z">
<meta property="article:author" content="Matriy">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Android逆向14-Frida检测",
  "url": "http://matriy330.github.io/4152d38e/",
  "image": "https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg",
  "datePublished": "2025-05-01T16:00:00.000Z",
  "dateModified": "2025-05-13T07:47:50.440Z",
  "author": [
    {
      "@type": "Person",
      "name": "Matriy",
      "url": "http://matriy330.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/bitbug_favicon.ico"><link rel="canonical" href="http://matriy330.github.io/4152d38e/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="G-ShTqjjywiLkL87Rg0PaiSsDVYymWStdQUO1wrM_VY"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: Matriy","link":"链接: ","source":"来源: Matriy's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}
</script><link rel="stylesheet" href="/css/custom.css"><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android逆向14-Frida检测',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/music.css"><link rel="stylesheet" href="/css/comment.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/img/bg.jpeg);"></div><div id="an_music_bg" style="background-image: url(/img/bg.jpeg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">222</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent;"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Matriy's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Android逆向14-Frida检测</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Android逆向14-Frida检测</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-01T16:00:00.000Z" title="发表于 2025-05-02 00:00:00">2025-05-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-13T07:47:50.440Z" title="更新于 2025-05-13 15:47:50">2025-05-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/4152d38e/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Android逆向14-Frida检测"><a href="#Android逆向14-Frida检测" class="headerlink" title="Android逆向14-Frida检测"></a>Android逆向14-Frida检测</h1><p>来自吾爱破解-正己</p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1701353-1-1.html">https://www.52pojie.cn/thread-1701353-1-1.html</a></p>
<h2 id="检测文件名、端口名、双进程保护、失效的检测点"><a href="#检测文件名、端口名、双进程保护、失效的检测点" class="headerlink" title="检测文件名、端口名、双进程保护、失效的检测点"></a>检测文件名、端口名、双进程保护、失效的检测点</h2><p>检测&#x2F;data&#x2F;local&#x2F;tmp路径下的是否有frida特征文件，server端改名，例如:fr</p>
<p>指定端口转发</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./fs1 -l 0.0.0.0:6666</span><br><span class="line">adb forward tcp:6666 tcp:6666</span><br><span class="line">frida -H 127.0.0.1:6666 wuaipojie -l hook.js</span><br></pre></td></tr></table></figure>

<p>spawn启动过双进程保护</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -f 进程名 -l hook.js</span><br></pre></td></tr></table></figure>

<p>PS:学会看注入报错的日志，比如说当app主动附加自身进程时，这时候再注入就会提示<code>run frida as root</code>（以spawn的方式启动进程即可）</p>
<p>借助脚本定位检测frida的so</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hook_dlopen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(<span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="literal">null</span>, <span class="string">&quot;android_dlopen_ext&quot;</span>),</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> pathptr = args[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (pathptr !== <span class="literal">undefined</span> &amp;&amp; pathptr != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">var</span> path = <span class="title function_">ptr</span>(pathptr).<span class="title function_">readCString</span>();</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;load &quot;</span> + path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着firda的版本迭代，以前诸多检测点以失效</p>
<p>例如<code>检测D-Bus</code>:D-Bus是一种进程间通信(IPC)和远程过程调用(RPC)机制,最初是为Linux开发的,目的是用一个统一的协议替代现有的和竞争的IPC解决方案。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">bool <span class="title function_">check_dbus</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义一个socket地址结构体变量sa</span></span><br><span class="line">    struct sockaddr_in sa;</span><br><span class="line">    <span class="comment">// 创建一个socket文件描述符</span></span><br><span class="line">    int sock;</span><br><span class="line">    <span class="comment">// 定义一个字符数组res，用于存储接收到的数据</span></span><br><span class="line">    char res[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历所有可能的端口号，从0到65535</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt;= <span class="number">65535</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的socket连接</span></span><br><span class="line">        sock = <span class="title function_">socket</span>(<span class="variable constant_">AF_INET</span>, <span class="variable constant_">SOCK_STREAM</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置socket地址结构体的端口号</span></span><br><span class="line">        sa.<span class="property">sin_port</span> = <span class="title function_">htons</span>(i);</span><br><span class="line">        <span class="comment">// 尝试连接到当前端口</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">connect</span>(sock, (struct sockaddr*)&amp;sa, <span class="title function_">sizeof</span>(sa)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果连接成功，记录日志信息，表示发现了一个开放的端口</span></span><br><span class="line">            <span class="title function_">__android_log_print</span>(<span class="variable constant_">ANDROID_LOG_VERBOSE</span>, <span class="string">&quot;ZJ595&quot;</span>, <span class="string">&quot;FRIDA DETECTION [1]: Open Port: %d&quot;</span>, i);</span><br><span class="line">            <span class="comment">// 初始化res数组，清零</span></span><br><span class="line">            <span class="title function_">memset</span>(res, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">            <span class="comment">// 向socket发送一个空字节</span></span><br><span class="line">            <span class="title function_">send</span>(sock, <span class="string">&quot;\x00&quot;</span>, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 注意这里的NULL被替换为0</span></span><br><span class="line">            <span class="comment">// 发送AUTH请求</span></span><br><span class="line">            <span class="title function_">send</span>(sock, <span class="string">&quot;AUTH\r\n&quot;</span>, <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 等待100微秒</span></span><br><span class="line">            <span class="title function_">usleep</span>(<span class="number">100</span>);</span><br><span class="line">            <span class="comment">// 尝试接收响应</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">recv</span>(sock, res, <span class="number">6</span>, <span class="variable constant_">MSG_DONTWAIT</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果接收到响应，检查响应内容是否为&quot;REJECT&quot;</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">strcmp</span>(res, <span class="string">&quot;REJECT&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果是，关闭socket并返回true，表示检测到了Frida服务器</span></span><br><span class="line">                    <span class="title function_">close</span>(sock);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// Frida server detected</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前端口连接失败或没有检测到Frida服务器，关闭socket</span></span><br><span class="line">        <span class="title function_">close</span>(sock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果遍历完所有端口都没有检测到Frida服务器，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// No Frida server detected</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>检测fd</p>
<p>&#x2F;proc&#x2F;pid&#x2F;fd 目录的作用在于提供了一种方便的方式来查看进程的文件描述符信息，这对于调试和监控进程非常有用。通过查看文件描述符信息，可以了解进程打开了哪些文件、网络连接等，帮助开发者和系统管理员进行问题排查和分析工作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">bool <span class="title function_">check_fd</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable constant_">DIR</span> *dir = <span class="variable constant_">NULL</span>;</span><br><span class="line">    struct dirent *entry;</span><br><span class="line">    char link_name[<span class="number">100</span>];</span><br><span class="line">    char buf[<span class="number">100</span>];</span><br><span class="line">    bool ret = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ((dir = <span class="title function_">opendir</span>(<span class="string">&quot;/proc/self/fd/&quot;</span>)) == <span class="variable constant_">NULL</span>) &#123;</span><br><span class="line">        <span class="title function_">LOGI</span>(<span class="string">&quot; %s - %d  error:%s&quot;</span>, __FILE__, __LINE__, <span class="title function_">strerror</span>(errno));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        entry = <span class="title function_">readdir</span>(dir);</span><br><span class="line">        <span class="keyword">while</span> (entry) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (entry-&gt;d_type) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="attr">DT_LNK</span>:</span><br><span class="line">                    <span class="title function_">sprintf</span>(link_name, <span class="string">&quot;%s/%s&quot;</span>, <span class="string">&quot;/proc/self/fd/&quot;</span>, entry-&gt;d_name);</span><br><span class="line">                    <span class="title function_">readlink</span>(link_name, buf, <span class="title function_">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span> (<span class="title function_">strstr</span>(buf, <span class="string">&quot;frida&quot;</span>) || <span class="title function_">strstr</span>(buf, <span class="string">&quot;gum-js-loop&quot;</span>) ||</span><br><span class="line">                        <span class="title function_">strstr</span>(buf, <span class="string">&quot;gmain&quot;</span>) ||</span><br><span class="line">                        <span class="title function_">strstr</span>(buf, <span class="string">&quot;-gadget&quot;</span>) || <span class="title function_">strstr</span>(buf, <span class="string">&quot;linjector&quot;</span>)) &#123;</span><br><span class="line">                        <span class="title function_">LOGI</span>(<span class="string">&quot;check_fd -&gt; find frida:%s&quot;</span>, buf);</span><br><span class="line">                        ret = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="attr">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            entry = <span class="title function_">readdir</span>(dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">closedir</span>(dir);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>检测文件</code></p>
<p>众所周知frida我们一般都会放在data&#x2F;local&#x2F;tmp目录下，旧版fridaserver端运行时都会释放到re.frida.server，所以这里在旧版也会被当做一个检测点，而新版已不再释放</p>
<h2 id="检测map"><a href="#检测map" class="headerlink" title="检测map"></a>检测map</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250508200413047.png" alt="image-20250508200413047"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell ps | findstr com.zj.wuaipojie</span><br><span class="line">cat /proc/12186/maps|grep frida</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250508200429619.png" alt="image-20250508200429619"></p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">u0_a504</td>
<td align="left">用户ID和应用ID：在Android系统中，<code>u0</code>代表系统用户（user 0），而<code>a504</code>是该应用在用户0下的唯一标识符。</td>
</tr>
<tr>
<td align="left">28082</td>
<td align="left">PID（进程ID）：该进程在操作系统中的标识符。</td>
</tr>
<tr>
<td align="left">1935</td>
<td align="left">PPID（父进程ID）：该进程的父进程的PID。</td>
</tr>
<tr>
<td align="left">6511212</td>
<td align="left">虚拟内存：进程使用的虚拟内存大小，通常以字节为单位。</td>
</tr>
<tr>
<td align="left">125728</td>
<td align="left">共享内存：进程使用的共享内存大小，同样以字节为单位。</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">CPU时间&#x2F;线程数：这通常表示进程的CPU时间或者是线程数，具体含义取决于<code>ps</code>命令的输出格式。</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">状态：其中<code>S</code>代表睡眠状态（Sleeping），即进程没有在执行，而是在等待某些事件或资源。</td>
</tr>
</tbody></table>
<p><code>/proc/self/maps</code> 是一个特殊的文件，它包含了当前进程的内存映射信息。当你打开这个文件时，它会显示一个列表，其中包含了进程中每个内存区域的详细信息。这些信息通常包括：</p>
<ul>
<li>起始地址（Start Address）</li>
<li>结束地址（End Address）</li>
<li>权限（如可读、可写、可执行）</li>
<li>共享&#x2F;私有标志（Shared or Private）</li>
<li>关联的文件或设备（如果内存区域是文件映射的）</li>
<li>内存区域的偏移量</li>
<li>内存区域的类型（如匿名映射、文件映射、设备映射等）<br>当注入frida后，在maps文件中就会存在 <code>frida-agent-64.so</code>、<code>frida-agent-32.so</code> 等文件。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool <span class="title function_">check_maps</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义一个足够大的字符数组line，用于存储读取的行</span></span><br><span class="line">    char line[<span class="number">512</span>];</span><br><span class="line">    <span class="comment">// 打开当前进程的内存映射文件/proc/self/maps进行读取</span></span><br><span class="line">    <span class="variable constant_">FILE</span>* fp = <span class="title function_">fopen</span>(<span class="string">&quot;/proc/self/maps&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">        <span class="comment">// 如果文件成功打开，循环读取每一行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="title function_">fgets</span>(line, <span class="title function_">sizeof</span>(line), fp)) &#123;</span><br><span class="line">            <span class="comment">// 使用strstr函数检查当前行是否包含&quot;frida&quot;字符串</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">strstr</span>(line, <span class="string">&quot;frida&quot;</span>) || <span class="title function_">strstr</span>(line, <span class="string">&quot;gadget&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 如果找到了&quot;frida&quot;，关闭文件并返回true，表示检测到了恶意库</span></span><br><span class="line">                <span class="title function_">fclose</span>(fp);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// Evil library is loaded.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历完文件后，关闭文件</span></span><br><span class="line">        <span class="title function_">fclose</span>(fp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果无法打开文件，记录错误。这可能意味着系统状态异常</span></span><br><span class="line">        <span class="comment">// 注意：这里的代码没有处理错误，只是注释说明了可能的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有在内存映射文件中找到&quot;frida&quot;，返回false，表示没有检测到恶意库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// No evil library detected.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>anti脚本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数anti_maps，用于阻止特定字符串的搜索匹配，避免检测到敏感内容如&quot;Frida&quot;或&quot;REJECT&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">anti_maps</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 查找libc.so库中strstr函数的地址，strstr用于查找字符串中首次出现指定字符序列的位置</span></span><br><span class="line">    <span class="keyword">var</span> pt_strstr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&#x27;strstr&#x27;</span>);</span><br><span class="line">    <span class="comment">// 查找libc.so库中strcmp函数的地址，strcmp用于比较两个字符串</span></span><br><span class="line">    <span class="keyword">var</span> pt_strcmp = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&#x27;strcmp&#x27;</span>);</span><br><span class="line">    <span class="comment">// 使用Interceptor模块附加到strstr函数上，拦截并修改其行为</span></span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(pt_strstr, &#123;</span><br><span class="line">        <span class="comment">// 在strstr函数调用前执行的回调</span></span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取strstr的第一个参数（源字符串）和第二个参数（要查找的子字符串）</span></span><br><span class="line">            <span class="keyword">var</span> str1 = args[<span class="number">0</span>].<span class="title function_">readCString</span>();</span><br><span class="line">            <span class="keyword">var</span> str2 = args[<span class="number">1</span>].<span class="title function_">readCString</span>();</span><br><span class="line">            <span class="comment">// 检查子字符串是否包含&quot;REJECT&quot;或&quot;frida&quot;，如果包含则设置hook标志为true</span></span><br><span class="line">            <span class="keyword">if</span> (str2.<span class="title function_">indexOf</span>(<span class="string">&quot;REJECT&quot;</span>) !== -<span class="number">1</span>  || str2.<span class="title function_">indexOf</span>(<span class="string">&quot;frida&quot;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">hook</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 在strstr函数调用后执行的回调</span></span><br><span class="line">        <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果之前设置了hook标志，则将strstr的结果替换为0（表示未找到），从而隐藏敏感信息</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">hook</span>) &#123;</span><br><span class="line">                retval.<span class="title function_">replace</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对strcmp函数做类似的处理，防止通过字符串比较检测敏感信息</span></span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(pt_strcmp, &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> str1 = args[<span class="number">0</span>].<span class="title function_">readCString</span>();</span><br><span class="line">            <span class="keyword">var</span> str2 = args[<span class="number">1</span>].<span class="title function_">readCString</span>();</span><br><span class="line">            <span class="keyword">if</span> (str2.<span class="title function_">indexOf</span>(<span class="string">&quot;REJECT&quot;</span>) !== -<span class="number">1</span>  || str2.<span class="title function_">indexOf</span>(<span class="string">&quot;frida&quot;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">hook</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">hook</span>) &#123;</span><br><span class="line">                <span class="comment">// strcmp返回值为0表示两个字符串相等，这里同样替换为0以避免匹配成功</span></span><br><span class="line">                retval.<span class="title function_">replace</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250508201306008.png" alt="image-20250508201306008"></p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>重定向maps</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数，用于重定向并修改maps文件内容，以隐藏特定的库和路径信息</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mapsRedirect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义伪造的maps文件路径</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">FakeMaps</span> = <span class="string">&quot;/data/data/com.zj.wuaipojie/maps&quot;</span>;</span><br><span class="line">    <span class="comment">// 获取libc.so库中&#x27;open&#x27;函数的地址</span></span><br><span class="line">    <span class="keyword">const</span> openPtr = <span class="title class_">Module</span>.<span class="title function_">getExportByName</span>(<span class="string">&#x27;libc.so&#x27;</span>, <span class="string">&#x27;open&#x27;</span>);</span><br><span class="line">    <span class="comment">// 根据地址创建一个新的NativeFunction对象，表示原生的&#x27;open&#x27;函数</span></span><br><span class="line">    <span class="keyword">const</span> open = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(openPtr, <span class="string">&#x27;int&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>, <span class="string">&#x27;int&#x27;</span>]);</span><br><span class="line">    <span class="comment">// 查找并获取libc.so库中&#x27;read&#x27;函数的地址</span></span><br><span class="line">    <span class="keyword">var</span> readPtr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;read&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建新的NativeFunction对象表示原生的&#x27;read&#x27;函数</span></span><br><span class="line">    <span class="keyword">var</span> read = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(readPtr, <span class="string">&#x27;int&#x27;</span>, [<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;pointer&#x27;</span>, <span class="string">&quot;int&quot;</span>]);</span><br><span class="line">    <span class="comment">// 分配512字节的内存空间，用于临时存储从maps文件读取的内容</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">MapsBuffer</span> = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(<span class="number">512</span>);</span><br><span class="line">    <span class="comment">// 创建一个伪造的maps文件，用于写入修改后的内容，模式为&quot;w&quot;（写入）</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">MapsFile</span> = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="title class_">FakeMaps</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用Interceptor替换原有的&#x27;open&#x27;函数，注入自定义逻辑</span></span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">replace</span>(openPtr, <span class="keyword">new</span> <span class="title class_">NativeCallback</span>(<span class="keyword">function</span>(<span class="params">pathname, flag</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用原始的&#x27;open&#x27;函数，并获取文件描述符（FD）</span></span><br><span class="line">        <span class="keyword">var</span> <span class="variable constant_">FD</span> = <span class="title function_">open</span>(pathname, flag);</span><br><span class="line">        <span class="comment">// 读取并打印尝试打开的文件路径</span></span><br><span class="line">        <span class="keyword">var</span> ch = pathname.<span class="title function_">readCString</span>();</span><br><span class="line">        <span class="keyword">if</span> (ch.<span class="title function_">indexOf</span>(<span class="string">&quot;/proc/&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; ch.<span class="title function_">indexOf</span>(<span class="string">&quot;maps&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;open : &quot;</span>, pathname.<span class="title function_">readCString</span>());</span><br><span class="line">            <span class="comment">// 循环读取maps内容，并写入伪造的maps文件中，同时进行字符串替换以隐藏特定信息</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">parseInt</span>(<span class="title function_">read</span>(<span class="variable constant_">FD</span>, <span class="title class_">MapsBuffer</span>, <span class="number">512</span>)) !== <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="title class_">MBuffer</span> = <span class="title class_">MapsBuffer</span>.<span class="title function_">readCString</span>();</span><br><span class="line">                <span class="title class_">MBuffer</span> = <span class="title class_">MBuffer</span>.<span class="title function_">replaceAll</span>(<span class="string">&quot;/data/local/tmp/re.frida.server/frida-agent-64.so&quot;</span>, <span class="string">&quot;FakingMaps&quot;</span>);</span><br><span class="line">                <span class="title class_">MBuffer</span> = <span class="title class_">MBuffer</span>.<span class="title function_">replaceAll</span>(<span class="string">&quot;re.frida.server&quot;</span>, <span class="string">&quot;FakingMaps&quot;</span>);</span><br><span class="line">                <span class="title class_">MBuffer</span> = <span class="title class_">MBuffer</span>.<span class="title function_">replaceAll</span>(<span class="string">&quot;frida-agent-64.so&quot;</span>, <span class="string">&quot;FakingMaps&quot;</span>);</span><br><span class="line">                <span class="title class_">MBuffer</span> = <span class="title class_">MBuffer</span>.<span class="title function_">replaceAll</span>(<span class="string">&quot;frida-agent-32.so&quot;</span>, <span class="string">&quot;FakingMaps&quot;</span>);</span><br><span class="line">                <span class="title class_">MBuffer</span> = <span class="title class_">MBuffer</span>.<span class="title function_">replaceAll</span>(<span class="string">&quot;frida&quot;</span>, <span class="string">&quot;FakingMaps&quot;</span>);</span><br><span class="line">                <span class="title class_">MBuffer</span> = <span class="title class_">MBuffer</span>.<span class="title function_">replaceAll</span>(<span class="string">&quot;/data/local/tmp&quot;</span>, <span class="string">&quot;/data&quot;</span>);</span><br><span class="line">                <span class="comment">// 将修改后的内容写入伪造的maps文件</span></span><br><span class="line">                <span class="title class_">MapsFile</span>.<span class="title function_">write</span>(<span class="title class_">MBuffer</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 为返回伪造maps文件的打开操作，分配UTF8编码的文件名字符串</span></span><br><span class="line">            <span class="keyword">var</span> filename = <span class="title class_">Memory</span>.<span class="title function_">allocUtf8String</span>(<span class="title class_">FakeMaps</span>);</span><br><span class="line">            <span class="comment">// 返回打开伪造maps文件的文件描述符</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">open</span>(filename, flag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是目标maps文件，则直接返回原open调用的结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable constant_">FD</span>;</span><br><span class="line">    &#125;, <span class="string">&#x27;int&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>, <span class="string">&#x27;int&#x27;</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h3><p>用eBPF来hook系统调用并修改参数实现目的，使用bpf_probe_write_user向用户态函数地址写内容直接修改参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char placeholder[] = &quot;/data/data/com.zj.wuaipojie/maps&quot;;</span><br><span class="line">bpf_probe_write_user((void*)addr, placeholder, sizeof(placeholder));</span><br></pre></td></tr></table></figure>

<h2 id="检测status-线程名"><a href="#检测status-线程名" class="headerlink" title="检测status(线程名)"></a>检测status(线程名)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /proc/pid/task 列出线程id</span><br><span class="line">cat /proc/pid/task/线程id/status</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>/proc/pid/task</code> 目录下，可以通过查看不同的线程子目录，来获取进程中每个线程的运行时信息。这些信息包括线程的状态、线程的寄存器内容、线程占用的CPU时间、线程的堆栈信息等。通过这些信息，可以实时观察和监控进程中每个线程的运行状态，帮助进行调试、性能优化和问题排查等工作。</li>
<li>在某些app中就会去读取 <code>/proc/stask/线程ID/status</code> 文件，如果是运行frida产生的，则进行反调试。例如：<code>gmain/gdbus/gum-js-loop/pool-frida</code>等</li>
</ul>
<ol>
<li>gmain：Frida 使用 Glib 库，其中的主事件循环被称为 GMainLoop。在 Frida 中，gmain 表示 GMainLoop 的线程。</li>
<li>gdbus：GDBus 是 Glib 提供的一个用于 D-Bus 通信的库。在 Frida 中，gdbus 表示 GDBus 相关的线程。</li>
<li>gum-js-loop：Gum 是 Frida 的运行时引擎，用于执行注入的 JavaScript 代码。gum-js-loop 表示 Gum 引擎执行 JavaScript 代码的线程。</li>
<li>pool-frida：Frida 中的某些功能可能会使用线程池来处理任务，pool-frida 表示 Frida 中的线程池。</li>
<li>linjector 是一种用于 Android 设备的开源工具，它允许用户在运行时向 Android 应用程序注入动态链接库（DLL）文件。通过注入 DLL 文件，用户可以修改应用程序的行为、调试应用程序、监视函数调用等，这在逆向工程、安全研究和动态分析中是非常有用的。<br>PS:由于frida可以随时附加到进程，所以写的检测必须覆盖APP的全周期，或者至少是敏感函数执行前</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">bool <span class="title function_">check_status</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable constant_">DIR</span> *dir = <span class="title function_">opendir</span>(<span class="string">&quot;/proc/self/task/&quot;</span>);</span><br><span class="line">    struct dirent *entry;</span><br><span class="line">    char status_path[<span class="variable constant_">MAX_PATH</span>];</span><br><span class="line">    char buffer[<span class="variable constant_">MAX_BUFFER</span>];</span><br><span class="line">    int found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dir) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((entry = <span class="title function_">readdir</span>(dir)) != <span class="variable constant_">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;d_type == <span class="variable constant_">DT_DIR</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">strcmp</span>(entry-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="title function_">strcmp</span>(entry-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">snprintf</span>(status_path, <span class="title function_">sizeof</span>(status_path), <span class="string">&quot;/proc/self/task/%s/status&quot;</span>, entry-&gt;d_name);</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">read_file</span>(status_path, buffer, <span class="title function_">sizeof</span>(buffer)) == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">strcmp</span>(buffer, <span class="string">&quot;null&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                char *line = <span class="title function_">strtok</span>(buffer, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (line) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="title function_">strstr</span>(line, <span class="string">&quot;Name:&quot;</span>) != <span class="variable constant_">NULL</span>) &#123;</span><br><span class="line">                        <span class="keyword">const</span> char *frida_name = <span class="title function_">strstr</span>(line, <span class="string">&quot;gmain&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (frida_name || <span class="title function_">strstr</span>(line, <span class="string">&quot;gum-js-loop&quot;</span>) || <span class="title function_">strstr</span>(line, <span class="string">&quot;pool-frida&quot;</span>) || <span class="title function_">strstr</span>(line, <span class="string">&quot;gdbus&quot;</span>)) &#123;</span><br><span class="line">                            found = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    line = <span class="title function_">strtok</span>(<span class="variable constant_">NULL</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (found) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">closedir</span>(dir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>anti脚本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replace_str</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> pt_strstr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&#x27;strstr&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> pt_strcmp = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&#x27;strcmp&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(pt_strstr, &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> str1 = args[<span class="number">0</span>].<span class="title function_">readCString</span>();</span><br><span class="line">            <span class="keyword">var</span> str2 = args[<span class="number">1</span>].<span class="title function_">readCString</span>();</span><br><span class="line">            <span class="keyword">if</span> (str2.<span class="title function_">indexOf</span>(<span class="string">&quot;tmp&quot;</span>) !== -<span class="number">1</span> ||</span><br><span class="line">                str2.<span class="title function_">indexOf</span>(<span class="string">&quot;frida&quot;</span>) !== -<span class="number">1</span> ||</span><br><span class="line">                str2.<span class="title function_">indexOf</span>(<span class="string">&quot;gum-js-loop&quot;</span>) !== -<span class="number">1</span> ||</span><br><span class="line">                str2.<span class="title function_">indexOf</span>(<span class="string">&quot;gmain&quot;</span>) !== -<span class="number">1</span> ||</span><br><span class="line">                str2.<span class="title function_">indexOf</span>(<span class="string">&quot;gdbus&quot;</span>) !== -<span class="number">1</span> ||</span><br><span class="line">                str2.<span class="title function_">indexOf</span>(<span class="string">&quot;pool-frida&quot;</span>) !== -<span class="number">1</span>||</span><br><span class="line">                str2.<span class="title function_">indexOf</span>(<span class="string">&quot;linjector&quot;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//console.log(&quot;strcmp--&gt;&quot;, str1, str2);</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">hook</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">hook</span>) &#123;</span><br><span class="line">                retval.<span class="title function_">replace</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(pt_strcmp, &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> str1 = args[<span class="number">0</span>].<span class="title function_">readCString</span>();</span><br><span class="line">            <span class="keyword">var</span> str2 = args[<span class="number">1</span>].<span class="title function_">readCString</span>();</span><br><span class="line">            <span class="keyword">if</span> (str2.<span class="title function_">indexOf</span>(<span class="string">&quot;tmp&quot;</span>) !== -<span class="number">1</span> ||</span><br><span class="line">                str2.<span class="title function_">indexOf</span>(<span class="string">&quot;frida&quot;</span>) !== -<span class="number">1</span> ||</span><br><span class="line">                str2.<span class="title function_">indexOf</span>(<span class="string">&quot;gum-js-loop&quot;</span>) !== -<span class="number">1</span> ||</span><br><span class="line">                str2.<span class="title function_">indexOf</span>(<span class="string">&quot;gmain&quot;</span>) !== -<span class="number">1</span> ||</span><br><span class="line">                str2.<span class="title function_">indexOf</span>(<span class="string">&quot;gdbus&quot;</span>) !== -<span class="number">1</span> ||</span><br><span class="line">                str2.<span class="title function_">indexOf</span>(<span class="string">&quot;pool-frida&quot;</span>) !== -<span class="number">1</span>||</span><br><span class="line">                str2.<span class="title function_">indexOf</span>(<span class="string">&quot;linjector&quot;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//console.log(&quot;strcmp--&gt;&quot;, str1, str2);</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">hook</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">hook</span>) &#123;</span><br><span class="line">                retval.<span class="title function_">replace</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="检测inlinehook"><a href="#检测inlinehook" class="headerlink" title="检测inlinehook"></a>检测inlinehook</h2><p>通过Frida查看一个函数hook之前和之后的机器码，以此来判断是否被Frida的inlinehook注入。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250508201928352.png" alt="image-20250508201928352"></p>
<p>下面的方案以内存中字节和本地对应的字节进行比较，如果不一致，那么可以认为内存中的字节被修改了，即被inlinehook了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;jni.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;dlfcn.<span class="property">h</span>&gt;</span><br><span class="line">#include <span class="string">&quot;dlfcn/local_dlfcn.h&quot;</span></span><br><span class="line"></span><br><span class="line">bool <span class="title function_">check_inlinehook</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 根据系统架构选择对应的libc.so库路径</span></span><br><span class="line">    <span class="keyword">const</span> char *lib_path;</span><br><span class="line">    #ifdef __LP64__</span><br><span class="line">    lib_path = <span class="string">&quot;/system/lib64/libc.so&quot;</span>;</span><br><span class="line">    #<span class="keyword">else</span></span><br><span class="line">    lib_path = <span class="string">&quot;/system/lib/libc.so&quot;</span>;</span><br><span class="line">    #endif</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义要比较的字节数</span></span><br><span class="line">    <span class="keyword">const</span> int <span class="variable constant_">CMP_COUNT</span> = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 指定要查找的符号名，这里是&quot;open&quot;函数</span></span><br><span class="line">    <span class="keyword">const</span> char *sym_name = <span class="string">&quot;open&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用local_dlopen函数打开指定的共享库，并获取操作句柄</span></span><br><span class="line">    struct local_dlfcn_handle *handle = static_cast&lt;local_dlfcn_handle *&gt;(<span class="title function_">local_dlopen</span>(lib_path));</span><br><span class="line">    <span class="keyword">if</span> (!handle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable constant_">JNI_FALSE</span>; <span class="comment">// 如果无法打开共享库，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取&quot;open&quot;函数在libc.so中的偏移量</span></span><br><span class="line">    off_t offset = <span class="title function_">local_dlsym</span>(handle, sym_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭handle，因为我们接下来使用标准的dlopen/dlsy来获取函数地址</span></span><br><span class="line">    <span class="title function_">local_dlclose</span>(handle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开libc.so文件，准备读取数据</span></span><br><span class="line">    <span class="variable constant_">FILE</span> *fp = <span class="title function_">fopen</span>(lib_path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable constant_">JNI_FALSE</span>; <span class="comment">// 如果无法打开文件，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个缓冲区，用于存储读取的文件内容</span></span><br><span class="line">    char file_bytes[<span class="variable constant_">CMP_COUNT</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 读取指定偏移量处的CMP_COUNT个字节</span></span><br><span class="line">    <span class="title function_">fseek</span>(fp, offset, <span class="variable constant_">SEEK_SET</span>);</span><br><span class="line">    <span class="title function_">fread</span>(file_bytes, <span class="number">1</span>, <span class="variable constant_">CMP_COUNT</span>, fp);</span><br><span class="line">    <span class="title function_">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用dlopen函数打开libc.so共享库，并获取操作句柄</span></span><br><span class="line">    <span class="keyword">void</span> *dl_handle = <span class="title function_">dlopen</span>(lib_path, <span class="variable constant_">RTLD_NOW</span>);</span><br><span class="line">    <span class="keyword">if</span> (!dl_handle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable constant_">JNI_FALSE</span>; <span class="comment">// 如果无法打开共享库，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用dlsym函数获取&quot;open&quot;函数的地址</span></span><br><span class="line">    <span class="keyword">void</span> *sym = <span class="title function_">dlsym</span>(dl_handle, sym_name);</span><br><span class="line">    <span class="keyword">if</span> (!sym) &#123;</span><br><span class="line">        <span class="title function_">dlclose</span>(dl_handle);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable constant_">JNI_FALSE</span>; <span class="comment">// 如果无法找到符号，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较原libc.so中的&quot;open&quot;函数内容与通过dlsym获取的&quot;open&quot;函数内容是否一致</span></span><br><span class="line">    int is_hook = <span class="title function_">memcmp</span>(file_bytes, sym, <span class="variable constant_">CMP_COUNT</span>) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭dlopen打开的共享库句柄</span></span><br><span class="line">    <span class="title function_">dlclose</span>(dl_handle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回比较结果，如果函数被hook则返回JNI_TRUE，否则返回JNI_FALSE</span></span><br><span class="line">    <span class="keyword">return</span> is_hook ? <span class="variable constant_">JNI_TRUE</span> : <span class="variable constant_">JNI_FALSE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取hook前字节码的脚本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bytes_count = <span class="number">8</span></span><br><span class="line"><span class="keyword">let</span> address = <span class="title class_">Module</span>.<span class="title function_">getExportByName</span>(<span class="string">&quot;libc.so&quot;</span>,<span class="string">&quot;open&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> before = <span class="title function_">ptr</span>(address)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; before hook: &quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hexdump</span>(before, &#123;</span><br><span class="line">    <span class="attr">offset</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">length</span>: bytes_count,</span><br><span class="line">    <span class="attr">header</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">ansi</span>: <span class="literal">true</span></span><br><span class="line">  &#125;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>anti脚本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hook_memcmp_addr</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//hook反调试</span></span><br><span class="line">    <span class="keyword">var</span> memcmp_addr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;fread&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (memcmp_addr !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fread address: &quot;</span>, memcmp_addr);</span><br><span class="line">        <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(memcmp_addr, &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">buffer</span> = args[<span class="number">0</span>];   <span class="comment">// 保存 buffer 参数</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">size</span> = args[<span class="number">1</span>];     <span class="comment">// 保存 size 参数</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">count</span> = args[<span class="number">2</span>];    <span class="comment">// 保存 count 参数</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">stream</span> = args[<span class="number">3</span>];   <span class="comment">// 保存 FILE* 参数</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里可以修改 buffer 的内容，假设我们知道何时 fread 被用于敏感操作</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">count</span>.<span class="title function_">toInt32</span>());</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span>.<span class="title function_">toInt32</span>() == <span class="number">8</span>) &#123;</span><br><span class="line">                <span class="comment">// 模拟 fread 读取了预期数据，伪造返回值</span></span><br><span class="line">                <span class="title class_">Memory</span>.<span class="title function_">writeByteArray</span>(<span class="variable language_">this</span>.<span class="property">buffer</span>, [<span class="number">0x50</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x58</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x1f</span>, <span class="number">0xd6</span>]);</span><br><span class="line">                retval.<span class="title function_">replace</span>(<span class="number">8</span>); <span class="comment">// 填充前8字节</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hexdump</span>(<span class="variable language_">this</span>.<span class="property">buffer</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Error: memcmp function not found in libc.so&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="刷入魔改的frida-server端"><a href="#刷入魔改的frida-server端" class="headerlink" title="刷入魔改的frida-server端"></a>刷入魔改的frida-server端</h2><p>注意版本！！！</p>
<p><a target="_blank" rel="noopener" href="https://github.com/hzzheyang/strongR-frida-android">strongR-frida-android</a></p>
<h2 id="Syscall-SVC-自定义strstr"><a href="#Syscall-SVC-自定义strstr" class="headerlink" title="Syscall&amp;SVC&amp;自定义strstr"></a>Syscall&amp;SVC&amp;自定义strstr</h2><p>在上面的检测对抗中，我们hook了libc.so中的fread、strstr、open等系统函数，但是如果app不讲武德，自实现这些函数，阁下又该如何应对？</p>
<p>在用户空间和内核空间之间，有一个叫做Syscall(系统调用, system call)的中间层，是连接用户态和内核态的桥梁。这样即提高了内核的安全型，也便于移植，只需实现同一套接口即可。Linux系统，用户空间通过向内核空间发出Syscall，产生软中断，从而让程序陷入内核态，执行相应的操作。</p>
<p><strong>SVC(软件中断指令)指令</strong>：在ARM架构的系统中，<code>svc</code>是一条特殊的指令，它允许用户态的程序发起一个系统调用。当这条指令被执行时，CPU会从用户态切换到内核态，从而允许内核处理这个请求。</p>
<p>Linux操作系统是一个巨大的图书馆，而<code>syscall</code>就是这个图书馆的前台服务窗口。当一个应用程序（比如一个读者）需要借阅书籍（获取系统资源或服务）时，它不能直接进入图书馆的内部书架去拿书，因为那样可能会造成混乱和损坏。所以，读者需要通过前台服务窗口，也就是<code>syscall</code>，来请求它想要的书籍。</p>
<p><code>svc</code>就像是图书馆前台服务窗口的内部电话。当读者通过前台窗口提出请求时，前台工作人员会通过内部电话（<code>svc</code>）来联系图书馆的内部工作人员，请求他们找到并提供所需的书籍。在Linux系统中，当一个程序通过<code>syscall</code>请求服务时，实际上是通过<code>svc</code>这条指令通知内核，然后由内核来处理这些请求。</p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-280343.htm#/">Frida-Sigaction-Seccomp实现对Android APP系统调用的拦截</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-271815.htm">分享一个Android通用svc跟踪以及hook方案——Frida-Seccomp</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-277544.htm#/">基于seccomp+sigaction的Android通用svc hook方案</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273160.htm">原创]SVC的TraceHook沙箱的实现&amp;无痕Hook实现思路</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-276585.htm">原创]Seccomp技术在Android应用中的滥用与防护</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-269895.htm">原创]批量检测android app的so中是否有svc调用</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/95a5834b93e0e9b4656b2ee59d3b03f26690.png" alt="图片"></p>
<ol>
<li>首先当我们长按开机键（电源按钮）开机，此时会引导芯片开始从固化到ROM中的预设代码处执行，然后加载引导程序到RAM。然后启动加载的引导程序，引导程序主要做一些基本的检查，包括RAM的检查，初始化硬件的参数。</li>
<li>到达内核层的流程后，这里初始化一些进程管理、内存管理、加载各种Driver等相关操作，如Camera Driver、Binder Driver 等。下一步就是内核线程，如软中断线程、内核守护线程。下面一层就是Native层，这里额外提一点知识，层于层之间是不可以直接通信的，所以需要一种中间状态来通信。Native层和Kernel层之间通信用的是syscall，Native层和Java层之间的通信是JNI。</li>
<li>在Native层会初始化init进程，也就是用户组进程的祖先进程。init中加载配置文件init.rc，init.rc中孵化出ueventd、logd、healthd、installd、lmkd等用户守护进程。开机动画启动等操作。核心的一步是孵化出Zygote进程，此进程是所有APP的父进程，这也是Xposed注入的核心，同时也是Android的第一个Java进程（虚拟机进程）。</li>
<li>进入框架层后，加载zygote init类，注册zygote socket套接字，通过此套接字来做进程通信，并加载虚拟机、类、系统资源等。zygote第一个孵化的进程是system_server进程，负责启动和管理整个Java Framework，包含ActivityManager、PowerManager等服务。</li>
<li>应用层的所有APP都是从zygote孵化而来</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">bool <span class="title function_">anti_anti_maps</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义一个足够大的字符数组line，用于存储读取的行</span></span><br><span class="line">    <span class="keyword">const</span> int buf_size = <span class="number">512</span>;</span><br><span class="line">    char buf[buf_size];</span><br><span class="line">    int fd;  <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="comment">// 使用 my_openat 打开当前进程的内存映射文件 /proc/self/maps 进行读取</span></span><br><span class="line">    <span class="comment">// AT_FDCWD 表示当前工作目录，&quot;r&quot; 表示只读方式打开</span></span><br><span class="line">    fd = <span class="title function_">my_openat</span>(<span class="variable constant_">AT_FDCWD</span>, <span class="string">&quot;/proc/self/maps&quot;</span>, <span class="variable constant_">O_RDONLY</span> | <span class="variable constant_">O_CLOEXEC</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果文件成功打开，循环读取每一行</span></span><br><span class="line">        <span class="keyword">while</span> ((<span class="title function_">read_line</span>(fd, buf, buf_size)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用strstr函数检查当前行是否包含&quot;frida&quot;字符串</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">strstr</span>(buf, <span class="string">&quot;frida&quot;</span>) || <span class="title function_">strstr</span>(buf, <span class="string">&quot;gadget&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 如果找到了&quot;frida&quot;，关闭文件并返回true，表示检测到了恶意库</span></span><br><span class="line">                <span class="title function_">close</span>(fd);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// Evil library is loaded.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历完文件后，关闭文件</span></span><br><span class="line">        <span class="title function_">close</span>(fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果无法打开文件，记录错误。这可能意味着系统状态异常</span></span><br><span class="line">        <span class="comment">// 注意：这里的代码没有处理错误，只是注释说明了可能的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有在内存映射文件中找到&quot;frida&quot;，返回false，表示没有检测到恶意库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// No evil library detected.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">ENTRY</span>(my_openat)  <span class="comment">// 定义函数入口，标签my_openat</span></span><br><span class="line">    mov     x8, __NR_openat  <span class="comment">// 将openat系统调用号（__NR_openat）移动到x8寄存器，x8用于存储系统调用号</span></span><br><span class="line">    svc     #<span class="number">0</span>               <span class="comment">// 触发系统调用异常，进入操作系统执行系统调用</span></span><br><span class="line">    cmn     x0, #(<span class="variable constant_">MAX_ERRNO</span> + <span class="number">1</span>)  <span class="comment">// 将函数返回值（存储在x0寄存器）与MAX_ERRNO + 1进行无符号比较</span></span><br><span class="line">    cneg    x0, x0, hi       <span class="comment">// 如果上面的比较结果大于或等于零（即没有错误），则将x0的符号位取反（如果原来是负则变正）</span></span><br><span class="line">    b.<span class="property">hi</span>    __set_errno_internal  <span class="comment">// 如果上面的比较结果大于或等于零（即发生了错误），则跳转到__set_errno_internal进行错误处理</span></span><br><span class="line">    ret                       <span class="comment">// 从函数返回，继续执行调用者代码</span></span><br><span class="line"><span class="title function_">END</span>(my_openat)  <span class="comment">// 标记函数结束</span></span><br></pre></td></tr></table></figure>

<p>anti脚本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">anti_svc</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> target_code_hex;  <span class="comment">// 用于搜索特定汇编指令序列的十六进制字符串</span></span><br><span class="line">    <span class="keyword">let</span> call_number_openat;  <span class="comment">// 系统调用号对应的数值，openat</span></span><br><span class="line">    <span class="keyword">let</span> arch = <span class="title class_">Process</span>.<span class="property">arch</span>;  <span class="comment">// 获取当前进程的架构</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;arm&quot;</span> === arch)&#123;  <span class="comment">// 如果架构是ARM</span></span><br><span class="line">        target_code_hex = <span class="string">&quot;00 00 00 EF&quot;</span>;  <span class="comment">// ARM架构下svc指令的十六进制表示</span></span><br><span class="line">        call_number_openat = <span class="number">322</span>;  <span class="comment">// openat在ARM架构中的系统调用号</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;arm64&quot;</span> === arch)&#123;  <span class="comment">// 如果架构是ARM64</span></span><br><span class="line">        target_code_hex = <span class="string">&quot;01 00 00 D4&quot;</span>;  <span class="comment">// ARM64架构下svc指令的十六进制表示</span></span><br><span class="line">        call_number_openat = <span class="number">56</span>;  <span class="comment">// openat在ARM64架构中的系统调用号</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arch not support!&quot;</span>);  <span class="comment">// 如果架构不支持，打印错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arch)&#123;  <span class="comment">// 如果成功获取了架构信息</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;\nthe_arch = &quot;</span> + arch);  <span class="comment">// 打印当前架构</span></span><br><span class="line">        <span class="comment">// 枚举进程的内存范围，寻找只读内存段</span></span><br><span class="line">        <span class="title class_">Process</span>.<span class="title function_">enumerateRanges</span>(<span class="string">&#x27;r--&#x27;</span>).<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">range</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!range.<span class="property">file</span> || !range.<span class="property">file</span>.<span class="property">path</span>)&#123;  <span class="comment">// 如果内存段没有文件路径，跳过</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> path = range.<span class="property">file</span>.<span class="property">path</span>;  <span class="comment">// 获取内存段的文件路径</span></span><br><span class="line">            <span class="comment">// 如果文件路径不是以&quot;/data/app/&quot;开头或不以&quot;.so&quot;结尾，跳过</span></span><br><span class="line">            <span class="keyword">if</span> ((!path.<span class="title function_">startsWith</span>(<span class="string">&quot;/data/app/&quot;</span>)) || (!path.<span class="title function_">endsWith</span>(<span class="string">&quot;.so&quot;</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> baseAddress = <span class="title class_">Module</span>.<span class="title function_">getBaseAddress</span>(path);  <span class="comment">// 获取so库的基址</span></span><br><span class="line">            <span class="keyword">let</span> soNameList = path.<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>);  <span class="comment">// 通过路径分割获取so库的名称</span></span><br><span class="line">            <span class="keyword">let</span> soName = soNameList[soNameList.<span class="property">length</span> - <span class="number">1</span>];  <span class="comment">// 获取so库的名称</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;\npath = &quot;</span> + path + <span class="string">&quot; , baseAddress = &quot;</span> + baseAddress + </span><br><span class="line">                        <span class="string">&quot; , rangeAddress = &quot;</span> + range.<span class="property">base</span> + <span class="string">&quot; , size = &quot;</span> + range.<span class="property">size</span>);</span><br><span class="line">            <span class="comment">// 在so库的内存范围内搜索target_code_hex对应的指令序列</span></span><br><span class="line">            <span class="title class_">Memory</span>.<span class="title function_">scan</span>(range.<span class="property">base</span>, range.<span class="property">size</span>, target_code_hex, &#123;</span><br><span class="line">                <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">match</span>)&#123;</span><br><span class="line">                    <span class="keyword">let</span> code_address = match;  <span class="comment">// 获取匹配到的指令地址</span></span><br><span class="line">                    <span class="keyword">let</span> code_address_str = code_address.<span class="title function_">toString</span>();  <span class="comment">// 转换为字符串</span></span><br><span class="line">                    <span class="comment">// 如果地址的最低位是0, 4, 8, c中的任意一个，说明可能是svc指令</span></span><br><span class="line">                    <span class="keyword">if</span> (code_address_str.<span class="title function_">endsWith</span>(<span class="string">&quot;0&quot;</span>) || code_address_str.<span class="title function_">endsWith</span>(<span class="string">&quot;4&quot;</span>) || </span><br><span class="line">                        code_address_str.<span class="title function_">endsWith</span>(<span class="string">&quot;8&quot;</span>) || code_address_str.<span class="title function_">endsWith</span>(<span class="string">&quot;c&quot;</span>))&#123;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">                        <span class="keyword">let</span> call_number = <span class="number">0</span>;  <span class="comment">// 初始化系统调用号</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;arm&quot;</span> === arch)&#123;</span><br><span class="line">                            <span class="comment">// 获取svc指令后面的立即数，作为系统调用号</span></span><br><span class="line">                            call_number = (code_address.<span class="title function_">sub</span>(<span class="number">0x4</span>).<span class="title function_">readS32</span>()) &amp; <span class="number">0xFFF</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;arm64&quot;</span> === arch)&#123;</span><br><span class="line">                            call_number = (code_address.<span class="title function_">sub</span>(<span class="number">0x4</span>).<span class="title function_">readS32</span>() &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;the arch get call_number not support!&quot;</span>);  <span class="comment">// 如果架构不支持，打印错误信息</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;find svc : so_name = &quot;</span> + soName + <span class="string">&quot; , address = &quot;</span> + code_address + </span><br><span class="line">                                    <span class="string">&quot; , call_number = &quot;</span> + call_number + <span class="string">&quot; , offset = &quot;</span> + code_address.<span class="title function_">sub</span>(baseAddress));</span><br><span class="line">                        <span class="comment">// 如果匹配到的系统调用号是openat，挂钩该地址</span></span><br><span class="line">                        <span class="keyword">if</span> (call_number_openat === call_number)&#123;</span><br><span class="line">                            <span class="keyword">let</span> target_hook_addr = code_address;</span><br><span class="line">                            <span class="keyword">let</span> target_hook_addr_offset = target_hook_addr.<span class="title function_">sub</span>(baseAddress);</span><br><span class="line">                            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;find svc openat , start inlinehook by frida!&quot;</span>);</span><br><span class="line">                            <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(target_hook_addr, &#123;</span><br><span class="line">                                <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>)&#123;  <span class="comment">// 当进入挂钩函数时</span></span><br><span class="line">                                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;\nonEnter_&quot;</span> + target_hook_addr_offset + <span class="string">&quot; , __NR_openat , args[1] = &quot;</span> + </span><br><span class="line">                                                  args[<span class="number">1</span>].<span class="title function_">readCString</span>());</span><br><span class="line">                                    <span class="comment">// 修改openat的第一个参数为指定路径</span></span><br><span class="line">                                    <span class="variable language_">this</span>.<span class="property">new_addr</span> = <span class="title class_">Memory</span>.<span class="title function_">allocUtf8String</span>(<span class="string">&quot;/data/user/0/com.zj.wuaipojie/maps&quot;</span>);</span><br><span class="line">                                    args[<span class="number">1</span>] = <span class="variable language_">this</span>.<span class="property">new_addr</span>;</span><br><span class="line">                                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onEnter_&quot;</span> + target_hook_addr_offset + <span class="string">&quot; , __NR_openat , args[1] = &quot;</span> + </span><br><span class="line">                                                  args[<span class="number">1</span>].<span class="title function_">readCString</span>());</span><br><span class="line">                                &#125;, </span><br><span class="line">                                <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>)&#123;  <span class="comment">// 当离开挂钩函数时</span></span><br><span class="line">                                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onLeave_&quot;</span> + target_hook_addr_offset + <span class="string">&quot; , __NR_openat , retval = &quot;</span> + retval)</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, </span><br><span class="line">                <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;  <span class="comment">// 搜索完成后的回调函数</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义strstr</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">bool <span class="title function_">anti_str_maps</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 定义一个足够大的字符数组line，用于存储读取的行</span></span><br><span class="line">    char line[<span class="number">512</span>];</span><br><span class="line">    <span class="comment">// 打开当前进程的内存映射文件/proc/self/maps进行读取</span></span><br><span class="line">    <span class="variable constant_">FILE</span>* fp = <span class="title function_">fopen</span>(<span class="string">&quot;/proc/self/maps&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">        <span class="comment">// 如果文件成功打开，循环读取每一行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="title function_">fgets</span>(line, <span class="title function_">sizeof</span>(line), fp)) &#123;</span><br><span class="line">            <span class="comment">// 使用自定义strstr函数检查当前行是否包含&quot;frida&quot;指纹</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">my_strstr</span>(line, <span class="string">&quot;frida&quot;</span>) || <span class="title function_">my_strstr</span>(line, <span class="string">&quot;gadget&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 如果找到了，关闭文件并返回true，表示检测到了恶意库</span></span><br><span class="line">                <span class="title function_">fclose</span>(fp);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历完文件后，关闭文件</span></span><br><span class="line">        <span class="title function_">fclose</span>(fp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果无法打开文件，记录错误。这可能意味着系统状态异常</span></span><br><span class="line">        <span class="comment">// 注意：这里的代码没有处理错误，只是注释说明了可能的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有在内存映射文件中找到&quot;frida&quot;，返回false，表示没有检测到恶意库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自实现了libc里的几个系统函数</span></span><br><span class="line"><span class="title function_">__attribute__</span>((always_inline))</span><br><span class="line"><span class="keyword">static</span> inline char *</span><br><span class="line"><span class="title function_">my_strstr</span>(<span class="params"><span class="keyword">const</span> char *s, <span class="keyword">const</span> char *find</span>)</span><br><span class="line">&#123;</span><br><span class="line">    char c, sc;</span><br><span class="line">    size_t len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((c = *find++) != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        len = <span class="title function_">my_strlen</span>(find);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc = *s++) == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> (<span class="variable constant_">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">while</span> (sc != c);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="title function_">my_strncmp</span>(s, find, len) != <span class="number">0</span>);</span><br><span class="line">        s--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((char *)s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="frida持久化方案"><a href="#frida持久化方案" class="headerlink" title="frida持久化方案"></a>frida持久化方案</h2><h3 id="免root方案"><a href="#免root方案" class="headerlink" title="免root方案"></a>免root方案</h3><p>Frida的Gadget是一个共享库，用于免root注入hook脚本。</p>
<p><a target="_blank" rel="noopener" href="https://frida.re/docs/gadget/#/">官方文档</a></p>
<p>思路:将APK解包后，通过修改smali代码或patch so文件的方式植入frida-gadget，然后重新打包安装。</p>
<p>优点:免ROOT、能过掉一部分检测机制</p>
<p>缺点:重打包可能会遇到解决不了的签名校验、hook时机需要把握</p>
<p>基于obejction的patchapk功能</p>
<p>官方文档命令：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objection patchapk -V 14.2.18 -c config.txt -s demo.apk(注意路径不要有中文)</span><br><span class="line"><span class="deletion">-V 指定gadget版本</span></span><br><span class="line"><span class="deletion">-c 加载脚本配置信息</span></span><br><span class="line"><span class="deletion">-s 要注入的apk</span></span><br></pre></td></tr></table></figure>

<p>注意的问题:<br><code>objection patchapk</code>命令基本上是其他几个系统命令的补充，可尽可能地自动化修补过程。当然，需要先安装并启用这些命令。它们是：</p>
<ul>
<li><code>aapt</code>- 来自：<a target="_blank" rel="noopener" href="http://elinux.org/Android_aapt">http://elinux.org/Android_aapt</a></li>
<li><code>adb</code>- 来自：<a target="_blank" rel="noopener" href="https://developer.android.com/studio/command-line/adb.html">https://developer.android.com/studio/command-line/adb.html</a></li>
<li><code>jarsigner</code>- 来自：<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jarsigner.html">http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jarsigner.html</a></li>
<li><code>apktool</code>- 来自：<a target="_blank" rel="noopener" href="https://ibotpeaches.github.io/Apktool/">https://ibotpeaches.github.io/Apktool/</a></li>
</ul>
<p>ps:这几个环境工具，aapt、jarsigner都是Android Studio自带的，所以在配置好as的环境即可，abd的环境配置网上搜一下就行，apktool则需要额外配置</p>
<p>另外会遇到的问题，patchapk的功能在patch的时候会下载对应版本的gadget的so，但是网络问题异常慢，所以建议根据链接去下载好，然后放到这个路径下并重命名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\用户名\.objection\android\arm64-v8a\libfrida-gadget.so</span><br></pre></td></tr></table></figure>

<h3 id="root方案"><a href="#root方案" class="headerlink" title="root方案"></a>root方案</h3><p>方法一:</p>
<p>思路:可以patch &#x2F;data&#x2F;app&#x2F;pkgname&#x2F;lib&#x2F;arm64(or arm)目录下的so文件，apk安装后会将so文件解压到该目录并在运行时加载，修改该目录下的文件不会触发签名校验。</p>
<p>Patch SO的原理可以参考<a target="_blank" rel="noopener" href="https://gslab.qq.com/portal.php?mod=view&aid=163">Android平台感染ELF文件实现模块注入</a></p>
<p>优点:绕过签名校验、root检测和部分ptrace保护。</p>
<p>缺点:需要root、高版本系统下，当manifest中的android:extractNativeLibs为false时，lib目录文件可能不会被加载，而是直接映射apk中的so文件、可能会有so完整性校验</p>
<p>使用方法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python LIEFInjectFrida.py test.apk ./ lib52pojie.so -apksign -persistence</span><br><span class="line">test.apk要注入的apk名称</span><br><span class="line">lib52pojie.so要注入的so名称</span><br></pre></td></tr></table></figure>

<p>然后提取patch后是so文件放到对应的so目录下</p>
<p>方法二:</p>
<p>思路:基于magisk模块方案注入frida-gadget，实现加载和hook。寒冰师傅的<a target="_blank" rel="noopener" href="https://github.com/hanbinglengyue/FridaManager">FridaManager</a></p>
<p>优点:无需重打包、灵活性较强</p>
<p>缺点:需要过root检测，magsik检测</p>
<p>方法三:</p>
<p>思路:基于jshook封装好的fridainject框架实现hook</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Xposed-Modules-Repo/me.jsonet.jshook">JsHook</a></p>
<h3 id="源码定制方案"><a href="#源码定制方案" class="headerlink" title="源码定制方案"></a>源码定制方案</h3><p>原理:修改aosp源代码,在fork子进程的时候注入frida-gadget</p>
<p><a target="_blank" rel="noopener" href="https://www.mobibrw.com/2021/28588#/">ubuntu 20.04系统AOSP(Android 11)集成Frida</a></p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1740214-1-1.html#/">AOSP Android 10内置FridaGadget实践01</a></p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1748101-1-1.html">AOSP Android 10内置FridaGadget实践02(完)</a>|</p>
<h2 id="其他检测思路与反思"><a href="#其他检测思路与反思" class="headerlink" title="其他检测思路与反思"></a>其他检测思路与反思</h2><p>1.检测方法签名信息，frida在hook方法的时候会把java方法转为native方法</p>
<p>2.Frida在attach进程注入SO时会显式地校验ELF_magic字段，不对则直接报错退出进程，可以手动在内存中抹掉SO的magic，达到反调试的效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">somain = api-&gt;solist_get_somain ();</span><br><span class="line">gum_init_soinfo_details (&amp;details, somain, api, &amp;ranges);</span><br><span class="line">api-&gt;solist_get_head ()</span><br><span class="line">gum_init_soinfo_details (&amp;details, si, api, &amp;ranges);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int getsomainoff = findsym(&quot;/system/bin/linker64&quot;,&quot;__dl__ZL6somain&quot;);</span><br><span class="line">*(long*)((char*)start+getsomainoff)=0;</span><br></pre></td></tr></table></figure>

<p>3.通常inline hook第一条指令是mov 常数到寄存器，然后第二条是一个br 寄存器指令。检查第二条指令高16位是不是0xd61f,就可以判断目标函数是否被inline hook了！</p>
<p>4.还可以去hook加固壳，现在很多加固厂商都antifrida了，从壳中的代码去分析检测思路</p>
<table>
<thead>
<tr>
<th align="left">反调试现状</th>
<th align="left">详细说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">检测方式多样</td>
<td align="left">从通用检测、hook检测到源码检测，方式层出不穷。源码检测可以针对每行代码都能开发出不同检测方式，Frida指纹过多。</td>
</tr>
<tr>
<td align="left">检测位置不确定</td>
<td align="left">一般是单独开线程跑，也可以在关键函数执行前判断</td>
</tr>
<tr>
<td align="left">强混淆加大定位难度</td>
<td align="left">反调试通常埋几行代码，但结合混淆可达万行代码，不考虑效率可膨胀更多，定位极难</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://matriy330.github.io">Matriy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://matriy330.github.io/4152d38e/">http://matriy330.github.io/4152d38e/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://matriy330.github.io" target="_blank">Matriy's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><div class="post-share"><div class="social-share" data-image="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/zsm.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/zsm.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/zfb.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/zfb.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/b20671e0/" title="Android逆向1-smali"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-25</div><div class="info-item-2">Android逆向1-smali</div></div><div class="info-2"><div class="info-item-1">Android逆向1-smali来自吾爱破解-正己 https://www.52pojie.cn/thread-1701353-1-1.html 1. JVM、Dalvik、ART JVM是JAVA虚拟机，运行JAVA字节码程序 Dalvik是Google专门为Android设计的一个虚拟机，Dalvik有专属的文件执行格式dex(Dalvik executable) Art(Android Runtime)相当于Dalvik的升级版，本质与Dalvik无异  2. smali及其语法smali是Dalvik的寄存器语言，smali代码是dex反编译而来的。 关键字    名称 注释    .class 类名   .super 父类名，继承的上级类名名称   .source 源名   .field 变量   .method 方法名   .register 寄存器   .end...</div></div></div></a><a class="pagination-related" href="/c47c9f7e/" title="Android逆向10-Frida_Native"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-28</div><div class="info-item-2">Android逆向10-Frida_Native</div></div><div class="info-2"><div class="info-item-1">Android逆向10-Frida_Native来自吾爱破解-正己 https://www.52pojie.cn/thread-1701353-1-1.html Process、Module、MemoryProcess 对象代表当前被Hook的进程，能获取进程的信息，枚举模块，枚举范围等    API 含义    Process.id 返回附加目标进程的 PID   Process.isDebuggerAttached() 检测当前是否对目标程序已经附加   Process.enumerateModules() 枚举当前加载的模块，返回模块对象的数组   Process.enumerateThreads() 枚举当前所有的线程，返回包含 id, state, context 等属性的对象数组   Module 对象代表一个加载到进程的模块(例如，在 Windows 上的 DLL，或在 Linux&#x2F;Android 上的 .so...</div></div></div></a><a class="pagination-related" href="/3761fa33/" title="Android逆向11-Frida进阶"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-29</div><div class="info-item-2">Android逆向11-Frida进阶</div></div><div class="info-2"><div class="info-item-1">Android逆向11-Frida进阶来自吾爱破解-正己 https://www.52pojie.cn/thread-1701353-1-1.html Frida写数据12345678//一般写在app的私有目录里，不然会报错:failed to open file (Permission denied)(实际上就是权限不足)var file_path = &quot;/data/user/0/com.zj.wuaipojie/test.txt&quot;;var file_handle = new File(file_path, &quot;wb&quot;);if (file_handle &amp;&amp; file_handle != null) &#123;        file_handle.write(data); //写入数据        file_handle.flush(); //刷新        file_handle.close(); //关闭&#125;  Frida_inlineHook与读写汇编什么是inlinehook？ Inline...</div></div></div></a><a class="pagination-related" href="/3fc95872/" title="Android逆向12-RPC"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-30</div><div class="info-item-2">Android逆向12-RPC</div></div><div class="info-2"><div class="info-item-1">Android逆向12-RPC来自吾爱破解-正己 https://www.52pojie.cn/thread-1701353-1-1.html RPC（Remote Procedure Call Protocol） 是一种远程过程调用协议，允许程序在不同的计算机上请求服务，而无需了解底层网络技术。RPC的主要作用是使不同服务之间的方法调用像本地调用一样便捷 Hook_Libartlibart.so: 在 Android 5.0（Lollipop）及更高版本中，libart.so 是 Android 运行时（ART，Android Runtime）的核心组件，它取代了之前的 Dalvik 虚拟机。可以在 libart.so 里找到 JNI 相关的实现。 PS:在高于安卓10的系统里，so的路径是&#x2F;apex&#x2F;com.android.runtime&#x2F;lib64&#x2F;libart.so，低于10的则在system&#x2F;lib64&#x2F;libart.so    函数名称 参数 描述 返回值    RegisterNatives JNIEnv...</div></div></div></a><a class="pagination-related" href="/d81ca9c8/" title="Android逆向13-例题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-01</div><div class="info-item-2">Android逆向13-例题</div></div><div class="info-2"><div class="info-item-1">Android逆向13-例题初级112345方法1:var ClassName=Java.use(&quot;com.zj.wuaipojie2024_1.YSQDActivity&quot;); console.log(ClassName.extractDataFromFile(&quot;/data/user/0/com.zj.wuaipojie2024_1/files/ys.mp4&quot;));方法2:android intent launch_activity com.zj.wuaipojie2024_1.YSQDActivity  初级2123456789101112131415161718方法1:android intent launch_activity com.kbtx.redpack_simple.FlagActivity方法2:function hookTest1()&#123;    var Arrays = Java.use(&quot;java.util.Arrays&quot;);   ...</div></div></div></a><a class="pagination-related" href="/ac0392ad/" title="Android逆向16-Flutter"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-08</div><div class="info-item-2">Android逆向16-Flutter</div></div><div class="info-2"><div class="info-item-1">Android逆向16-FlutterFlutter是Google构建在开源的Dart VM之上，使用Dart语言开发的移动应用开发框架，可以帮助开发者使用一套Dart代码就能快速在移动iOS 、Android上构建高质量的原生用户界面，同时还支持开发Web和桌面应用。 Flutter引擎是一个用于高质量跨平台应用的可移植运行时，由C/C++编写。它实现了Flutter的核心库，包括动画和图形、文件和网络I&#x2F;O、辅助功能支持、插件架构，以及用于开发、编译和运行Flutter应用程序的Dart运行时和工具链。引擎将底层C++代码包装成 Dart代码，通过dart:ui暴露给 Flutter框架层。 flutter开源地址 flutter官网 原创]Flutter概述和逆向技术发展时间线，带你快速了解 在逆向分析前，我们首先要确定测试目标是否用Flutter开发的。当使用Flutter构建Android...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Matriy</div><div class="author-info-description">不积硅步，无以至千里</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">222</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Matriy330"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">正在学习安卓逆向 (*^_^*)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Android%E9%80%86%E5%90%9114-Frida%E6%A3%80%E6%B5%8B"><span class="toc-text">Android逆向14-Frida检测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E5%90%8D%E3%80%81%E7%AB%AF%E5%8F%A3%E5%90%8D%E3%80%81%E5%8F%8C%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%8A%A4%E3%80%81%E5%A4%B1%E6%95%88%E7%9A%84%E6%A3%80%E6%B5%8B%E7%82%B9"><span class="toc-text">检测文件名、端口名、双进程保护、失效的检测点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8Bmap"><span class="toc-text">检测map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%951"><span class="toc-text">方法1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%952"><span class="toc-text">方法2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%953"><span class="toc-text">方法3</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8Bstatus-%E7%BA%BF%E7%A8%8B%E5%90%8D"><span class="toc-text">检测status(线程名)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8Binlinehook"><span class="toc-text">检测inlinehook</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B7%E5%85%A5%E9%AD%94%E6%94%B9%E7%9A%84frida-server%E7%AB%AF"><span class="toc-text">刷入魔改的frida-server端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Syscall-SVC-%E8%87%AA%E5%AE%9A%E4%B9%89strstr"><span class="toc-text">Syscall&amp;SVC&amp;自定义strstr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#frida%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-text">frida持久化方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%8Droot%E6%96%B9%E6%A1%88"><span class="toc-text">免root方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#root%E6%96%B9%E6%A1%88"><span class="toc-text">root方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%AE%9A%E5%88%B6%E6%96%B9%E6%A1%88"><span class="toc-text">源码定制方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%A3%80%E6%B5%8B%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%8F%8D%E6%80%9D"><span class="toc-text">其他检测思路与反思</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/32958ffb/" title="CTF逆向常见反调试技术总结">CTF逆向常见反调试技术总结</a><time datetime="2025-10-06T16:00:00.000Z" title="发表于 2025-10-07 00:00:00">2025-10-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/32958ffb/" title="CTF逆向常见反调试技术总结">CTF逆向常见反调试技术总结</a><time datetime="2025-10-06T16:00:00.000Z" title="发表于 2025-10-07 00:00:00">2025-10-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/65f6ce99/" title="游戏逆向初探">游戏逆向初探</a><time datetime="2025-10-05T16:00:00.000Z" title="发表于 2025-10-06 00:00:00">2025-10-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2ade85f8/" title="DASCTF 2023 10 wp">DASCTF 2023 10 wp</a><time datetime="2025-10-02T16:00:00.000Z" title="发表于 2025-10-03 00:00:00">2025-10-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/41a159b6/" title="Angr 学习">Angr 学习</a><time datetime="2025-10-01T16:00:00.000Z" title="发表于 2025-10-02 00:00:00">2025-10-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Matriy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank" href="https://hexo.io/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px"target="_blank" href="https://www.jsdelivr.com/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px"target="_blank" href="https://github.com/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p> <p>Hi, welcome to Matriy's <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.open-ctf.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo.open-ctf.top/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script async data-pjax src="/js/anzhiyu.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href="/music/"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>