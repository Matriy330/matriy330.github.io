<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android逆向17-抓包进阶 | Matriy's blog</title><meta name="author" content="Matriy"><meta name="copyright" content="Matriy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Android逆向17-抓包进阶来自吾爱破解-正己 https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-1701353-1-1.html Hook抓包&amp;&amp;关键定位&amp;&amp;混淆对抗Hook 抓包是一种截取应用程序数据包的方法，通过 Hook 应用或系统函数来获取数据流。在应用层 Hook 时，通过查找触发请求的函数来抓包，优点是不受防抓包手段影响，缺点是抓包数据不">
<meta property="og:type" content="article">
<meta property="og:title" content="Android逆向17-抓包进阶">
<meta property="og:url" content="http://matriy330.github.io/c2ef4741/index.html">
<meta property="og:site_name" content="Matriy&#39;s blog">
<meta property="og:description" content="Android逆向17-抓包进阶来自吾爱破解-正己 https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-1701353-1-1.html Hook抓包&amp;&amp;关键定位&amp;&amp;混淆对抗Hook 抓包是一种截取应用程序数据包的方法，通过 Hook 应用或系统函数来获取数据流。在应用层 Hook 时，通过查找触发请求的函数来抓包，优点是不受防抓包手段影响，缺点是抓包数据不">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg">
<meta property="article:published_time" content="2025-05-08T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-13T07:47:50.445Z">
<meta property="article:author" content="Matriy">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Android逆向17-抓包进阶",
  "url": "http://matriy330.github.io/c2ef4741/",
  "image": "https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg",
  "datePublished": "2025-05-08T16:00:00.000Z",
  "dateModified": "2025-05-13T07:47:50.445Z",
  "author": [
    {
      "@type": "Person",
      "name": "Matriy",
      "url": "http://matriy330.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/bitbug_favicon.ico"><link rel="canonical" href="http://matriy330.github.io/c2ef4741/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="G-ShTqjjywiLkL87Rg0PaiSsDVYymWStdQUO1wrM_VY"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: Matriy","link":"链接: ","source":"来源: Matriy's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}
</script><link rel="stylesheet" href="/css/custom.css"><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android逆向17-抓包进阶',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/music.css"><link rel="stylesheet" href="/css/comment.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/img/bg.jpeg);"></div><div id="an_music_bg" style="background-image: url(/img/bg.jpeg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">204</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent;"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Matriy's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Android逆向17-抓包进阶</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Android逆向17-抓包进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-08T16:00:00.000Z" title="发表于 2025-05-09 00:00:00">2025-05-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-13T07:47:50.445Z" title="更新于 2025-05-13 15:47:50">2025-05-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/c2ef4741/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Android逆向17-抓包进阶"><a href="#Android逆向17-抓包进阶" class="headerlink" title="Android逆向17-抓包进阶"></a>Android逆向17-抓包进阶</h1><p>来自吾爱破解-正己</p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1701353-1-1.html">https://www.52pojie.cn/thread-1701353-1-1.html</a></p>
<h2 id="Hook抓包-关键定位-混淆对抗"><a href="#Hook抓包-关键定位-混淆对抗" class="headerlink" title="Hook抓包&amp;&amp;关键定位&amp;&amp;混淆对抗"></a>Hook抓包&amp;&amp;关键定位&amp;&amp;混淆对抗</h2><p>Hook 抓包是一种截取应用程序数据包的方法，通过 Hook 应用或系统函数来获取数据流。在应用层 Hook 时，通过查找触发请求的函数来抓包，优点是不受防抓包手段影响，缺点是抓包数据不便于我们分析和筛选。</p>
<p>常见安卓网络开发框架</p>
<table>
<thead>
<tr>
<th align="left">框架名称</th>
<th align="left">描述</th>
<th align="left">GitHub 地址</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Volley</td>
<td align="left">由Google开源的轻量级网络库，支持网络请求处理、小图片的异步加载和缓存等功能</td>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/google/volley">https://github.com/google/volley</a></td>
</tr>
<tr>
<td align="left">Android-async-http</td>
<td align="left">基于Apache HttpClient的一个异步网络请求处理库</td>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/android-async-http/android-async-http">https://github.com/android-async-http/android-async-http</a></td>
</tr>
<tr>
<td align="left">xUtils</td>
<td align="left">类似于Afinal，但被认为是Afinal的一个升级版，提供了HTTP请求的支持</td>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/wyouflf/xUtils3">https://github.com/wyouflf/xUtils3</a></td>
</tr>
<tr>
<td align="left">OkHttp</td>
<td align="left">一个高性能的网络框架，已经被Google官方认可，在Android 6.0中底层源码已经使用了OkHttp来替代HttpURLConnection</td>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/square/okhttp">https://github.com/square/okhttp</a></td>
</tr>
<tr>
<td align="left">Retrofit</td>
<td align="left">提供了一种类型安全的HTTP客户端接口，简化了HTTP请求的编写，通常与OkHttp配合使用</td>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/square/retrofit">https://github.com/square/retrofit</a></td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liyutian/p/9489016.html">【译】OkHttp3 拦截器（Interceptor）</a></p>
<p>拦截器是 OkHttp 提供的对 Http 请求和响应进行统一处理的强大机制，它可以实现网络监听、请求以及响应重写、请求失败充实等功能。<br>OkHttp 中的 Interceptor 就是典型的责任链的实现，它可以设置任意数量的 Intercepter 来对网络请求及其响应做任何中间处理，比如设置缓存，Https证书认证，统一对请求加密&#x2F;防篡改社会，打印log，过滤请求等等。<br>OkHttp 中的拦截器分为 Application Interceptor（应用拦截器） 和 NetWork Interceptor（网络拦截器）两种</p>
<ul>
<li>Network Interceptor（网络拦截器）<br>通过调用 OkHttpClient.Builder 的 addNetworkInterceptor() 方法来注册网络拦截器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = new OkHttpClient.Builder()</span><br><span class="line">    .addNetworkInterceptor(new LoggingInterceptor())</span><br><span class="line">    .build();</span><br><span class="line">Request request = new Request.Builder()</span><br><span class="line">    .url(&quot;https://www.52pojie.cn/&quot;)</span><br><span class="line">    .header(&quot;User-Agent&quot;, &quot;OkHttp Example&quot;)</span><br><span class="line">    .build();</span><br><span class="line">Response response = client.newCall(request).execute();</span><br><span class="line">response.body().close();</span><br></pre></td></tr></table></figure>

<p>参考项目:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/siyujie/OkHttpLogger-Frida">OkHttpLogger-Frida</a></p>
<p><code>源码解析:</code></p>
<p><a target="_blank" rel="noopener" href="https://github.com/siyujie/okhttp_find/blob/dc69bb2faebb45ba803dc3389bdfdc22bf584e34/librarys/src/main/java/com/singleman/okhttp/OkHttpFinder.java#L68">定位OkHttpClient关键点</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找并配置OkHttpClient的Client和Builder类。</span></span><br><span class="line"><span class="comment"> * 该方法通过反射扫描指定类的字段和方法来确定其是否符合OkHttpClient的结构特征。</span></span><br><span class="line"><span class="comment"> * 如果找到符合的类，则会进一步配置和注入相关拦截器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> classes   当前扫描的类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> className 类名，用于查找和调试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findClientAndBuilderAndBuildAnd</span><span class="params">(Class classes, String className)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 确认类是final且静态</span></span><br><span class="line">        <span class="keyword">if</span> (Modifier.isFinal(classes.getModifiers())</span><br><span class="line">                &amp;&amp; Modifier.isStatic(classes.getModifiers())) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">listCount</span> <span class="operator">=</span> <span class="number">0</span>;         <span class="comment">// 记录List类型字段的数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">finalListCount</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 记录final修饰的List字段数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">listInterfaceCount</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 记录List中包含接口的字段数量</span></span><br><span class="line">            Field[] fields = classes.getDeclaredFields();</span><br><span class="line">            Field.setAccessible(fields, <span class="literal">true</span>); <span class="comment">// 设置字段访问权限</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> field.getType().getName();</span><br><span class="line">                <span class="keyword">if</span> (type.contains(List.class.getName())) &#123;</span><br><span class="line">                    listCount++; <span class="comment">// 判断字段是否为List类型</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 检查List是否是接口类型</span></span><br><span class="line">                    <span class="type">Class</span> <span class="variable">genericClass</span> <span class="operator">=</span> getGenericClass(field);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> != genericClass &amp;&amp; genericClass.isInterface()) &#123;</span><br><span class="line">                        listInterfaceCount++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断字段是否为final修饰的List类型</span></span><br><span class="line">                <span class="keyword">if</span> (type.contains(List.class.getName()) &amp;&amp; Modifier.isFinal(field.getModifiers())) &#123;</span><br><span class="line">                    finalListCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 符合OkHttpClient特征的条件检查</span></span><br><span class="line">            <span class="keyword">if</span> (listCount == <span class="number">4</span> &amp;&amp; finalListCount == <span class="number">2</span> &amp;&amp; listInterfaceCount == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取并确认OkHttpClient的包结构和父类</span></span><br><span class="line">                <span class="type">Class</span> <span class="variable">OkHttpClientClazz</span> <span class="operator">=</span> classes.getEnclosingClass();</span><br><span class="line">                <span class="keyword">if</span> (Cloneable.class.isAssignableFrom(OkHttpClientClazz)) &#123;</span><br><span class="line">                    OkCompat.Cls_OkHttpClient = OkHttpClientClazz.getName();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> != classes &amp;&amp; <span class="literal">null</span> != classes.getPackage()) &#123;</span><br><span class="line">                        Compat_PackageName = classes.getPackage().getName();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">Class</span> <span class="variable">builderClazz</span> <span class="operator">=</span> classes;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 查找并注入拦截器</span></span><br><span class="line">                    find_interceptor(builderClazz);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 查找OkHttpClient相关类</span></span><br><span class="line">                    findClientAbout(OkHttpClientClazz);</span><br><span class="line"></span><br><span class="line">                    findTag1 = <span class="literal">true</span>; <span class="comment">// 标记找到目标</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">        <span class="comment">// 捕获所有异常以防止中断流程，但不处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找并注入Interceptor拦截器到Builder类中。</span></span><br><span class="line"><span class="comment"> * 此方法会扫描Builder类的字段，找到符合拦截器的字段并进行配置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> builderClazz 需要查找的Builder类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">find_interceptor</span><span class="params">(Class builderClazz)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查包名是否符合条件</span></span><br><span class="line">    <span class="keyword">if</span> (!checkPackage(builderClazz)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Field[] declaredFields = builderClazz.getDeclaredFields();</span><br><span class="line">    Field.setAccessible(declaredFields, <span class="literal">true</span>); <span class="comment">// 设置字段访问权限</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用于计数找到的拦截器字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Field field : declaredFields) &#123;</span><br><span class="line">        <span class="comment">// 检查字段是否为final修饰的List类型且包含接口</span></span><br><span class="line">        <span class="keyword">if</span> (List.class.isAssignableFrom(field.getType()) &amp;&amp; Modifier.isFinal(field.getModifiers())</span><br><span class="line">                &amp;&amp; getGenericClass(field).isInterface()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 注入自定义Interceptor，提供给JS调用的回调</span></span><br><span class="line">                findInterceptor(field);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/siyujie/OkHttpLogger-Frida/blob/c70da16d107c67d451d7112cfee7ee090589a527/okhttp_poker.js#L489">拦截器加载关键点</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hookRealCall - 拦截 OkHttp 的 RealCall 类的网络请求。</span></span><br><span class="line"><span class="comment"> * 该方法通过拦截 RealCall 类的 `enqueue`（异步请求）和 `execute`（同步请求）方法，</span></span><br><span class="line"><span class="comment"> * 实现对网络请求和响应的捕获和处理。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;string&#125; realCallClassName - OkHttp RealCall 类的完整类名。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">function <span class="title function_">hookRealCall</span><span class="params">(realCallClassName)</span> &#123;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        console.log(<span class="string">&quot; ...........  hookRealCall  : &quot;</span> + realCallClassName)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 RealCall 类</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">RealCall</span> <span class="operator">=</span> Java.use(realCallClassName)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否定义了 Cls_CallBack 类（用于异步请求拦截）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span> != Cls_CallBack) &#123;</span><br><span class="line">            <span class="comment">// 拦截 RealCall 类中的异步方法 enqueue</span></span><br><span class="line">            RealCall[M_Call_enqueue].overload(Cls_CallBack).implementation = function (callback) &#123;</span><br><span class="line">                <span class="comment">// 获取 callback 的类</span></span><br><span class="line">                <span class="type">var</span> <span class="variable">realCallBack</span> <span class="operator">=</span> Java.use(callback.$className)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 拦截 callback 中的 onResponse 方法，修改返回的响应数据</span></span><br><span class="line">                realCallBack[M_CallBack_onResponse].overload(Cls_Call, Cls_Response).implementation = function(call, response) &#123;</span><br><span class="line">                    <span class="comment">// 使用自定义的 buildNewResponse 方法创建新的响应数据</span></span><br><span class="line">                    <span class="type">var</span> <span class="variable">newResponse</span> <span class="operator">=</span> buildNewResponse(response)</span><br><span class="line">                    <span class="comment">// 继续执行原始的 onResponse 方法，传入新的响应数据</span></span><br><span class="line">                    <span class="built_in">this</span>[M_CallBack_onResponse](call, newResponse)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用原始的 enqueue 方法，传入修改后的 callback</span></span><br><span class="line">                <span class="built_in">this</span>[M_Call_enqueue](callback)</span><br><span class="line">                <span class="comment">// 释放 callback 类引用</span></span><br><span class="line">                realCallBack.$dispose</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拦截 RealCall 类中的同步方法 execute</span></span><br><span class="line">        RealCall[M_Call_execute].overload().implementation = function () &#123;</span><br><span class="line">            <span class="comment">// 调用原始的 execute 方法，获取响应数据</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">response</span> <span class="operator">=</span> <span class="built_in">this</span>[M_Call_execute]()</span><br><span class="line">            <span class="comment">// 使用自定义的 buildNewResponse 方法创建新的响应数据</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">newResponse</span> <span class="operator">=</span> buildNewResponse(response)</span><br><span class="line">            <span class="comment">// 返回新的响应数据</span></span><br><span class="line">            <span class="keyword">return</span> newResponse;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>使用操作:</code></p>
<p>1.将 <code>okhttpfind.dex</code> 拷贝到 <code>/data/local/tmp/</code> 目录下（顺带设置一下777权限）</p>
<p>2.执行命令启动<code>frida -U wuaipojie -l okhttp_poker.js</code> 可追加 <code>-o [output filepath]</code>保存到文件</p>
<p>3.执行find()和hold()方法看看效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">D:\Program Files\WORKON_HOME\frida16\frida-agent-example&gt;frida -U wuaipojie -l okhttp_poker.js</span><br><span class="line">     ____</span><br><span class="line">    / _  |   Frida 16.1.3 - A world-class dynamic instrumentation toolkit</span><br><span class="line">   | (_| |</span><br><span class="line">    &gt; _  |   Commands:</span><br><span class="line">   /_/ |_|       help      -&gt; Displays the help system</span><br><span class="line">   . . . .       object?   -&gt; Display information about &#x27;object&#x27;</span><br><span class="line">   . . . .       exit/quit -&gt; Exit</span><br><span class="line">   . . . .</span><br><span class="line">   . . . .   More info at https://frida.re/docs/home/</span><br><span class="line">   . . . .</span><br><span class="line">   . . . .   Connected to Redmi K30 (id=30d9b4bf)</span><br><span class="line">Attaching...</span><br><span class="line"></span><br><span class="line">------------------------- OkHttp Poker by SingleMan [V.20201130]------------------------------------</span><br><span class="line">API:</span><br><span class="line">   &gt;&gt;&gt;  find()                                         检查是否使用了Okhttp &amp; 是否可能被混淆 &amp; 寻找okhttp3关键类及函数</span><br><span class="line">   &gt;&gt;&gt;  switchLoader(&quot;okhttp3.OkHttpClient&quot;)           参数：静态分析到的okhttpclient类名</span><br><span class="line">   &gt;&gt;&gt;  hold()                                         开启HOOK拦截</span><br><span class="line">   &gt;&gt;&gt;  history()                                      打印可重新发送的请求</span><br><span class="line">   &gt;&gt;&gt;  resend(index)                                  重新发送请求</span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line">[Redmi K30::wuaipojie ]-&gt; find()</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 未 混 淆 (仅参考)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">likelyClazzList size :352</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Start Find~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Find Result~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">var Cls_Call = &quot;okhttp3.Call&quot;;</span><br><span class="line">var Cls_CallBack = &quot;okhttp3.Callback&quot;;</span><br><span class="line">var Cls_OkHttpClient = &quot;okhttp3.OkHttpClient&quot;;</span><br><span class="line">var M_rsp$builder_build = &quot;build&quot;;</span><br><span class="line">var M_rsp_newBuilder = &quot;newBuilder&quot;;</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Find Complete~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">[Redmi K30::wuaipojie ]-&gt; hold()</span><br><span class="line">[Redmi K30::wuaipojie ]-&gt;  ...........  hookRealCall  : okhttp3.RealCall</span><br><span class="line"></span><br><span class="line">┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">| URL: http://192.168.124.21:5000/get_user_data</span><br><span class="line">|</span><br><span class="line">| Method: GET</span><br><span class="line">|</span><br><span class="line">| Request Headers: 0</span><br><span class="line">|     no headers</span><br><span class="line">|</span><br><span class="line">|--&gt; END</span><br><span class="line">|</span><br><span class="line">| URL: http://192.168.124.21:5000/get_user_data</span><br><span class="line">|</span><br><span class="line">| Status Code: 200 / OK</span><br><span class="line">|</span><br><span class="line">| Response Headers: 5</span><br><span class="line">|   ┌─Server: Werkzeug/2.3.3 Python/3.10.11</span><br><span class="line">|   ┌─Date: Sun, 27 Oct 2024 04:27:52 GMT</span><br><span class="line">|   ┌─Content-Type: application/json</span><br><span class="line">|   ┌─Content-Length: 104</span><br><span class="line">|   └─Connection: close</span><br><span class="line">|</span><br><span class="line">| Response Body:</span><br><span class="line">|   &#123;&quot;user_data&quot;:&quot;&#123;\&quot;user_id\&quot;: \&quot;zj2595\&quot;, \&quot;is_vip\&quot;: true, \&quot;vip_level\&quot;: \&quot;5\&quot;, \&quot;coin_amount\&quot;: 115&#125;&quot;&#125;</span><br><span class="line"></span><br><span class="line">|</span><br><span class="line">|&lt;-- END HTTP</span><br><span class="line">└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure>

<h2 id="底层网络自吐-r0capture"><a href="#底层网络自吐-r0capture" class="headerlink" title="底层网络自吐&amp;r0capture"></a>底层网络自吐&amp;r0capture</h2><p>问题:如果app不是用okhttp开发的呢？或者混淆定位不到？</p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-267940.htm">原创]android抓包学习的整理和归纳</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/r0ysue/r0capture">r0capture开源地址</a></p>
<h3 id="java-层-http-发包"><a href="#java-层-http-发包" class="headerlink" title="java 层 http 发包"></a>java 层 http 发包</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250510104354415.png" alt="image-20250510104354415"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250510104412539.png" alt="image-20250510104412539"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Java.use 方法获取 java.net.SocketOutputStream 类，并重写 socketWrite0 方法</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.net.SocketOutputStream&quot;</span>).<span class="property">socketWrite0</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.io.FileDescriptor&#x27;</span>, <span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">fd, bytearry, offset, byteCount</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用原始的 socketWrite0 方法</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">socketWrite0</span>(fd, bytearry, offset, byteCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个消息对象用于存储数据</span></span><br><span class="line">    <span class="keyword">var</span> message = &#123;&#125;;</span><br><span class="line">    message[<span class="string">&quot;function&quot;</span>] = <span class="string">&quot;HTTP_send&quot;</span>; <span class="comment">// 标识为 HTTP 发送操作</span></span><br><span class="line">    message[<span class="string">&quot;ssl_session_id&quot;</span>] = <span class="string">&quot;&quot;</span>; <span class="comment">// SSL 会话 ID 为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地地址和端口</span></span><br><span class="line">    message[<span class="string">&quot;src_addr&quot;</span>] = <span class="title function_">ntohl</span>(<span class="title function_">ipToNumber</span>((<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getLocalAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]).<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>).<span class="title function_">pop</span>()));</span><br><span class="line">    message[<span class="string">&quot;src_port&quot;</span>] = <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getLocalPort</span>().<span class="title function_">toString</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取远程地址和端口</span></span><br><span class="line">    message[<span class="string">&quot;dst_addr&quot;</span>] = <span class="title function_">ntohl</span>(<span class="title function_">ipToNumber</span>((<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getRemoteSocketAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]).<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>).<span class="title function_">pop</span>()));</span><br><span class="line">    message[<span class="string">&quot;dst_port&quot;</span>] = <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getRemoteSocketAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>).<span class="title function_">pop</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取调用栈信息</span></span><br><span class="line">    message[<span class="string">&quot;stack&quot;</span>] = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将要发送的数据拷贝到内存中</span></span><br><span class="line">    <span class="keyword">var</span> ptr = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(byteCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; byteCount; ++i)</span><br><span class="line">        <span class="title class_">Memory</span>.<span class="title function_">writeS8</span>(ptr.<span class="title function_">add</span>(i), bytearry[offset + i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息和数据</span></span><br><span class="line">    <span class="title function_">send</span>(message, <span class="title class_">Memory</span>.<span class="title function_">readByteArray</span>(ptr, byteCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回原始方法的结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Java.use 方法获取 java.net.SocketInputStream 类，并重写 socketRead0 方法</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.net.SocketInputStream&quot;</span>).<span class="property">socketRead0</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.io.FileDescriptor&#x27;</span>, <span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">fd, bytearry, offset, byteCount, timeout</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用原始的 socketRead0 方法</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">socketRead0</span>(fd, bytearry, offset, byteCount, timeout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个消息对象用于存储数据</span></span><br><span class="line">    <span class="keyword">var</span> message = &#123;&#125;;</span><br><span class="line">    message[<span class="string">&quot;function&quot;</span>] = <span class="string">&quot;HTTP_recv&quot;</span>; <span class="comment">// 标识为 HTTP 接收操作</span></span><br><span class="line">    message[<span class="string">&quot;ssl_session_id&quot;</span>] = <span class="string">&quot;&quot;</span>; <span class="comment">// SSL 会话 ID 为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取远程地址和端口（作为源地址）</span></span><br><span class="line">    message[<span class="string">&quot;src_addr&quot;</span>] = <span class="title function_">ntohl</span>(<span class="title function_">ipToNumber</span>((<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getRemoteSocketAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]).<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>).<span class="title function_">pop</span>()));</span><br><span class="line">    message[<span class="string">&quot;src_port&quot;</span>] = <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getRemoteSocketAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>).<span class="title function_">pop</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地地址和端口（作为目标地址）</span></span><br><span class="line">    message[<span class="string">&quot;dst_addr&quot;</span>] = <span class="title function_">ntohl</span>(<span class="title function_">ipToNumber</span>((<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getLocalAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]).<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>).<span class="title function_">pop</span>()));</span><br><span class="line">    message[<span class="string">&quot;dst_port&quot;</span>] = <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getLocalPort</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取调用栈信息</span></span><br><span class="line">    message[<span class="string">&quot;stack&quot;</span>] = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果读取到的数据字节数大于 0，将数据拷贝到内存并发送</span></span><br><span class="line">    <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> ptr = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(result);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; result; ++i)</span><br><span class="line">            <span class="title class_">Memory</span>.<span class="title function_">writeS8</span>(ptr.<span class="title function_">add</span>(i), bytearry[offset + i]);</span><br><span class="line">        <span class="title function_">send</span>(message, <span class="title class_">Memory</span>.<span class="title function_">readByteArray</span>(ptr, result));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回原始方法的结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过拦截 Java 中的 <code>socketWrite0</code> 和 <code>socketRead0</code> 方法，在数据发送和接收时收集相关信息并发送给指定的接收方，以便进行监控或调试</p>
<h3 id="java-层-https-发包"><a href="#java-层-https-发包" class="headerlink" title="java 层 https 发包"></a>java 层 https 发包</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250510104502451.png" alt="image-20250510104502451"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截 SSLOutputStream 类的 write 方法</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;</span>).<span class="property">write</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">bytearry, int1, int2</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用原始的 write 方法</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">write</span>(bytearry, int1, int2);</span><br><span class="line">    <span class="comment">// 获取当前调用栈的字符串形式，存储 SSL 数据写入时的调用栈</span></span><br><span class="line">    <span class="title class_">SSLstackwrite</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()).<span class="title function_">toString</span>();</span><br><span class="line">    <span class="comment">// 返回原始方法的结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截 SSLInputStream 类的 read 方法</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;</span>).<span class="property">read</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">bytearry, int1, int2</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用原始的 read 方法</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">read</span>(bytearry, int1, int2);</span><br><span class="line">    <span class="comment">// 获取当前调用栈的字符串形式，存储 SSL 数据读取时的调用栈</span></span><br><span class="line">    <span class="title class_">SSLstackread</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()).<span class="title function_">toString</span>();</span><br><span class="line">    <span class="comment">// 返回原始方法的结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拦截了 <code>SSLOutputStream</code> 和 <code>SSLInputStream</code> 类的 <code>write</code> 和 <code>read</code> 方法，在进行数据读写时获取当前的调用栈信息</p>
<h3 id="native-层-http-发包"><a href="#native-层-http-发包" class="headerlink" title="native 层 http 发包"></a>native 层 http 发包</h3><table>
<thead>
<tr>
<th align="left">函数名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">native.socketWrite0</td>
<td align="left">这是一个 native 方法，负责从 Java 层向底层网络接口写入数据。</td>
</tr>
<tr>
<td align="left">libopenjdk.so.NET_Send</td>
<td align="left">这是 <code>libopenjdk.so</code> 中的一个函数，调用底层的 <code>sendto</code> 方法，用于发送数据。</td>
</tr>
<tr>
<td align="left">libc.so.sendto</td>
<td align="left">这是一个底层系统调用函数，将数据发送到指定的网络地址。</td>
</tr>
<tr>
<td align="left">native.socketRead0</td>
<td align="left">这是一个 native 方法，用于从底层网络接口读取数据。</td>
</tr>
<tr>
<td align="left">libopenjdk.so.NET_Read</td>
<td align="left">这是 <code>libopenjdk.so</code> 中的一个函数，调用底层的 <code>recvfrom</code> 方法，负责接收数据。</td>
</tr>
<tr>
<td align="left">libopenjdk.so.recvfrom</td>
<td align="left">这是一个底层系统调用函数，用于从网络接口接收数据包。</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 libc.so 库中的 sendto 和 recvfrom 函数的指针</span></span><br><span class="line"><span class="keyword">var</span> sendtoPtr = <span class="title class_">Module</span>.<span class="title function_">getExportByName</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;sendto&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> recvfromPtr = <span class="title class_">Module</span>.<span class="title function_">getExportByName</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sendto:&quot;</span>, sendtoPtr, <span class="string">&quot;, recvfrom:&quot;</span>, recvfromPtr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截 sendto 函数</span></span><br><span class="line"><span class="comment">// sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len)</span></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(sendtoPtr, &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取文件描述符 fd</span></span><br><span class="line">        <span class="keyword">var</span> fd = args[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 获取要发送的缓冲区指针 buff</span></span><br><span class="line">        <span class="keyword">var</span> buff = args[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 获取数据大小 size</span></span><br><span class="line">        <span class="keyword">var</span> size = args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取套接字的相关信息</span></span><br><span class="line">        <span class="keyword">var</span> sockdata = <span class="title function_">getSocketData</span>(fd.<span class="title function_">toInt32</span>());</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(sockdata);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印缓冲区的十六进制内容</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hexdump</span>(buff, &#123; <span class="attr">length</span>: size.<span class="title function_">toInt32</span>() &#125;));</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>) &#123;</span><br><span class="line">        <span class="comment">// 离开 sendto 函数时不做额外处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截 recvfrom 函数</span></span><br><span class="line"><span class="comment">// recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len)</span></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(recvfromPtr, &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取文件描述符 fd</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">fd</span> = args[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 获取缓冲区指针 buff</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">buff</span> = args[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 获取数据大小 size</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">size</span> = args[<span class="number">2</span>];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取套接字的相关信息</span></span><br><span class="line">        <span class="keyword">var</span> sockdata = <span class="title function_">getSocketData</span>(<span class="variable language_">this</span>.<span class="property">fd</span>.<span class="title function_">toInt32</span>());</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(sockdata);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印接收到的缓冲区的十六进制内容</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hexdump</span>(<span class="variable language_">this</span>.<span class="property">buff</span>, &#123; <span class="attr">length</span>: <span class="variable language_">this</span>.<span class="property">size</span>.<span class="title function_">toInt32</span>() &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250510104538737.png" alt="image-20250510104538737"></p>
<p>拦截 <code>sendto</code> 和 <code>recvfrom</code> 函数，捕获发送和接收的数据包。<code>onEnter</code> 钩子函数用于在函数调用前处理参数，获取文件描述符和缓冲区地址，调用 <code>hexdump</code> 打印缓冲区内容以便查看实际发送或接收的数据</p>
<h3 id="native-层-https-发包"><a href="#native-层-https-发包" class="headerlink" title="native 层 https 发包"></a>native 层 https 发包</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250510104613424.png" alt="image-20250510104613424"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 libc.so 库中的 write 和 read 函数的指针</span></span><br><span class="line"><span class="keyword">var</span> writePtr = <span class="title class_">Module</span>.<span class="title function_">getExportByName</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;write&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> readPtr = <span class="title class_">Module</span>.<span class="title function_">getExportByName</span>(<span class="string">&quot;libc.so&quot;</span>, <span class="string">&quot;read&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;write:&quot;</span>, writePtr, <span class="string">&quot;, read:&quot;</span>, readPtr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截 write 函数</span></span><br><span class="line"><span class="comment">// write(int fd, const void *buf, size_t count)</span></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(writePtr, &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取文件描述符 fd</span></span><br><span class="line">        <span class="keyword">var</span> fd = args[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 获取写入的数据缓冲区指针 buff</span></span><br><span class="line">        <span class="keyword">var</span> buff = args[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 获取数据大小 size</span></span><br><span class="line">        <span class="keyword">var</span> size = args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取套接字信息（假设 getSocketData 是自定义函数）</span></span><br><span class="line">        <span class="keyword">var</span> sockdata = <span class="title function_">getSocketData</span>(fd.<span class="title function_">toInt32</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果套接字是 TCP 类型，打印相关数据</span></span><br><span class="line">        <span class="keyword">if</span> (sockdata.<span class="title function_">indexOf</span>(<span class="string">&quot;tcp&quot;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(sockdata);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hexdump</span>(buff, &#123; <span class="attr">length</span>: size.<span class="title function_">toInt32</span>() &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>) &#123;</span><br><span class="line">        <span class="comment">// 离开 write 函数时不做额外处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截 read 函数</span></span><br><span class="line"><span class="comment">// read(int fd, void *buf, size_t count)</span></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(readPtr, &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取文件描述符 fd</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">fd</span> = args[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 获取读取的缓冲区指针 buff</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">buff</span> = args[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 获取数据大小 size</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">size</span> = args[<span class="number">2</span>];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取套接字信息</span></span><br><span class="line">        <span class="keyword">var</span> sockdata = <span class="title function_">getSocketData</span>(<span class="variable language_">this</span>.<span class="property">fd</span>.<span class="title function_">toInt32</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果套接字是 TCP 类型，打印相关数据</span></span><br><span class="line">        <span class="keyword">if</span> (sockdata.<span class="title function_">indexOf</span>(<span class="string">&quot;tcp&quot;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(sockdata);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hexdump</span>(<span class="variable language_">this</span>.<span class="property">buff</span>, &#123; <span class="attr">length</span>: <span class="variable language_">this</span>.<span class="property">size</span>.<span class="title function_">toInt32</span>() &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 libssl.so 中的 SSL_write、SSL_read 和 SSL_get_rfd 函数的指针</span></span><br><span class="line"><span class="keyword">var</span> sslWritePtr = <span class="title class_">Module</span>.<span class="title function_">getExportByName</span>(<span class="string">&quot;libssl.so&quot;</span>, <span class="string">&quot;SSL_write&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> sslReadPtr = <span class="title class_">Module</span>.<span class="title function_">getExportByName</span>(<span class="string">&quot;libssl.so&quot;</span>, <span class="string">&quot;SSL_read&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sslWrite:&quot;</span>, sslWritePtr, <span class="string">&quot;, sslRead:&quot;</span>, sslReadPtr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 SSL_get_rfd 函数的指针，用于从 SSL 结构体中获取文件描述符</span></span><br><span class="line"><span class="keyword">var</span> sslGetFdPtr = <span class="title class_">Module</span>.<span class="title function_">getExportByName</span>(<span class="string">&quot;libssl.so&quot;</span>, <span class="string">&quot;SSL_get_rfd&quot;</span>);</span><br><span class="line"><span class="comment">// 使用 NativeFunction 创建对 SSL_get_rfd 函数的调用</span></span><br><span class="line"><span class="keyword">var</span> sslGetFdFunc = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(sslGetFdPtr, <span class="string">&#x27;int&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截 SSL_write 函数</span></span><br><span class="line"><span class="comment">// int SSL_write(SSL *ssl, const void *buf, int num)</span></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(sslWritePtr, &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取 SSL 对象指针</span></span><br><span class="line">        <span class="keyword">var</span> sslPtr = args[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 获取要发送的缓冲区指针</span></span><br><span class="line">        <span class="keyword">var</span> buff = args[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 获取数据大小</span></span><br><span class="line">        <span class="keyword">var</span> size = args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 SSL_get_rfd 获取文件描述符</span></span><br><span class="line">        <span class="keyword">var</span> fd = <span class="title function_">sslGetFdFunc</span>(sslPtr);</span><br><span class="line">        <span class="comment">// 获取套接字的数据（假设 getSocketData 是自定义函数）</span></span><br><span class="line">        <span class="keyword">var</span> sockdata = <span class="title function_">getSocketData</span>(fd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印套接字数据和发送数据的十六进制内容</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(sockdata);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hexdump</span>(buff, &#123; <span class="attr">length</span>: size.<span class="title function_">toInt32</span>() &#125;));</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>) &#123;</span><br><span class="line">        <span class="comment">// 离开 SSL_write 函数时不做额外处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截 SSL_read 函数</span></span><br><span class="line"><span class="comment">// int SSL_read(SSL *ssl, void *buf, int num)</span></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(sslReadPtr, &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取 SSL 对象指针</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sslPtr</span> = args[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 获取接收缓冲区指针</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">buff</span> = args[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 获取接收数据的大小</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">size</span> = args[<span class="number">2</span>];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 SSL_get_rfd 获取文件描述符</span></span><br><span class="line">        <span class="keyword">var</span> fd = <span class="title function_">sslGetFdFunc</span>(<span class="variable language_">this</span>.<span class="property">sslPtr</span>);</span><br><span class="line">        <span class="comment">// 获取套接字的数据</span></span><br><span class="line">        <span class="keyword">var</span> sockdata = <span class="title function_">getSocketData</span>(fd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印套接字数据和接收到的十六进制数据</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(sockdata);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hexdump</span>(<span class="variable language_">this</span>.<span class="property">buff</span>, &#123; <span class="attr">length</span>: <span class="variable language_">this</span>.<span class="property">size</span>.<span class="title function_">toInt32</span>() &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>r0capture简介</p>
<ul>
<li>仅限安卓平台，测试安卓7-14 可用 ；</li>
<li>无视所有证书校验或绑定；</li>
<li>通杀TCP&#x2F;IP四层模型中的应用层中的全部协议；</li>
<li>通杀协议包括：Http,WebSocket,Ftp,Xmpp,Imap,Smtp,Protobuf等等、以及它们的SSL版本；</li>
<li>通杀所有应用层框架，包括HttpUrlConnection、Okhttp1&#x2F;3&#x2F;4、Retrofit&#x2F;Volley等等；</li>
<li>无视加固<br>局限：部分开发实力过强的大厂或框架，采用的是自身的SSL框架，比如WebView、部分融合App、小程序或Flutter，这部分目前暂未支持。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 r0capture.py -U wuaipojie -v -p test.pcap</span><br></pre></td></tr></table></figure>

<h2 id="ebpf抓包实战-ecapture"><a href="#ebpf抓包实战-ecapture" class="headerlink" title="ebpf抓包实战&amp;ecapture"></a>ebpf抓包实战&amp;ecapture</h2><p>什么是ebpf</p>
<p><a target="_blank" rel="noopener" href="https://ebpf.io/what-is-ebpf/">what-is-ebpf</a></p>
<p>eBPF是一个运行在 Linux 内核里面的虚拟机组件，它可以在无需改变内核代码或者加载内核模块的情况下，安全而又高效地拓展内核的功能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250510104735755.png" alt="image-20250510104735755"></p>
<p>ebpf的功能之网络抓包</p>
<table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">描述</th>
<th align="left">优势</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>系统调用监控</strong></td>
<td align="left">使用 eBPF 脚本监控应用程序的系统调用，帮助分析应用行为。</td>
<td align="left">- 不需要修改目标程序<br>- 不易被应用程序检测<br>- 性能开销低</td>
</tr>
<tr>
<td align="left"><strong>应用程序插桩</strong></td>
<td align="left">通过 kprobe&#x2F;uprobe&#x2F;tracepoints&#x2F;USDT 对应用程序进行动态插桩，用于监视或修改程序状态。</td>
<td align="left">- 高度便携<br>- 无需重新编译应用程序<br>- 支持内核和用户空间</td>
</tr>
<tr>
<td align="left"><strong>性能问题分析</strong></td>
<td align="left">利用 eBPF 监控内核关键路径，识别性能瓶颈。</td>
<td align="left">- 直接在内核层面工作，减少干扰<br>- 开销低，准确性高<br>- 易于实施，已有工具支持</td>
</tr>
<tr>
<td align="left"><strong>网络抓包</strong></td>
<td align="left">在内核网络层面上使用 eBPF 实现高效的数据包捕获，包括 HTTPS 流量。</td>
<td align="left">- 无需设置代{过}{滤}理或使用其他中间件<br>- 支持加密流量的捕获（理论上）<br>- 更加安全可靠</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://github.com/gojue/ecapture">ecapture</a></p>
<p><a target="_blank" rel="noopener" href="https://ecapture.cc/zh/examples/android.html">官方案例</a></p>
<p>eCapture主要利用了eBPF和HOOK技术：</p>
<ul>
<li><strong>eBPF加载机制</strong>：利用eBPF技术进行数据包的捕获和处理，eBPF程序是事件驱动的，当内核或应用程序通过某个挂钩点时运行。预定义的钩子包括系统调用、函数入口&#x2F;出口、内核跟踪点、网络事件和其他几个；</li>
<li><strong>HOOK机制</strong>：使用eBPF uprobe相关函数进行用户态函数的HOOK，支持对不同编程语言实现的加密库进行HOOK，如OpenSSL、GnuTLS、NSS&#x2F;NSPR。</li>
</ul>
<p>eCapture 的工作原理涉及到用户态和内核态。用户态就是运行应用程序的地方，比如各种 App。在这个区域中，eCapture 通过一个共享的模块(Shared Object)获取应用程序的网络数据。然后，它将这些数据传递给内核态的 eBPF 程序进行分析和处理。</p>
<p>在内核空间，eCapture 通过 eBPF 插件捕捉网络层的数据流，比如数据包是从哪里来的、发到了哪里去。这一过程不需要修改应用程序本身，所以对系统性能影响很小。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20250510104816695.png" alt="image-20250510104816695"></p>
<p>安卓设备的内核版本只有在5.10版本上才可以进行无任何修改的开箱抓包操作(如果你的设备是安卓13，应该可以正常使用ecapture。低于13的安卓设备，如果内核是5.10，理论也是可行的。 因为安卓使用的linux内核的ebpf环境受内核版本号的影响，而工作良好的ebpf接口是在内核5.5版本时才全部使能。)</p>
<p>可通过adb命令查看自己的设备的内核版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /proc/version</span><br><span class="line">或者adb shell uname -a</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/gojue/ecapture/releases">下载地址</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb push ecapture /data/local/tmp/</span><br><span class="line">adb shell chmod 777 /data/local/tmp/ecapture</span><br></pre></td></tr></table></figure>

<p>使用说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">NAME:</span><br><span class="line">        eCapture - 通过eBPF捕获SSL/TLS明文数据，无需安装CA证书。支持Linux/Android内核，适用于amd64/arm64架构。</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">        eCapture [flags]</span><br><span class="line"></span><br><span class="line">VERSION:</span><br><span class="line">        androidgki_arm64:v0.8.9:6.5.0-1025-azure</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">        bash    捕获bash命令的执行信息</span><br><span class="line">        gotls   捕获使用TLS/HTTPS加密的Golang程序的明文通信</span><br><span class="line">        help    获取有关任何命令的帮助信息</span><br><span class="line">        tls     用于捕获TLS/SSL明文内容，无需CA证书。支持OpenSSL 1.0.x/1.1.x/3.x或更新版本。</span><br><span class="line"></span><br><span class="line">DESCRIPTION:</span><br><span class="line">        eCapture（旁观者）是一个可以捕获如HTTPS和TLS等明文数据包的工具，且不需要安装CA证书。</span><br><span class="line">        它还可以捕获bash命令，适用于安全审计场景，比如mysqld数据库审计等（在Android中禁用）。</span><br><span class="line">        支持Linux(Android)系统，内核版本为X86_64 4.18或aarch64 5.5及更高版本。</span><br><span class="line">        项目仓库：https://github.com/gojue/ecapture</span><br><span class="line">        官方主页：https://ecapture.cc</span><br><span class="line"></span><br><span class="line">        使用方法：</span><br><span class="line">          ecapture tls -h</span><br><span class="line">          ecapture bash -h</span><br><span class="line"></span><br><span class="line">        Docker使用示例：</span><br><span class="line">        docker pull gojue/ecapture:latest</span><br><span class="line">        docker run --rm --privileged=true --net=host -v $&#123;HOST_PATH&#125;:$&#123;CONTAINER_PATH&#125; gojue/ecapture -h</span><br><span class="line"></span><br><span class="line">NAME:</span><br><span class="line">        tls - 用于捕获TLS/SSL明文内容，无需CA证书。支持OpenSSL 1.0.x/1.1.x/3.x及更新版本。</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">        eCapture tls [flags]</span><br><span class="line"></span><br><span class="line">DESCRIPTION:</span><br><span class="line">        使用eBPF uprobe/TC捕获进程事件数据和网络数据。还支持pcap-NG格式。</span><br><span class="line"></span><br><span class="line">        示例：</span><br><span class="line">        ecapture tls -m [text|keylog|pcap] [flags] [pcap过滤表达式（用于pcap模式）]</span><br><span class="line">        ecapture tls -m pcap -i wlan0 -w save.pcapng host 192.168.1.1 and tcp port 443</span><br><span class="line">        ecapture tls -l save.log --pid=3423</span><br><span class="line">        ecapture tls --libssl=/lib/x86_64-linux-gnu/libssl.so.1.1</span><br><span class="line">        ecapture tls -m keylog --pcapfile save_3_0_5.pcapng --ssl_version=&quot;openssl 3.0.5&quot; --libssl=/lib/x86_64-linux-gnu/libssl.so.3</span><br><span class="line">        ecapture tls -m pcap --pcapfile save_android.pcapng -i wlan0 --libssl=/apex/com.android.conscrypt/lib64/libssl.so --ssl_version=&quot;boringssl 1.1.1&quot; tcp port 443</span><br><span class="line"></span><br><span class="line">        Docker使用示例：</span><br><span class="line">        docker pull gojue/ecapture</span><br><span class="line">        docker run --rm --privileged=true --net=host -v /etc:/etc -v /usr:/usr -v $&#123;PWD&#125;:/output gojue/ecapture tls -m pcap -i wlp3s0 --pcapfile=/output/ecapture.pcapng tcp port 443</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">      --cgroup_path=&quot;/sys/fs/cgroup&quot;            设置cgroup路径，默认值：/sys/fs/cgroup。</span><br><span class="line">  -h, --help[=false]                            获取tls命令的帮助信息</span><br><span class="line">  -i, --ifname=&quot;&quot;                               (TC Classifier) 要附加探针的网络接口名称</span><br><span class="line">  -k, --keylogfile=&quot;ecapture_openssl_key.og&quot;    存储SSL/TLS密钥的文件，eCapture捕获加密通信中的密钥并将其保存到该文件</span><br><span class="line">      --libssl=&quot;&quot;                               指定libssl.so文件路径，默认从curl中自动查找</span><br><span class="line">  -m, --model=&quot;text&quot;                            捕获模型，可以是：text（明文内容），pcap/pcapng（原始数据包格式），key/keylog（SSL/TLS密钥）</span><br><span class="line">  -w, --pcapfile=&quot;save.pcapng&quot;                  将原始数据包以pcapng格式写入文件</span><br><span class="line">      --ssl_version=&quot;&quot;                          指定OpenSSL/BoringSSL版本，例如：--ssl_version=&quot;openssl 1.1.1g&quot; 或 --ssl_version=&quot;boringssl 1.1.1&quot;</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">  -b, --btf=0                           启用BTF模式（0：自动选择；1：核心模式；2：非核心模式）</span><br><span class="line">  -d, --debug[=false]                   启用调试日志</span><br><span class="line">      --eventaddr=&quot;&quot;                    设置接收捕获事件的服务器地址。默认值与logaddr相同（例如：tcp://127.0.0.1:8090）</span><br><span class="line">      --hex[=false]                     以十六进制字符串打印字节数据</span><br><span class="line">      --listen=&quot;localhost:28256&quot;        设置HTTP服务器的监听地址，默认值：127.0.0.1:28256</span><br><span class="line">  -l, --logaddr=&quot;&quot;                      设置日志服务器的地址。例如：-l /tmp/ecapture.log 或 -l tcp://127.0.0.1:8080</span><br><span class="line">      --mapsize=1024                    设置每个CPU的eBPF映射大小（事件缓冲区）。默认值：1024 * PAGESIZE（单位：KB）</span><br><span class="line">  -p, --pid=0                           设置目标进程ID。如果为0，则目标为所有进程</span><br><span class="line">  -u, --uid=0                           设置目标用户ID。如果为0，则目标为所有用户</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell ps | findstr 应用包名（获取进程pid）</span><br><span class="line">./ecapture tls -p pid -m text</span><br><span class="line">./ecapture tls -p 2600 -m text</span><br></pre></td></tr></table></figure>

<h2 id="简单加解密协议实战"><a href="#简单加解密协议实战" class="headerlink" title="简单加解密协议实战"></a>简单加解密协议实战</h2><p>说一下这里服务端配置需要通过ipconfig获取到真实的ip地址替换，除此之外，还需要对教程demo里的dex进行修改，字符串搜搜192.，然后把对应接口的ip地址换成刚才获取到的ip地址</p>
<p>服务端代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib  </span><br><span class="line"><span class="keyword">import</span> json  </span><br><span class="line"><span class="keyword">import</span> base64  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad  </span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives <span class="keyword">import</span> padding  </span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, request  </span><br><span class="line"></span><br><span class="line">app = Flask(__name__)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密函数  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_encrypt</span>(<span class="params">data: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:  </span><br><span class="line">    key = <span class="string">b&#x27;1234567890abcdefwuaipojie0abcdef&#x27;</span>  </span><br><span class="line">    iv = <span class="string">b&#x27;1234567wuaipojie&#x27;</span>  <span class="comment"># Initialization Vector  </span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv)  </span><br><span class="line">    encrypted_data = cipher.encrypt(pad(data.encode(<span class="string">&#x27;utf-8&#x27;</span>), AES.block_size))  </span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(encrypted_data).decode(<span class="string">&#x27;utf-8&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密函数  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_decrypt</span>(<span class="params">encrypted_data: <span class="built_in">str</span></span>) -&gt; <span class="built_in">dict</span>:  </span><br><span class="line">    key = <span class="string">b&#x27;1234567890abcdefwuaipojie0abcdef&#x27;</span>  </span><br><span class="line">    iv = <span class="string">b&#x27;1234567wuaipojie&#x27;</span>  <span class="comment"># Initialization Vector  </span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv)  </span><br><span class="line">    encrypted_bytes = base64.b64decode(encrypted_data)  </span><br><span class="line">    decrypted_data = cipher.decrypt(encrypted_bytes)  </span><br><span class="line">    unpadder = padding.PKCS7(AES.block_size * <span class="number">8</span>).unpadder()  </span><br><span class="line">    decrypted_unpadded = unpadder.update(decrypted_data) + unpadder.finalize()  </span><br><span class="line">    decrypted_str = decrypted_unpadded.decode(<span class="string">&#x27;utf-8&#x27;</span>)  </span><br><span class="line">    <span class="keyword">return</span> json.loads(decrypted_str)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取用户数据  </span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;user_data.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:  </span><br><span class="line">    user_data = json.load(file)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入本地JSON文件  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_json_file</span>(<span class="params">file_path: <span class="built_in">str</span>, data: <span class="built_in">dict</span></span>):  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:  </span><br><span class="line">        json.dump(data, file, indent=<span class="number">4</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成签名函数  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_signature</span>(<span class="params">user_id: <span class="built_in">str</span>, coin: <span class="built_in">int</span>, timestamp: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:  </span><br><span class="line">    message = <span class="string">f&quot;<span class="subst">&#123;user_id&#125;</span>&amp;<span class="subst">&#123;coin&#125;</span>&amp;<span class="subst">&#123;timestamp&#125;</span>&quot;</span>  </span><br><span class="line">    hash_object = hashlib.md5(message.encode())  </span><br><span class="line">    <span class="keyword">return</span> hash_object.hexdigest()  </span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/get_coin&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_coin</span>():  </span><br><span class="line">    <span class="comment"># 获取加密的数据  </span></span><br><span class="line">    encrypted_data = request.json.get(<span class="string">&#x27;user_data&#x27;</span>)  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> encrypted_data:  </span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;数据有误!&quot;</span>&#125;), <span class="number">400</span>  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        <span class="comment"># 解密数据  </span></span><br><span class="line">        decrypted_data = aes_decrypt(encrypted_data)  </span><br><span class="line">        <span class="comment"># 验证签名  </span></span><br><span class="line">        timestamp = <span class="built_in">int</span>(decrypted_data.get(<span class="string">&#x27;timestamp&#x27;</span>))  </span><br><span class="line">        current_time = <span class="built_in">int</span>(time.time()*<span class="number">1000</span>)  </span><br><span class="line">        <span class="built_in">print</span>(timestamp)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">abs</span>(current_time - timestamp))  </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(current_time - timestamp) &gt; <span class="number">5000</span>:  </span><br><span class="line">            <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;请求过期!&quot;</span>&#125;), <span class="number">400</span>  </span><br><span class="line">        sign = decrypted_data.get(<span class="string">&#x27;sign&#x27;</span>)  </span><br><span class="line">        <span class="comment"># 计算签名  </span></span><br><span class="line">        expected_sign = generate_signature(decrypted_data[<span class="string">&quot;user_id&quot;</span>], <span class="number">1</span>, timestamp)  </span><br><span class="line">        <span class="keyword">if</span> sign != expected_sign:  </span><br><span class="line">            <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;签名验证失败!&quot;</span>&#125;), <span class="number">401</span>  </span><br><span class="line">        <span class="comment"># 验证成功后，获取用户的金币数量  </span></span><br><span class="line">        user_id = decrypted_data.get(<span class="string">&#x27;user_id&#x27;</span>)  </span><br><span class="line">        <span class="keyword">if</span> user_id <span class="keyword">in</span> user_data[<span class="string">&#x27;user_id&#x27;</span>]:  </span><br><span class="line">            user_data[<span class="string">&#x27;coin_amount&#x27;</span>] += <span class="number">1</span>  <span class="comment"># 增加金币数量  </span></span><br><span class="line">            write_json_file(<span class="string">&#x27;user_data.json&#x27;</span>, user_data)  <span class="comment"># 写入文件  </span></span><br><span class="line">            <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;投币成功，当前数量为:&quot;</span>: user_data[<span class="string">&#x27;coin_amount&#x27;</span>]&#125;)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;用户未找到!&quot;</span>&#125;), <span class="number">404</span>  </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">f&quot;处理请求时出错: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>&#125;), <span class="number">500</span>  </span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/get_user_data&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_data</span>():  </span><br><span class="line">    <span class="comment"># 将数据转换成字符串形式以便于加密  </span></span><br><span class="line">    data_str = json.dumps(user_data)  </span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;user_data&quot;</span>: data_str&#125;)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    app.run(host=<span class="string">&#x27;192.168.73.82&#x27;</span>, port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure>

<p>协议实现:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json  </span><br><span class="line"><span class="keyword">import</span> base64  </span><br><span class="line"><span class="keyword">import</span> hashlib  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES  </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad  </span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime  </span><br><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成签名函数  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_signature</span>(<span class="params">user_id: <span class="built_in">str</span>, coin: <span class="built_in">int</span>, timestamp: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:  </span><br><span class="line">    message = <span class="string">f&quot;<span class="subst">&#123;user_id&#125;</span>&amp;<span class="subst">&#123;coin&#125;</span>&amp;<span class="subst">&#123;timestamp&#125;</span>&quot;</span>  </span><br><span class="line">    hash_object = hashlib.md5(message.encode())  </span><br><span class="line">    <span class="keyword">return</span> hash_object.hexdigest()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密函数  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_encrypt</span>(<span class="params">data: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:  </span><br><span class="line">    key = <span class="string">b&#x27;1234567890abcdefwuaipojie0abcdef&#x27;</span>  </span><br><span class="line">    iv = <span class="string">b&#x27;1234567wuaipojie&#x27;</span>  <span class="comment"># Initialization Vector  </span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv)  </span><br><span class="line">    encrypted_data = cipher.encrypt(pad(data.encode(<span class="string">&#x27;utf-8&#x27;</span>), AES.block_size))  </span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(encrypted_data).decode(<span class="string">&#x27;utf-8&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟用户数据  </span></span><br><span class="line">user_data = &#123;  </span><br><span class="line">    <span class="string">&quot;user_id&quot;</span>: <span class="string">&quot;zj2595&quot;</span>,  </span><br><span class="line">    <span class="string">&quot;timestamp&quot;</span>: <span class="built_in">int</span>(time.time()*<span class="number">1000</span>),  <span class="comment"># 当前时间的时间戳  </span></span><br><span class="line">    <span class="string">&quot;sign&quot;</span>: <span class="string">&quot;&quot;</span>,  <span class="comment"># 这个稍后计算并赋值  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算签名  </span></span><br><span class="line">user_data[<span class="string">&quot;sign&quot;</span>] = generate_signature(user_data[<span class="string">&quot;user_id&quot;</span>], <span class="number">1</span>, user_data[<span class="string">&quot;timestamp&quot;</span>])  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为JSON字符串  </span></span><br><span class="line">data_str = json.dumps(user_data)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密数据  </span></span><br><span class="line">encrypted_data = aes_encrypt(data_str)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送POST请求  </span></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    response = requests.post(  </span><br><span class="line">        <span class="string">&#x27;http://192.168.73.82:5000/get_coin&#x27;</span>,  </span><br><span class="line">        json=&#123;<span class="string">&quot;user_data&quot;</span>: encrypted_data&#125;,  </span><br><span class="line"></span><br><span class="line">    )  </span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;投币成功&quot;</span>)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Response:&quot;</span>, response.json())  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Request failed with status code: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;请求出现异常: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://matriy330.github.io">Matriy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://matriy330.github.io/c2ef4741/">http://matriy330.github.io/c2ef4741/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://matriy330.github.io" target="_blank">Matriy's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><div class="post-share"><div class="social-share" data-image="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/zsm.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/zsm.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/zfb.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/zfb.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/b20671e0/" title="Android逆向1-smali"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-25</div><div class="info-item-2">Android逆向1-smali</div></div><div class="info-2"><div class="info-item-1">Android逆向1-smali来自吾爱破解-正己 https://www.52pojie.cn/thread-1701353-1-1.html 1. JVM、Dalvik、ART JVM是JAVA虚拟机，运行JAVA字节码程序 Dalvik是Google专门为Android设计的一个虚拟机，Dalvik有专属的文件执行格式dex(Dalvik executable) Art(Android Runtime)相当于Dalvik的升级版，本质与Dalvik无异  2. smali及其语法smali是Dalvik的寄存器语言，smali代码是dex反编译而来的。 关键字    名称 注释    .class 类名   .super 父类名，继承的上级类名名称   .source 源名   .field 变量   .method 方法名   .register 寄存器   .end...</div></div></div></a><a class="pagination-related" href="/c47c9f7e/" title="Android逆向10-Frida_Native"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-28</div><div class="info-item-2">Android逆向10-Frida_Native</div></div><div class="info-2"><div class="info-item-1">Android逆向10-Frida_Native来自吾爱破解-正己 https://www.52pojie.cn/thread-1701353-1-1.html Process、Module、MemoryProcess 对象代表当前被Hook的进程，能获取进程的信息，枚举模块，枚举范围等    API 含义    Process.id 返回附加目标进程的 PID   Process.isDebuggerAttached() 检测当前是否对目标程序已经附加   Process.enumerateModules() 枚举当前加载的模块，返回模块对象的数组   Process.enumerateThreads() 枚举当前所有的线程，返回包含 id, state, context 等属性的对象数组   Module 对象代表一个加载到进程的模块(例如，在 Windows 上的 DLL，或在 Linux&#x2F;Android 上的 .so...</div></div></div></a><a class="pagination-related" href="/d81ca9c8/" title="Android逆向13-例题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-01</div><div class="info-item-2">Android逆向13-例题</div></div><div class="info-2"><div class="info-item-1">Android逆向13-例题初级112345方法1:var ClassName=Java.use(&quot;com.zj.wuaipojie2024_1.YSQDActivity&quot;); console.log(ClassName.extractDataFromFile(&quot;/data/user/0/com.zj.wuaipojie2024_1/files/ys.mp4&quot;));方法2:android intent launch_activity com.zj.wuaipojie2024_1.YSQDActivity  初级2123456789101112131415161718方法1:android intent launch_activity com.kbtx.redpack_simple.FlagActivity方法2:function hookTest1()&#123;    var Arrays = Java.use(&quot;java.util.Arrays&quot;);   ...</div></div></div></a><a class="pagination-related" href="/3761fa33/" title="Android逆向11-Frida进阶"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-29</div><div class="info-item-2">Android逆向11-Frida进阶</div></div><div class="info-2"><div class="info-item-1">Android逆向11-Frida进阶来自吾爱破解-正己 https://www.52pojie.cn/thread-1701353-1-1.html Frida写数据12345678//一般写在app的私有目录里，不然会报错:failed to open file (Permission denied)(实际上就是权限不足)var file_path = &quot;/data/user/0/com.zj.wuaipojie/test.txt&quot;;var file_handle = new File(file_path, &quot;wb&quot;);if (file_handle &amp;&amp; file_handle != null) &#123;        file_handle.write(data); //写入数据        file_handle.flush(); //刷新        file_handle.close(); //关闭&#125;  Frida_inlineHook与读写汇编什么是inlinehook？ Inline...</div></div></div></a><a class="pagination-related" href="/3fc95872/" title="Android逆向12-RPC"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-30</div><div class="info-item-2">Android逆向12-RPC</div></div><div class="info-2"><div class="info-item-1">Android逆向12-RPC来自吾爱破解-正己 https://www.52pojie.cn/thread-1701353-1-1.html RPC（Remote Procedure Call Protocol） 是一种远程过程调用协议，允许程序在不同的计算机上请求服务，而无需了解底层网络技术。RPC的主要作用是使不同服务之间的方法调用像本地调用一样便捷 Hook_Libartlibart.so: 在 Android 5.0（Lollipop）及更高版本中，libart.so 是 Android 运行时（ART，Android Runtime）的核心组件，它取代了之前的 Dalvik 虚拟机。可以在 libart.so 里找到 JNI 相关的实现。 PS:在高于安卓10的系统里，so的路径是&#x2F;apex&#x2F;com.android.runtime&#x2F;lib64&#x2F;libart.so，低于10的则在system&#x2F;lib64&#x2F;libart.so    函数名称 参数 描述 返回值    RegisterNatives JNIEnv...</div></div></div></a><a class="pagination-related" href="/f3acfce3/" title="Android逆向15-抓包"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-07</div><div class="info-item-2">Android逆向15-抓包</div></div><div class="info-2"><div class="info-item-1">Android逆向15-抓包来自吾爱破解-正己 https://www.52pojie.cn/thread-1701353-1-1.html 抓包基础知识在计算机网络中，“包”通常指的是在网络上传输的数据单元，也被称为数据包。在互联网协议（IP）的语境下，数据包是由报头（Header）和载荷（Payload）组成，其中报头包含了源地址、目的地址、长度等信息，而载荷则是实际要传输的数据。 抓包具体指的是通过某些工具获取安卓App与服务器之间传输的网络数据，这些数据通常用于逆向分析、协议接口分析或App渗透测试，帮助安全工程师理解App与服务器之间的通信细节，如请求和响应的具体内容，从而进行安全评估或逆向工程。  帮助定位加密或混淆的代码中的关键部分 逆向接口(比如:一些第三方影视app的解析接口、分析是否为服务器校验) 篡改数据包实现免重打包破解&amp;屏蔽广告 协议分析&amp;爬虫需求  网络协议可以分层，每层都有特定的任务和责任，最著名的分层模型是OSI七层模型和TCP&#x2F;IP四层模型。常见的网络协议包括：  TCP&#x2F;IP（Transmission...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Matriy</div><div class="author-info-description">不积硅步，无以至千里</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">204</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Matriy330"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">我是一个网安小白，一名安卓逆向工程师，Web安全开发工程师，二进制学习者</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Android%E9%80%86%E5%90%9117-%E6%8A%93%E5%8C%85%E8%BF%9B%E9%98%B6"><span class="toc-text">Android逆向17-抓包进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hook%E6%8A%93%E5%8C%85-%E5%85%B3%E9%94%AE%E5%AE%9A%E4%BD%8D-%E6%B7%B7%E6%B7%86%E5%AF%B9%E6%8A%97"><span class="toc-text">Hook抓包&amp;&amp;关键定位&amp;&amp;混淆对抗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E7%BD%91%E7%BB%9C%E8%87%AA%E5%90%90-r0capture"><span class="toc-text">底层网络自吐&amp;r0capture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-%E5%B1%82-http-%E5%8F%91%E5%8C%85"><span class="toc-text">java 层 http 发包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-%E5%B1%82-https-%E5%8F%91%E5%8C%85"><span class="toc-text">java 层 https 发包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#native-%E5%B1%82-http-%E5%8F%91%E5%8C%85"><span class="toc-text">native 层 http 发包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#native-%E5%B1%82-https-%E5%8F%91%E5%8C%85"><span class="toc-text">native 层 https 发包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ebpf%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98-ecapture"><span class="toc-text">ebpf抓包实战&amp;ecapture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%8D%8F%E8%AE%AE%E5%AE%9E%E6%88%98"><span class="toc-text">简单加解密协议实战</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/b22496bd/" title="L3HCTF 2025 wp"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/wps.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="L3HCTF 2025 wp"/></a><div class="content"><a class="title" href="/b22496bd/" title="L3HCTF 2025 wp">L3HCTF 2025 wp</a><time datetime="2025-08-20T16:00:00.000Z" title="发表于 2025-08-21 00:00:00">2025-08-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/de9c80c5/" title="DubheCTF 2024 re 复现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/1bc9335f-4952-4bbb-814d-8fcbc8b2044b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DubheCTF 2024 re 复现"/></a><div class="content"><a class="title" href="/de9c80c5/" title="DubheCTF 2024 re 复现">DubheCTF 2024 re 复现</a><time datetime="2025-07-28T16:00:00.000Z" title="发表于 2025-07-29 00:00:00">2025-07-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f1dd543a/" title="DASCTF 2025上半年赛-re"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DASCTF 2025上半年赛-re"/></a><div class="content"><a class="title" href="/f1dd543a/" title="DASCTF 2025上半年赛-re">DASCTF 2025上半年赛-re</a><time datetime="2025-07-01T16:00:00.000Z" title="发表于 2025-07-02 00:00:00">2025-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e22082ab/" title="RCTF 2024 wp [复现]"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/0d04e86e-b194-4e9d-8b3a-aa1eba5b849a.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RCTF 2024 wp [复现]"/></a><div class="content"><a class="title" href="/e22082ab/" title="RCTF 2024 wp [复现]">RCTF 2024 wp [复现]</a><time datetime="2025-06-30T16:00:00.000Z" title="发表于 2025-07-01 00:00:00">2025-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/560945d3/" title="第一届OpenHarmony CTF专题赛RE题解"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/2bb4e3fb-e784-407a-8acb-2b27e6bf7493.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第一届OpenHarmony CTF专题赛RE题解"/></a><div class="content"><a class="title" href="/560945d3/" title="第一届OpenHarmony CTF专题赛RE题解">第一届OpenHarmony CTF专题赛RE题解</a><time datetime="2025-06-29T16:00:00.000Z" title="发表于 2025-06-30 00:00:00">2025-06-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Matriy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank" href="https://hexo.io/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px"target="_blank" href="https://www.jsdelivr.com/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px"target="_blank" href="https://github.com/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p> <p>Hi, welcome to Matriy's <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.open-ctf.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo.open-ctf.top/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script async data-pjax src="/js/anzhiyu.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href="/music/"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>