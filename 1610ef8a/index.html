<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android逆向18-Unicorn | Matriy's blog</title><meta name="author" content="Matriy"><meta name="copyright" content="Matriy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Android逆向18-Unicorn来自吾爱破解-正己 https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-1701353-1-1.html 开源地址 Unicorn 是一个由新加坡南洋理工大学团队在2015年开源的CPU模拟器框架，它支持多种架构，包括X86&#x2F;X64&#x2F;ARM&#x2F;ARM64&#x2F;MIPS等。Unicorn 的主要特点是：  多架构支持：它">
<meta property="og:type" content="article">
<meta property="og:title" content="Android逆向18-Unicorn">
<meta property="og:url" content="http://matriy330.github.io/1610ef8a/index.html">
<meta property="og:site_name" content="Matriy&#39;s blog">
<meta property="og:description" content="Android逆向18-Unicorn来自吾爱破解-正己 https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-1701353-1-1.html 开源地址 Unicorn 是一个由新加坡南洋理工大学团队在2015年开源的CPU模拟器框架，它支持多种架构，包括X86&#x2F;X64&#x2F;ARM&#x2F;ARM64&#x2F;MIPS等。Unicorn 的主要特点是：  多架构支持：它">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg">
<meta property="article:published_time" content="2025-05-09T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-13T07:47:50.447Z">
<meta property="article:author" content="Matriy">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Android逆向18-Unicorn",
  "url": "http://matriy330.github.io/1610ef8a/",
  "image": "https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg",
  "datePublished": "2025-05-09T16:00:00.000Z",
  "dateModified": "2025-05-13T07:47:50.447Z",
  "author": [
    {
      "@type": "Person",
      "name": "Matriy",
      "url": "http://matriy330.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/bitbug_favicon.ico"><link rel="canonical" href="http://matriy330.github.io/1610ef8a/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="G-ShTqjjywiLkL87Rg0PaiSsDVYymWStdQUO1wrM_VY"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: Matriy","link":"链接: ","source":"来源: Matriy's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}
</script><link rel="stylesheet" href="/css/custom.css"><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android逆向18-Unicorn',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/music.css"><link rel="stylesheet" href="/css/comment.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/img/bg.jpeg);"></div><div id="an_music_bg" style="background-image: url(/img/bg.jpeg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">206</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent;"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Matriy's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Android逆向18-Unicorn</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Android逆向18-Unicorn</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-09T16:00:00.000Z" title="发表于 2025-05-10 00:00:00">2025-05-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-13T07:47:50.447Z" title="更新于 2025-05-13 15:47:50">2025-05-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/1610ef8a/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Android逆向18-Unicorn"><a href="#Android逆向18-Unicorn" class="headerlink" title="Android逆向18-Unicorn"></a>Android逆向18-Unicorn</h1><p>来自吾爱破解-正己</p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1701353-1-1.html">https://www.52pojie.cn/thread-1701353-1-1.html</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/unicorn-engine/unicorn">开源地址</a></p>
<p>Unicorn 是一个由新加坡南洋理工大学团队在2015年开源的CPU模拟器框架，它支持多种架构，包括X86&#x2F;X64&#x2F;ARM&#x2F;ARM64&#x2F;MIPS等。Unicorn 的主要特点是：</p>
<ol>
<li><strong>多架构支持</strong>：它能够模拟不同架构的CPU指令，这使得它在跨平台分析和测试中非常有用。</li>
<li><strong>高性能</strong>：Unicorn 通过使用JIT（Just-In-Time）编译技术，将模拟的指令翻译成宿主机的本地指令，从而提高了执行效率。</li>
<li><strong>丰富的接口</strong>：Unicorn 提供了多种语言的绑定，包括Python、Java、C#等，使得在不同编程环境中都能方便地使用。</li>
<li><strong>Hook和拦截功能</strong>：Unicorn 允许用户在模拟执行过程中设置Hook，拦截和处理特定的指令或内存访问，这对于逆向工程和动态分析非常有用。</li>
<li><strong>专注于CPU模拟</strong>：与一些既模拟CPU又模拟操作系统的模拟器不同，Unicorn 专注于CPU指令的模拟，提供了简单的Hook接口、内存操作接口和指令执行接口，而不涉及操作系统层面的模拟。</li>
</ol>
<p>什么是unidbg？</p>
<p><a target="_blank" rel="noopener" href="https://github.com/zhkl0228/unidbg">开源地址</a></p>
<p>Unidbg(Unicorn Debugger)是一个开源的轻量级模拟器，主要设计用于模拟执行Android平台上的Native代码。它由凯神在2019年开源，基于Maven构建，使用Java语言编写，可以在IDE中打开和运行。Unidbg能够模拟Android Native函数的执行，让逆向工程师和安全研究人员能够分析和理解二进制文件的运行行为。它支持模拟系统调用和JNI调用，使得可以在模拟环境中执行依赖这些调用的代码。Unidbg基于Unicorn项目，Unidbg的优势在于它提供了一种隐蔽的监控手段，可以模拟复杂的Native环境，帮助用户进行深入的动态分析。由于其开源特性，Unidbg得到了社区的广泛支持和持续更新，成为了Android Native逆向分析领域中一个强有力的工具。</p>
<p>竞争者： <a target="_blank" rel="noopener" href="https://github.com/AeonLucid/AndroidNativeEmu">AndroidNativeEmu</a> 和继任者 <a target="_blank" rel="noopener" href="https://github.com/maiyao1988/ExAndroidNativeEmu">ExAndroidNativeEmu</a>   (Unidbg优点:模拟实现了更多的系统调用和 JNI)</p>
<p><strong>unidbg的使用场景与优缺点</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">模拟执行</td>
<td align="left">执行目标 SO 文件中用户关注的函数，获取与真机等价的结果；替代 Frida&#x2F;Xposed Call 进行 RPC 调用。</td>
</tr>
<tr>
<td align="left">监控观察</td>
<td align="left">观察样本对环境的信息获取与修改；监控所有类型的外部信息访问，包括系统调用、库函数、JNI 调用、文件读写等。</td>
</tr>
<tr>
<td align="left">辅助算法分析和还原</td>
<td align="left">提供 Hook&#x2F;Debug&#x2F;Trace 等分析能力，结合时间旅行调试器(Time-Travel Debugging),无疑是Android Native 上强大的分析神器。</td>
</tr>
<tr>
<td align="left"><strong>优点</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">低成本</td>
<td align="left">减少设备成本和改机成本，无需购置和维护大量真机或租借云手机。</td>
</tr>
<tr>
<td align="left">灵活性</td>
<td align="left">可以模拟或代{过}{滤}理所有函数调用接口，方便模拟设备环境变化。</td>
</tr>
<tr>
<td align="left">监控能力</td>
<td align="left">能够监控 Native 层的详细执行流，包括 JNI 调用和文件访问。</td>
</tr>
<tr>
<td align="left">分析能力</td>
<td align="left">结合时间旅行调试器，提供强大的算法分析和还原能力。</td>
</tr>
<tr>
<td align="left"><strong>缺点</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">学习成本高</td>
<td align="left">尤其是环境补全（补环境）部分，如果补得不好，即使跑出结果也无法使用。</td>
</tr>
<tr>
<td align="left">执行速度慢</td>
<td align="left">基于 Unicorn 的模拟执行速度相比真机慢很多，尽管有 Dynarmic 等方案可以提高速度，但牺牲了部分辅助算法还原的能力。</td>
</tr>
<tr>
<td align="left">功能限制</td>
<td align="left">没有为特定场景做专门的优化，也没有提供配置管理功能；没有实现对所有系统调用的良好模拟，可能导致某些逻辑处理失败。</td>
</tr>
<tr>
<td align="left">扩展性差</td>
<td align="left">作为一个 Java 项目，Unidbg 无法作为 IDA 或 Ghidra 插件，也难以轻松嵌入到其他项目中，不如 Python 项目灵活。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">├── README.md                     # 项目介绍和使用指南</span><br><span class="line">├── LICENSE                       # 开源许可证文件</span><br><span class="line">├── .gitignore                    # Git 忽略文件配置</span><br><span class="line">├── pom.xml                       # Maven 配置文件，定义了项目的依赖和构建配置</span><br><span class="line">├── mvnw                          # 脚本文件，用于 Maven Wrapper (Linux/Mac)</span><br><span class="line">├── mvnw.cmd                      # 脚本文件，用于 Maven Wrapper (Windows)</span><br><span class="line">├── test.sh                       # 测试脚本 (Linux/Mac)</span><br><span class="line">├── test.cmd                      # 测试脚本 (Windows)</span><br><span class="line">├── .mvn/                         # Maven 配置目录</span><br><span class="line">│   └── wrapper/                  # Maven Wrapper 相关配置</span><br><span class="line">├── assets/                       # 存放模拟过程中使用的资源文件</span><br><span class="line">│   ├── *.dll                     # Windows 动态链接库文件</span><br><span class="line">│   └── *.so                      # Linux/Android 动态链接库文件</span><br><span class="line">├── backend/                      # 后端逻辑实现，包含核心模拟功能</span><br><span class="line">├── unidbg-api/                   # 核心接口和抽象类模块</span><br><span class="line">│   └── src/                      # API 模块的源代码目录</span><br><span class="line">├── unidbg-ios/                   # iOS 应用模拟模块</span><br><span class="line">│   └── src/                      # iOS 模拟模块的源代码目录</span><br><span class="line">├── unidbg-android/               # Android 应用模拟模块</span><br><span class="line">│   ├── pom.xml                   # Maven 构建文件</span><br><span class="line">│   ├── pull.sh                   # 拉取 Android 模拟所需依赖文件的脚本</span><br><span class="line">│   └── src/                      # unidbg-android 模块的源代码目录</span><br><span class="line">│       ├── main/</span><br><span class="line">│       │   ├── java/             # 核心 Java 源代码</span><br><span class="line">│       │   │   └── com/github/unidbg/  # 包含核心模拟器、文件系统、虚拟机组件</span><br><span class="line">│       │   │   └── net/fornwall/jelf   # ELF 文件格式解析实现</span><br><span class="line">│       │   └── resources/        # 资源文件，封装了 JNI 库、Android 系统库等</span><br><span class="line">│       ├── test/</span><br><span class="line">│       │   ├── java/             # 单元测试代码</span><br><span class="line">│       │   ├── native/android/   # 测试 Android 原生库的 C/C++ 源代码</span><br><span class="line">│       │   └── resources/        # 测试资源文件，包含预编译的二进制文件（log4j.properties这个是日志相关配置，可以对open,syscall这类的系统调用进行trace）</span><br><span class="line">└── .mvn/                         # Maven Wrapper 相关配置目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log4j.logger.com.github.unidbg.linux.file=DEBUG //把INFO改成DEBUG</span><br></pre></td></tr></table></figure>

<p><strong>项目式学习</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kanxue.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.unidbg.AndroidEmulator;</span><br><span class="line"><span class="keyword">import</span> com.github.unidbg.Module;</span><br><span class="line"><span class="keyword">import</span> com.github.unidbg.arm.backend.DynarmicFactory;</span><br><span class="line"><span class="keyword">import</span> com.github.unidbg.linux.android.AndroidEmulatorBuilder;</span><br><span class="line"><span class="keyword">import</span> com.github.unidbg.linux.android.AndroidResolver;</span><br><span class="line"><span class="keyword">import</span> com.github.unidbg.linux.android.dvm.DalvikModule;</span><br><span class="line"><span class="keyword">import</span> com.github.unidbg.linux.android.dvm.DvmObject;</span><br><span class="line"><span class="keyword">import</span> com.github.unidbg.linux.android.dvm.ProxyDvmObject;</span><br><span class="line"><span class="keyword">import</span> com.github.unidbg.linux.android.dvm.VM;</span><br><span class="line"><span class="keyword">import</span> com.github.unidbg.memory.Memory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AndroidEmulator emulator; <span class="comment">// 定义Android模拟器实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VM vm; <span class="comment">// 定义Dalvik虚拟机实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MainActivity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建32位Android模拟器实例，使用Dynarmic后端</span></span><br><span class="line">        emulator = AndroidEmulatorBuilder.for32Bit()</span><br><span class="line">                .addBackendFactory(<span class="keyword">new</span> <span class="title class_">DynarmicFactory</span>(<span class="literal">true</span>))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取模拟器的内存管理接口</span></span><br><span class="line">        <span class="type">Memory</span> <span class="variable">memory</span> <span class="operator">=</span> emulator.getMemory();</span><br><span class="line">        <span class="comment">// 设置系统类库</span></span><br><span class="line">        <span class="type">LibraryResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AndroidResolver</span>(<span class="number">23</span>);</span><br><span class="line">        memory.setLibraryResolver(resolver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Dalvik虚拟机实例</span></span><br><span class="line">        vm = emulator.createDalvikVM();</span><br><span class="line">        <span class="comment">// 设置是否输出详细的JNI调用日志</span></span><br><span class="line">        vm.setVerbose(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载指定路径的SO库文件，不自动调用JNI_OnLoad函数</span></span><br><span class="line">        <span class="type">DalvikModule</span> <span class="variable">dm</span> <span class="operator">=</span> vm.loadLibrary(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;unidbg-android/src/test/resources/example_binaries/armeabi-v7a/libnative-lib.so&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 手动调用JNI_OnLoad方法</span></span><br><span class="line">        dm.callJNI_OnLoad(emulator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">crack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个vm对象，模拟Java层的对象传递给JNI层</span></span><br><span class="line">        DvmObject&lt;?&gt; obj = ProxyDvmObject.createObject(vm, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有可能的三字符组合，尝试破解</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> a : LETTERS) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> b : LETTERS) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> c : LETTERS) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + a + b + c;</span><br><span class="line">                    <span class="comment">// 调用JNI方法，传入当前组合，判断是否成功</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> obj.callJniMethodBoolean(emulator, <span class="string">&quot;jnitest(Ljava/lang/String;)Z&quot;</span>, str);</span><br><span class="line">                    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                        <span class="comment">// 如果成功，输出结果并结束</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;Found: &quot;</span> + str + <span class="string">&quot;, off=&quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>[] LETTERS = &#123;  </span><br><span class="line">        <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;M&#x27;</span>,  </span><br><span class="line">        <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>,  </span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>,  </span><br><span class="line">        <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>  </span><br><span class="line">        &#125;; <span class="comment">// 定义字母表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="comment">//记录开始时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();  </span><br><span class="line">        <span class="comment">// 创建MainActivity实例</span></span><br><span class="line">        <span class="type">MainActivity</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MainActivity</span>();</span><br><span class="line">        <span class="comment">//输出调用结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;load offset=&quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);  </span><br><span class="line">        <span class="comment">// 调用破解方法</span></span><br><span class="line">        main.crack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emulator = AndroidEmulatorBuilder.for32Bit()</span><br><span class="line">            .addBackendFactory(new DynarmicFactory(true))</span><br><span class="line">            .build();</span><br></pre></td></tr></table></figure>

<ul>
<li>1.for32Bit()的意思是创建32位Android模拟器实例，for64Bit()则是创建64位，apk lib 里只有armeabi-v7a，那就只能选择 32 位，apk lib 里只有arm64-v8a，就选择 64 位。区别：64位的执行速度较快，浮动10%左右；Unidbg 对 ARM32 的支持和完善程度高于 ARM64</li>
<li>2.Unidbg 支持了数个后端，目前共五个 Backend，分别是 Unicorn、Unicorn2、Dynarmic(执行速度较快)、Hypervisor、KVM。new DynarmicFactory(true)中的true，标志着在出现异常时是否使用默认后端unicorn。</li>
</ul>
<p><strong>emulator常用Api</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>方法名</strong></th>
<th align="left"><strong>返回类型</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>getMemory()</code></td>
<td align="left"><code>Memory</code></td>
<td align="left">获取内存操作接口。</td>
</tr>
<tr>
<td align="left"><code>getPid()</code></td>
<td align="left"><code>int</code></td>
<td align="left">获取进程的 PID。</td>
</tr>
<tr>
<td align="left"><code>createDalvikVM()</code></td>
<td align="left"><code>VM</code></td>
<td align="left">创建虚拟机。</td>
</tr>
<tr>
<td align="left"><code>createDalvikVM(File apkFile)</code></td>
<td align="left"><code>VM</code></td>
<td align="left">创建虚拟机并指定 APK 文件路径。</td>
</tr>
<tr>
<td align="left"><code>getDalvikVM()</code></td>
<td align="left"><code>VM</code></td>
<td align="left">获取已创建的虚拟机。</td>
</tr>
<tr>
<td align="left"><code>showRegs()</code></td>
<td align="left"><code>void</code></td>
<td align="left">显示当前寄存器状态，可指定寄存器。</td>
</tr>
<tr>
<td align="left"><code>getBackend()</code></td>
<td align="left"><code>Backend</code></td>
<td align="left">获取后端 CPU。</td>
</tr>
<tr>
<td align="left"><code>getProcessName()</code></td>
<td align="left"><code>String</code></td>
<td align="left">获取进程名。</td>
</tr>
<tr>
<td align="left"><code>getContext()</code></td>
<td align="left"><code>RegisterContext</code></td>
<td align="left">获取寄存器上下文。</td>
</tr>
<tr>
<td align="left"><code>traceRead(long begin, long end)</code></td>
<td align="left"><code>void</code></td>
<td align="left">Trace 读内存操作。</td>
</tr>
<tr>
<td align="left"><code>traceWrite(long begin, long end)</code></td>
<td align="left"><code>void</code></td>
<td align="left">Trace 写内存操作。</td>
</tr>
<tr>
<td align="left"><code>traceCode(long begin, long end)</code></td>
<td align="left"><code>void</code></td>
<td align="left">Trace 汇编指令执行。</td>
</tr>
<tr>
<td align="left"><code>isRunning()</code></td>
<td align="left"><code>boolean</code></td>
<td align="left">判断当前 Emulator 是否正在运行。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LibraryResolver resolver = new AndroidResolver(23);</span><br><span class="line">memory.setLibraryResolver(resolver);</span><br></pre></td></tr></table></figure>

<p>23 和 19 分别对应于 sdk23（Android 6.0） 和 sdk19（Android 4.4）的运行库环境，处理 64 位 SO 时只能选择 SDK23。</p>
<p><strong>memory常用Api</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>方法名</strong></th>
<th align="left"><strong>返回类型</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>setLibraryResolver(AndroidResolver resolver)</code></td>
<td align="left"><code>void</code></td>
<td align="left">设置 Android SDK 版本解析器，目前支持 19 和 23 两个版本。</td>
</tr>
<tr>
<td align="left"><code>getStackPoint()</code></td>
<td align="left"><code>long</code></td>
<td align="left">获取当前栈指针的值。</td>
</tr>
<tr>
<td align="left"><code>pointer(long address)</code></td>
<td align="left"><code>UnidbgPointer</code></td>
<td align="left">获取指针，指向指定内存地址，可通过指针操作内存。</td>
</tr>
<tr>
<td align="left"><code>getMemoryMap()</code></td>
<td align="left"><code>Collection&lt;MemoryMap&gt;</code></td>
<td align="left">获取当前内存的映射情况。</td>
</tr>
<tr>
<td align="left"><code>findModule(String moduleName)</code></td>
<td align="left"><code>Module</code></td>
<td align="left">根据模块名获取指定模块。</td>
</tr>
<tr>
<td align="left"><code>findModuleByAddress(long address)</code></td>
<td align="left"><code>Module</code></td>
<td align="left">根据地址获取指定模块。</td>
</tr>
<tr>
<td align="left"><code>loadLibrary(File file, boolean forceLoad)</code></td>
<td align="left"><code>ElfModule</code></td>
<td align="left">加载 SO 文件，会调用 <code>Linker.do_dlopen()</code> 方法完成加载。</td>
</tr>
<tr>
<td align="left"><code>allocatestack(int size)</code></td>
<td align="left"><code>UnidbgPointer</code></td>
<td align="left">在栈上分配指定大小的内存空间。</td>
</tr>
<tr>
<td align="left"><code>writestackstring(String value)</code></td>
<td align="left"><code>UnidbgPointer</code></td>
<td align="left">将字符串写入栈内存中。</td>
</tr>
<tr>
<td align="left"><code>writestackBytes(byte[] value)</code></td>
<td align="left"><code>UnidbgPointer</code></td>
<td align="left">将字节数组写入栈内存中。</td>
</tr>
<tr>
<td align="left"><code>malloc(int size, boolean runtime)</code></td>
<td align="left"><code>UnidbgPointer</code></td>
<td align="left">分配指定大小的内存空间，返回指向该内存的指针。</td>
</tr>
</tbody></table>
<p>vm常用Api</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Dalvik虚拟机实例</span></span><br><span class="line">vm = emulator.createDalvikVM();</span><br><span class="line"><span class="comment">// 设置是否输出详细的JNI调用日志</span></span><br><span class="line">vm.setVerbose(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 加载指定路径的SO库文件，不自动调用JNI_OnLoad函数</span></span><br><span class="line"><span class="type">DalvikModule</span> <span class="variable">dm</span> <span class="operator">=</span> vm.loadLibrary(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;unidbg-android/src/test/resources/example_binaries/armeabi-v7a/libnative-lib.so&quot;</span>), <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 手动调用JNI_OnLoad方法</span></span><br><span class="line">dm.callJNI_OnLoad(emulator);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left"><strong>方法名</strong></th>
<th align="left"><strong>返回类型</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>createDalvikVM(File apkFile)</code></td>
<td align="left"><code>VM</code></td>
<td align="left">创建虚拟机，指定 APK 文件，file可为空</td>
</tr>
<tr>
<td align="left"><code>setVerbose(boolean verbose)</code></td>
<td align="left"><code>void</code></td>
<td align="left">设置是否输出 JNI 运行日志。</td>
</tr>
<tr>
<td align="left"><code>loadLibrary(File soFile, boolean callInit)</code></td>
<td align="left"><code>DalvikModule</code></td>
<td align="left">加载 SO 模块，参数二设置是否自动调用 <code>init</code> 函数。</td>
</tr>
<tr>
<td align="left"><code>setJni(Jni jni)</code></td>
<td align="left"><code>void</code></td>
<td align="left">设置 JNI 交互接口，推荐实现 <code>AbstractJni</code>。</td>
</tr>
<tr>
<td align="left"><code>getJNIEnv()</code></td>
<td align="left"><code>Pointer</code></td>
<td align="left">获取 JNIEnv 指针，可作为参数传递。</td>
</tr>
<tr>
<td align="left"><code>getJavaVM()</code></td>
<td align="left"><code>Pointer</code></td>
<td align="left">获取 JavaVM 指针，可作为参数传递。</td>
</tr>
<tr>
<td align="left"><code>callJNI_OnLoad(Emulator&lt;?&gt; emulator, Module module)</code></td>
<td align="left"><code>void</code></td>
<td align="left">调用 <code>JNI_OnLoad</code> 函数。</td>
</tr>
<tr>
<td align="left"><code>addGlobalObject(DvmObject&lt;?&gt; obj)</code></td>
<td align="left"><code>int</code></td>
<td align="left">向 VM 添加全局对象，返回该对象的 hash 值。</td>
</tr>
<tr>
<td align="left"><code>addLocalObject(DvmObject&lt;?&gt; obj)</code></td>
<td align="left"><code>int</code></td>
<td align="left">向 VM 添加局部对象，返回该对象的 hash 值。</td>
</tr>
<tr>
<td align="left"><code>getObject(int hash)</code></td>
<td align="left"><code>DvmObject&lt;?&gt;</code></td>
<td align="left">根据 hash 值获取虚拟机中的对象。</td>
</tr>
<tr>
<td align="left"><code>resolveClass(String className)</code></td>
<td align="left"><code>DvmClass</code></td>
<td align="left">解析指定类名，构建并返回一个 <code>DvmClass</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>getPackageName()</code></td>
<td align="left"><code>String</code></td>
<td align="left">获取 APK 包名。</td>
</tr>
<tr>
<td align="left"><code>getVersionName()</code></td>
<td align="left"><code>String</code></td>
<td align="left">获取 APK 版本名称。</td>
</tr>
<tr>
<td align="left"><code>getVersionCode()</code></td>
<td align="left"><code>String</code></td>
<td align="left">获取 APK 版本号。</td>
</tr>
<tr>
<td align="left"><code>openAsset(String assetName)</code></td>
<td align="left"><code>InputStream</code></td>
<td align="left">打开 APK 中的指定资源文件。</td>
</tr>
<tr>
<td align="left"><code>getManifestXml()</code></td>
<td align="left"><code>String</code></td>
<td align="left">获取 <code>AndroidManifest.xml</code> 文件的文本内容。</td>
</tr>
<tr>
<td align="left"><code>getSignatures()</code></td>
<td align="left"><code>CertificateMeta[]</code></td>
<td align="left">获取 APK 签名信息。</td>
</tr>
<tr>
<td align="left"><code>findClass(String className)</code></td>
<td align="left"><code>DvmClass</code></td>
<td align="left">通过类名获取已经加载的类（<code>DvmClass</code> 对象）。</td>
</tr>
<tr>
<td align="left"><code>getEmulator()</code></td>
<td align="left"><code>Emulator&lt;?&gt;</code></td>
<td align="left">获取模拟器对象 <code>emulator</code>。</td>
</tr>
</tbody></table>
<ul>
<li>1.<code>VM dalvikVM = emulator.createDalvikVM(new File(&quot;apk file path&quot;))</code>-创建虚拟机并指定APK文件，加载指定APK文件，unidbg可以帮我们完成一些小操作，例如：解析 Apk 基本信息，Apk 的版本名、版本号、包名、 Apk 签名等信息，减少补环境操作；解析和管理 Apk 资源文件，加载 Apk 后可以通过 <code>openAsset</code>获取 APK <code>assets</code>目录下的文件。</li>
<li>2.<code>loadLibrary</code>三个重载方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载指定名称的库文件。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> libname 库文件的名称，不包括前缀 &quot;lib&quot; 和后缀 &quot;.so&quot;（例如 &quot;example&quot; 对应 &quot;libexample.so&quot;）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forceCallInit 是否强制调用库的初始化函数（如 JNI_OnLoad）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> 加载后的 DalvikModule 对象，封装了加载的库模块。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DalvikModule <span class="title function_">loadLibrary</span><span class="params">(String libname, <span class="type">boolean</span> forceCallInit)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从原始字节数组中加载指定的库文件。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> libname 库文件的名称，仅用于标识该库，与文件路径无关。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 传入buffer方便解析elf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DalvikModule <span class="title function_">loadLibrary</span><span class="params">(String libname, <span class="type">byte</span>[] raw, <span class="type">boolean</span> forceCallInit)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从指定路径的加载ELF。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elfFile 表示库的 ELF 文件，必须是有效的 ELF 格式文件。例如:new File(&quot;unidbg-android/src/test/resources/example_binaries/armeabi-v7a/libnative-lib.so&quot;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forceCallInit 是否强制调用库的初始化函数（如 JNI_OnLoad）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DalvikModule <span class="title function_">loadLibrary</span><span class="params">(File elfFile, <span class="type">boolean</span> forceCallInit)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>jni函数的调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数传入模拟器实例</span></span><br><span class="line"><span class="comment">//第二个参数传入要调用的函数在java层方法签名信息</span></span><br><span class="line"><span class="comment">//第三个参数传入可变参数列表，这里的参数在旧版本有很多需要自己封装，新版则帮我们封装好了，详细看callJniMethod方法</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> obj.callJniMethodBoolean(emulator, <span class="string">&quot;jnitest(Ljava/lang/String;)Z&quot;</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用 JNI 方法的辅助函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> emulator   模拟器实例。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> vm         Dalvik 虚拟机实例。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> objectType 调用方法的类（DvmClass）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> thisObj    方法调用的对象实例（DvmObject）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method     要调用的方法签名（例如 &quot;methodName(参数类型)返回类型&quot;）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args       方法的可变参数列表。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>           方法执行后的返回值（Number 类型），可能是整数或浮点数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Number <span class="title function_">callJniMethod</span><span class="params">(Emulator&lt;?&gt; emulator, VM vm, DvmClass objectType, DvmObject&lt;?&gt; thisObj, String method, Object... args)</span> &#123;</span><br><span class="line">    <span class="comment">// 查找对应的本地函数指针（Native 方法）</span></span><br><span class="line">    <span class="type">UnidbgPointer</span> <span class="variable">fnPtr</span> <span class="operator">=</span> objectType.findNativeFunction(emulator, method);</span><br><span class="line">    <span class="comment">// 将当前对象添加到本地引用表，防止被垃圾回收</span></span><br><span class="line">    vm.addLocalObject(thisObj);</span><br><span class="line">    <span class="comment">// 创建用于存放函数参数的列表，初始容量为10</span></span><br><span class="line">    List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 添加 JNI 环境指针（JNIEnv*）</span></span><br><span class="line">    list.add(vm.getJNIEnv());</span><br><span class="line">    <span class="comment">// 添加 this 对象的引用（jobject）</span></span><br><span class="line">    list.add(thisObj.hashCode());</span><br><span class="line">    <span class="comment">// 处理传入的参数列表</span></span><br><span class="line">    <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">                <span class="comment">// 如果参数是布尔值，转换为 JNI_TRUE 或 JNI_FALSE</span></span><br><span class="line">                list.add((Boolean) arg ? VM.JNI_TRUE : VM.JNI_FALSE);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Hashable) &#123;</span><br><span class="line">                <span class="comment">// 如果参数实现了 Hashable 接口，表示是 DvmObject 或其子类</span></span><br><span class="line">                list.add(arg.hashCode()); <span class="comment">// 添加对象引用（jobject）</span></span><br><span class="line">                <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> DvmObject) &#123;</span><br><span class="line">                    <span class="comment">// 将 DvmObject 对象添加到本地引用表</span></span><br><span class="line">                    vm.addLocalObject((DvmObject&lt;?&gt;) arg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> DvmAwareObject ||</span><br><span class="line">                    arg <span class="keyword">instanceof</span> String ||</span><br><span class="line">                    arg <span class="keyword">instanceof</span> <span class="type">byte</span>[] ||</span><br><span class="line">                    arg <span class="keyword">instanceof</span> <span class="type">short</span>[] ||</span><br><span class="line">                    arg <span class="keyword">instanceof</span> <span class="type">int</span>[] ||</span><br><span class="line">                    arg <span class="keyword">instanceof</span> <span class="type">float</span>[] ||</span><br><span class="line">                    arg <span class="keyword">instanceof</span> <span class="type">double</span>[] ||</span><br><span class="line">                    arg <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">                <span class="comment">// 如果参数是 DvmAwareObject、字符串、数组或枚举等类型</span></span><br><span class="line">                <span class="comment">// 创建一个代&#123;过&#125;&#123;滤&#125;理 DvmObject 对象</span></span><br><span class="line">                DvmObject&lt;?&gt; obj = ProxyDvmObject.createObject(vm, arg);</span><br><span class="line">                <span class="comment">// 添加对象引用（jobject）</span></span><br><span class="line">                list.add(obj.hashCode());</span><br><span class="line">                <span class="comment">// 将对象添加到本地引用表</span></span><br><span class="line">                vm.addLocalObject(obj);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于其他类型的参数，直接添加到参数列表</span></span><br><span class="line">            list.add(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用本地函数，传入参数列表，并返回结果</span></span><br><span class="line">    <span class="keyword">return</span> Module.emulateFunction(emulator, fnPtr.peer, list.toArray());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>基本类型直接传递，int、long、boolean、double 等。</p>
<ul>
<li><p>下面几种对象类型unidbg也帮我们封装好了</p>
</li>
<li><p>String</p>
</li>
<li><p>byte 数组</p>
</li>
<li><p>short 数组</p>
</li>
<li><p>int 数组</p>
</li>
<li><p>float 数组</p>
</li>
<li><p>double 数组</p>
</li>
<li><p>Enum 枚举类型</p>
</li>
</ul>
<p>特殊参数构造:对于其他数据类型需要借助<code>resolveClass</code>构造，例如<code>Context</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DvmObject&lt;?&gt; context = vm.resolveClass(&quot;android/content/Context&quot;).newObject(null);</span><br></pre></td></tr></table></figure>

<p><strong>符号调用与偏移调用</strong></p>
<p><strong>符号调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Symbol</span> <span class="variable">symbol</span> <span class="operator">=</span> <span class="keyword">module</span>.findSymbolByName(<span class="string">&quot;导出符号&quot;</span>);  </span><br><span class="line"><span class="keyword">if</span> (symbol != <span class="literal">null</span>)&#123;  </span><br><span class="line">        <span class="comment">//第一个模拟器实例，第二个jnienv，第三个jclass，第四个可变参数</span></span><br><span class="line">    <span class="type">Number</span> <span class="variable">numbers</span> <span class="operator">=</span> symbol.call(emulator, vm.getJNIEnv(), vm.addLocalObject(实例类), 可变参数);  </span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> numbers.intValue(); </span><br><span class="line">    System.out.println(result);  </span><br><span class="line">    <span class="comment">//如果返回值是string，可以通过vm.getObject(retval)获取</span></span><br><span class="line">    System.out.println(vm.getObject(result).getValue());</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;符号未找到&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>偏移调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个模拟器实例，第二个偏移地址(thumb记得+1)，第三个jnienv，第四个jclass，第五个可变参数</span></span><br><span class="line"><span class="type">Number</span> <span class="variable">number</span> <span class="operator">=</span> <span class="keyword">module</span>.callFunction(emulator, <span class="number">0x11240</span>, vm.getJNIEnv(),vm.addLocalObject(SecurityUtils),vm.addLocalObject(<span class="keyword">new</span> <span class="title class_">StringObject</span>(vm, <span class="string">&quot;超级&quot;</span>)));</span><br><span class="line">DvmObject&lt;?&gt; object = vm.getObject(number.intValue());  </span><br><span class="line">System.out.println(<span class="string">&quot;result:&quot;</span> + object.getValue());</span><br></pre></td></tr></table></figure>

<p><strong>unidbg之hook</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>类别</strong></th>
<th align="left"><strong>描述</strong></th>
<th align="left"><strong>优点</strong></th>
<th align="left"><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>内置的第三方 Hook 框架</strong></td>
<td align="left">包括 Dobby（前身为 HookZz）、Whale 和 xHook 等。HookZz对于32位支持较好，Dobby64位，XHook不能Hook Sub_xxx 子函数。</td>
<td align="left">- <strong>功能丰富</strong>：支持多种 Hook 方式，如 Inline Hook 和 PLT Hook。<br>- <strong>易于使用</strong>：提供简洁的 API 接口，便于快速上手。</td>
<td align="left">- <strong>可能被检测</strong>：某些应用可能检测到这些 Hook 框架的存在。<br>- <strong>局限性</strong>：Inline Hook 在短函数或相邻地址的函数中可能出现问题；PLT Hook 无法 Hook 非导出函数。</td>
</tr>
<tr>
<td align="left"><strong>基于 Unicorn 引擎的原生 Hook 功能</strong></td>
<td align="left">利用 Unicorn 引擎实现的指令级Hook，块级Hook，内存读写Hook，异常Hook等功能，Unidbg 在此基础上还封装了 Console Debugger。</td>
<td align="left">- <strong>隐蔽性强</strong>：原生 Hook 方式更难被应用检测到。<br>- <strong>灵活性高</strong>：可对任意代码位置进行 Hook，无特定限制。</td>
<td align="left">- <strong>使用复杂度较高</strong>：需要深入理解底层机制，配置相对复杂。</td>
</tr>
</tbody></table>
<p><strong>HookZz&amp;Dobby</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 HookZz 实例，用于后续的 Hook 操作</span></span><br><span class="line"><span class="title class_">IHookZz</span> hookZz = <span class="title class_">HookZz</span>.<span class="title function_">getInstance</span>(emulator);</span><br><span class="line"><span class="comment">// 使用 HookZz 的 wrap 方法对导出函数 &quot;ss_encrypt&quot; 进行 Inline Hook</span></span><br><span class="line">hookZz.<span class="title function_">wrap</span>(<span class="variable language_">module</span>.<span class="title function_">findSymbolByName</span>(<span class="string">&quot;ss_encrypt&quot;</span>), <span class="keyword">new</span> <span class="title class_">WrapCallback</span>&lt;<span class="title class_">RegisterContext</span>&gt;() &#123;</span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">preCall</span>(<span class="params">Emulator&lt;?&gt; emulator, RegisterContext ctx, HookEntryInfo info</span>) &#123;</span><br><span class="line">        <span class="comment">// 在函数调用前执行的操作</span></span><br><span class="line">        <span class="comment">// 获取第三个参数的指针</span></span><br><span class="line">        <span class="title class_">Pointer</span> pointer = ctx.<span class="title function_">getPointerArg</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 获取第四个参数的整数值</span></span><br><span class="line">        int length = ctx.<span class="title function_">getIntArg</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 读取指针指向的内存内容，获取密钥数据</span></span><br><span class="line">        byte[] key = pointer.<span class="title function_">getByteArray</span>(<span class="number">0</span>, length);</span><br><span class="line">        <span class="comment">// 使用 Inspector 工具输出密钥内容，便于调试和分析</span></span><br><span class="line">        <span class="title class_">Inspector</span>.<span class="title function_">inspect</span>(key, <span class="string">&quot;ss_encrypt key&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">postCall</span>(<span class="params">Emulator&lt;?&gt; emulator, RegisterContext ctx, HookEntryInfo info</span>) &#123;</span><br><span class="line">        <span class="comment">// 在函数调用后执行的操作</span></span><br><span class="line">        <span class="comment">// 输出函数返回值的值</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;ss_encrypt.postCall R0=&quot;</span> + ctx.<span class="title function_">getLongArg</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>获取 HookZz 实例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IHookZz hookZz = HookZz.getInstance(emulator);</span><br></pre></td></tr></table></figure>

<p><strong>wrap_hook函数</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hookZz.<span class="title function_">wrap</span>(functionAddress, <span class="keyword">new</span> <span class="title class_">WrapCallback</span>&lt;<span class="title class_">RegisterContext</span>&gt;() &#123;</span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">preCall</span>(<span class="params">Emulator&lt;?&gt; emulator, RegisterContext context, HookEntryInfo info</span>) &#123;</span><br><span class="line">        <span class="comment">// 函数调用前的操作</span></span><br><span class="line">        <span class="title class_">UnidbgPointer</span> input = ctx.<span class="title function_">getPointerArg</span>(<span class="number">2</span>);  </span><br><span class="line">                <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;preCall:&quot;</span>+vm.<span class="title function_">getObject</span>(input.<span class="title function_">toIntPeer</span>()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">postCall</span>(<span class="params">Emulator&lt;?&gt; emulator, RegisterContext context, HookEntryInfo info</span>) &#123;</span><br><span class="line">        <span class="comment">// 函数调用后的操作</span></span><br><span class="line">        <span class="comment">//获取整数型的返回值</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;postCall:&quot;</span> + ctx.<span class="title function_">getLongArg</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//获取jstr</span></span><br><span class="line">                <span class="title class_">UnidbgPointer</span> input = ctx.<span class="title function_">getPointerArg</span>(<span class="number">0</span>);  </span><br><span class="line">                <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;postCall:&quot;</span>+vm.<span class="title function_">getObject</span>(input.<span class="title function_">toIntPeer</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>wrap</code>函数有两个重载，一个基于符号寻址，一个基于地址寻址，本质没区别，符号寻址的最终也是会调用<code>symbol.getAddress()</code><br>参数里的WrapCallback的泛型接口有三个<code>RegisterContext(函数 Hook)</code>、<code>HookZzArm32RegisterContext(针对ARM32位)</code>和<code>HookZzArm64RegisterContext(针对ARM64位)</code>因为可以访问某个寄存器的值，所以适用于inline hook</p>
<p>而在<code>HookZzArm64RegisterContext</code>中则是通过以下的方法去获取对应的寄存器的值</p>
<p><strong>instrument_inline_hook函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 HookZz 的 instrument 方法对特定地址的指令进行 Inline Hook, thumb记得+1</span></span><br><span class="line">hookZz.instrument(<span class="keyword">module</span>.base + <span class="number">0x11470</span>, <span class="keyword">new</span> <span class="title class_">InstrumentCallback</span>&lt;Arm64RegisterContext&gt;() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dbiCall</span><span class="params">(Emulator&lt;?&gt; emulator, Arm64RegisterContext ctx, HookEntryInfo info)</span> &#123; </span><br><span class="line">            <span class="comment">// 在指定指令执行时触发的操作</span></span><br><span class="line">        <span class="comment">// 输出 W0 寄存器的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;W0=&quot;</span> + ctx.getXInt(<span class="number">0</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>replace替换函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 dobby 的 replace 方法替换 &quot;Java_com_zj_wuaipojie_util_SecurityUtil_diamondNum&quot; 函数的实现</span></span><br><span class="line"><span class="type">Dobby</span> <span class="variable">dobby</span> <span class="operator">=</span> Dobby.getInstance(emulator);  </span><br><span class="line">dobby.replace(<span class="keyword">module</span>.findSymbolByName(<span class="string">&quot;Java_com_zj_wuaipojie_util_SecurityUtil_diamondNum&quot;</span>), <span class="keyword">new</span> <span class="title class_">ReplaceCallback</span>() &#123; <span class="comment">// 使用Dobby inline hook导出函数  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> HookStatus <span class="title function_">onCall</span><span class="params">(Emulator&lt;?&gt; emulator, HookContext context, <span class="type">long</span> originFunction)</span> &#123;  </span><br><span class="line">                <span class="comment">//替换整数型</span></span><br><span class="line">        <span class="keyword">return</span> HookStatus.LR(emulator,<span class="number">888888</span>);  </span><br><span class="line">        <span class="comment">//字符串</span></span><br><span class="line">        <span class="keyword">return</span> HookStatus.LR(emulator, vm.addLocalObject(<span class="keyword">new</span> <span class="title class_">StringObject</span>(vm, <span class="string">&quot;超级&quot;</span>)));</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">emulator.<span class="title function_">getBackend</span>().<span class="title function_">hook_add_new</span>(<span class="keyword">new</span> <span class="title class_">CodeHook</span>() &#123;  </span><br><span class="line">    @<span class="title class_">Override</span>  </span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">hook</span>(<span class="params">Backend backend, long address, int size, <span class="built_in">Object</span> user</span>) &#123;  </span><br><span class="line">        <span class="title class_">Arm64RegisterContext</span> context = emulator.<span class="title function_">getContext</span>();  </span><br><span class="line">        <span class="keyword">if</span> (address == <span class="variable language_">module</span>.<span class="property">base</span> + <span class="number">0x11330</span>) &#123;  </span><br><span class="line">            int x0=emulator.<span class="title function_">getBackend</span>().<span class="title function_">reg_read</span>(<span class="title class_">Arm64Const</span>.<span class="property">UC_ARM64_REG_X0</span>).<span class="title function_">intValue</span>();  </span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;x0:&quot;</span>+vm.<span class="title function_">getObject</span>(x0));  </span><br><span class="line">            emulator.<span class="title function_">getBackend</span>().<span class="title function_">reg_write</span>(<span class="title class_">Arm64Const</span>.<span class="property">UC_ARM64_REG_X0</span>,vm.<span class="title function_">addLocalObject</span>(<span class="keyword">new</span> <span class="title class_">StringObject</span>(vm, <span class="string">&quot;超级&quot;</span>)));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @<span class="title class_">Override</span>  </span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">onAttach</span>(<span class="params">UnHook unHook</span>) &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @<span class="title class_">Override</span>  </span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">detach</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;, <span class="variable language_">module</span>.<span class="property">base</span> + <span class="number">0x11240</span>,<span class="variable language_">module</span>.<span class="property">base</span> + <span class="number">0x11340</span>,<span class="literal">null</span>);  </span><br><span class="line"><span class="title class_">StringObject</span> <span class="title class_">Result</span> = <span class="title class_">SecurityUtils</span>.<span class="title function_">callStaticJniMethodObject</span>(emulator, <span class="string">&quot;vipLevel(Ljava/lang/String;)Ljava/lang/String;&quot;</span>, <span class="string">&quot;123&quot;</span>); </span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;Result: &quot;</span> + <span class="title class_">Result</span>.<span class="title function_">getValue</span>());</span><br></pre></td></tr></table></figure>

<p><strong>Console Debugge</strong></p>
<p>Console Debugger（控制台调试器）是 Unidbg 提供的一个强大工具，允许用户在模拟执行过程中设置断点、单步调试、查看和修改内存及寄存器等操作，从而深入分析目标程序的行为。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Debugger</span> <span class="variable">attach</span> <span class="operator">=</span> emulator.attach();  </span><br><span class="line">attach.addBreakPoint(<span class="keyword">module</span>.base + <span class="number">0x11070</span>); <span class="comment">//下断地址</span></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="type">Number</span> <span class="variable">number</span> <span class="operator">=</span> <span class="keyword">module</span>.callFunction(emulator, <span class="number">0x11014</span>, vm.getJNIEnv(),vm.addLocalObject(SecurityUtils),vm.addLocalObject(<span class="keyword">new</span> <span class="title class_">StringObject</span>(vm, <span class="string">&quot;123456&quot;</span>)));  </span><br><span class="line">System.out.println(<span class="string">&quot;result:&quot;</span> + number.intValue());</span><br></pre></td></tr></table></figure>

<p>替换返回值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">emulator.<span class="title function_">attach</span>().<span class="title function_">addBreakPoint</span>(<span class="variable language_">module</span>.<span class="title function_">findSymbolByName</span>(<span class="string">&quot;verifyApkSign&quot;</span>).<span class="title function_">getAddress</span>(), <span class="keyword">new</span> <span class="title class_">BreakPointCallback</span>() &#123;</span><br><span class="line">        @<span class="title class_">Override</span></span><br><span class="line">        public boolean <span class="title function_">onHit</span>(<span class="params">Emulator&lt;?&gt; emulator, long address</span>) &#123;</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;替换函数 verifyApkSign&quot;</span>);</span><br><span class="line">            <span class="title class_">RegisterContext</span> registerContext = emulator.<span class="title function_">getContext</span>();</span><br><span class="line">            emulator.<span class="title function_">getBackend</span>().<span class="title function_">reg_write</span>(<span class="title class_">ArmConst</span>.<span class="property">UC_ARM_REG_PC</span>, registerContext.<span class="title function_">getLRPointer</span>().<span class="property">peer</span>);</span><br><span class="line">            emulator.<span class="title function_">getBackend</span>().<span class="title function_">reg_write</span>(<span class="title class_">ArmConst</span>.<span class="property">UC_ARM_REG_R0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">功能说明</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>c</code></td>
<td align="left">继续执行程序</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>n</code></td>
<td align="left">跨过当前指令</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>bt</code></td>
<td align="left">回溯堆栈</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>st hex</code></td>
<td align="left">搜索堆栈</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>shw hex</code></td>
<td align="left">搜索可写堆</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>shr hex</code></td>
<td align="left">搜索可读堆</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>shx-hex</code></td>
<td align="left">搜索可执行堆</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>nb</code></td>
<td align="left">在下一个区块中断</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s</code></td>
<td align="left">步入当前指令</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s [decimal]</code></td>
<td align="left">执行指定数量的指令</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s (blx)</code></td>
<td align="left">执行直到 <code>blx</code> 助记符（性能较低）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>m (op) [size]</code></td>
<td align="left">显示内存，默认大小为 <code>0x70</code>，大小可为十六进制或十进制</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>mr0-mr7, mfp, mip, msp [size]</code></td>
<td align="left">显示指定寄存器的内存</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>m (address) [size]</code></td>
<td align="left">显示指定地址的内存，地址需以 <code>0x</code> 开头</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>wr0-wr7, wfp, wip, wsp &lt;value&gt;</code></td>
<td align="left">写入指定寄存器</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>wb(address), ws(address), wi(address) &lt;value&gt;</code></td>
<td align="left">写入指定地址的（字节、短、整数）内存，地址需以 <code>0x</code> 开头</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>wx (address) &lt;hex&gt;</code></td>
<td align="left">将字节写入指定地址的内存，地址需以 <code>0x</code> 开头</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>b (address)</code></td>
<td align="left">添加临时断点，地址需以 <code>0x</code> 开头，可为模块偏移量</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>b</code></td>
<td align="left">添加寄存器 <code>PC</code> 的断点</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>r</code></td>
<td align="left">删除寄存器 <code>PC</code> 的断点</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>blr</code></td>
<td align="left">添加寄存器 <code>LR</code> 的临时断点</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>p (assembly)</code></td>
<td align="left">在 PC 地址修补汇编指令</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>where</code></td>
<td align="left">显示 Java 堆栈跟踪</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>trace [begin-end]</code></td>
<td align="left">设置指令跟踪</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>traceRead [begin-end]</code></td>
<td align="left">设置内存读取跟踪</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>traceWrite [begin-end]</code></td>
<td align="left">设置内存写入跟踪</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>vm</code></td>
<td align="left">查看已加载的模块</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>vbs</code></td>
<td align="left">查看断点</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>d</code></td>
<td align="left">显示反汇编代码</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>d (0x)</code></td>
<td align="left">在指定地址显示反汇编代码</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>stop</code></td>
<td align="left">停止模拟</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>run [arg]</code></td>
<td align="left">运行测试</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>gc</code></td>
<td align="left">运行 <code>System.gc()</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>threads</code></td>
<td align="left">显示线程列表</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>cc size</code></td>
<td align="left">将地址范围的汇编代码转为 C 函数</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>unidbg之patch</strong></p>
<p>Patch 就是直接对二进制文件进行修改，Patch本质上只有两种形式</p>
<ul>
<li>patch 二进制文件</li>
<li>在内存里 patch<br>Patch的应用场景很多，在一些场景比Hook更好用，这就是需要介绍它的原因。Patch 二进制文件的形式是大多数人所熟悉的，在IDA中使用KeyPatch打补丁的体验很友好。这里主要介绍unidbg的内存Patch。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UnidbgPointer</span> <span class="variable">pointer</span> <span class="operator">=</span> UnidbgPointer.pointer(emulator,<span class="keyword">module</span>.base + <span class="number">0x1146C</span>);  </span><br><span class="line"><span class="comment">//在进行 Patch 操作前，需确保已正确定位目标函数的地址和指令集类型（如 ARM 或 Thumb）</span></span><br><span class="line"><span class="comment">//如果是32位的，代码如下：Keystone keystone = new Keystone(KeystoneArchitecture.Arm, KeystoneMode.ArmThumb);</span></span><br><span class="line"><span class="type">Keystone</span> <span class="variable">keystone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Keystone</span>(KeystoneArchitecture.Arm64, KeystoneMode.LittleEndian);  </span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;MOV W0, #0x99&quot;</span>;  <span class="comment">//具体要修改的汇编指令</span></span><br><span class="line"><span class="type">byte</span>[] machineCode = keystone.assemble(s).getMachineCode();   <span class="comment">//转换为机器码</span></span><br><span class="line">pointer.write(machineCode); <span class="comment">//写入内存</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://matriy330.github.io">Matriy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://matriy330.github.io/1610ef8a/">http://matriy330.github.io/1610ef8a/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://matriy330.github.io" target="_blank">Matriy's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><div class="post-share"><div class="social-share" data-image="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/zsm.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/zsm.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/zfb.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/zfb.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/b20671e0/" title="Android逆向1-smali"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-25</div><div class="info-item-2">Android逆向1-smali</div></div><div class="info-2"><div class="info-item-1">Android逆向1-smali来自吾爱破解-正己 https://www.52pojie.cn/thread-1701353-1-1.html 1. JVM、Dalvik、ART JVM是JAVA虚拟机，运行JAVA字节码程序 Dalvik是Google专门为Android设计的一个虚拟机，Dalvik有专属的文件执行格式dex(Dalvik executable) Art(Android Runtime)相当于Dalvik的升级版，本质与Dalvik无异  2. smali及其语法smali是Dalvik的寄存器语言，smali代码是dex反编译而来的。 关键字    名称 注释    .class 类名   .super 父类名，继承的上级类名名称   .source 源名   .field 变量   .method 方法名   .register 寄存器   .end...</div></div></div></a><a class="pagination-related" href="/3761fa33/" title="Android逆向11-Frida进阶"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-29</div><div class="info-item-2">Android逆向11-Frida进阶</div></div><div class="info-2"><div class="info-item-1">Android逆向11-Frida进阶来自吾爱破解-正己 https://www.52pojie.cn/thread-1701353-1-1.html Frida写数据12345678//一般写在app的私有目录里，不然会报错:failed to open file (Permission denied)(实际上就是权限不足)var file_path = &quot;/data/user/0/com.zj.wuaipojie/test.txt&quot;;var file_handle = new File(file_path, &quot;wb&quot;);if (file_handle &amp;&amp; file_handle != null) &#123;        file_handle.write(data); //写入数据        file_handle.flush(); //刷新        file_handle.close(); //关闭&#125;  Frida_inlineHook与读写汇编什么是inlinehook？ Inline...</div></div></div></a><a class="pagination-related" href="/c47c9f7e/" title="Android逆向10-Frida_Native"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-28</div><div class="info-item-2">Android逆向10-Frida_Native</div></div><div class="info-2"><div class="info-item-1">Android逆向10-Frida_Native来自吾爱破解-正己 https://www.52pojie.cn/thread-1701353-1-1.html Process、Module、MemoryProcess 对象代表当前被Hook的进程，能获取进程的信息，枚举模块，枚举范围等    API 含义    Process.id 返回附加目标进程的 PID   Process.isDebuggerAttached() 检测当前是否对目标程序已经附加   Process.enumerateModules() 枚举当前加载的模块，返回模块对象的数组   Process.enumerateThreads() 枚举当前所有的线程，返回包含 id, state, context 等属性的对象数组   Module 对象代表一个加载到进程的模块(例如，在 Windows 上的 DLL，或在 Linux&#x2F;Android 上的 .so...</div></div></div></a><a class="pagination-related" href="/3fc95872/" title="Android逆向12-RPC"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-30</div><div class="info-item-2">Android逆向12-RPC</div></div><div class="info-2"><div class="info-item-1">Android逆向12-RPC来自吾爱破解-正己 https://www.52pojie.cn/thread-1701353-1-1.html RPC（Remote Procedure Call Protocol） 是一种远程过程调用协议，允许程序在不同的计算机上请求服务，而无需了解底层网络技术。RPC的主要作用是使不同服务之间的方法调用像本地调用一样便捷 Hook_Libartlibart.so: 在 Android 5.0（Lollipop）及更高版本中，libart.so 是 Android 运行时（ART，Android Runtime）的核心组件，它取代了之前的 Dalvik 虚拟机。可以在 libart.so 里找到 JNI 相关的实现。 PS:在高于安卓10的系统里，so的路径是&#x2F;apex&#x2F;com.android.runtime&#x2F;lib64&#x2F;libart.so，低于10的则在system&#x2F;lib64&#x2F;libart.so    函数名称 参数 描述 返回值    RegisterNatives JNIEnv...</div></div></div></a><a class="pagination-related" href="/d81ca9c8/" title="Android逆向13-例题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-01</div><div class="info-item-2">Android逆向13-例题</div></div><div class="info-2"><div class="info-item-1">Android逆向13-例题初级112345方法1:var ClassName=Java.use(&quot;com.zj.wuaipojie2024_1.YSQDActivity&quot;); console.log(ClassName.extractDataFromFile(&quot;/data/user/0/com.zj.wuaipojie2024_1/files/ys.mp4&quot;));方法2:android intent launch_activity com.zj.wuaipojie2024_1.YSQDActivity  初级2123456789101112131415161718方法1:android intent launch_activity com.kbtx.redpack_simple.FlagActivity方法2:function hookTest1()&#123;    var Arrays = Java.use(&quot;java.util.Arrays&quot;);   ...</div></div></div></a><a class="pagination-related" href="/ac0392ad/" title="Android逆向16-Flutter"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/v2-dbadb26e707dabf6723061583f9967b4_720w.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-08</div><div class="info-item-2">Android逆向16-Flutter</div></div><div class="info-2"><div class="info-item-1">Android逆向16-FlutterFlutter是Google构建在开源的Dart VM之上，使用Dart语言开发的移动应用开发框架，可以帮助开发者使用一套Dart代码就能快速在移动iOS 、Android上构建高质量的原生用户界面，同时还支持开发Web和桌面应用。 Flutter引擎是一个用于高质量跨平台应用的可移植运行时，由C/C++编写。它实现了Flutter的核心库，包括动画和图形、文件和网络I&#x2F;O、辅助功能支持、插件架构，以及用于开发、编译和运行Flutter应用程序的Dart运行时和工具链。引擎将底层C++代码包装成 Dart代码，通过dart:ui暴露给 Flutter框架层。 flutter开源地址 flutter官网 原创]Flutter概述和逆向技术发展时间线，带你快速了解 在逆向分析前，我们首先要确定测试目标是否用Flutter开发的。当使用Flutter构建Android...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Matriy</div><div class="author-info-description">不积硅步，无以至千里</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">206</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Matriy330"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">正在学习安卓逆向 (*^_^*)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Android%E9%80%86%E5%90%9118-Unicorn"><span class="toc-text">Android逆向18-Unicorn</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/76ff2a77/" title="羊城杯 2023 re 复现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/a847d2e8-3959-45ff-ae49-6c6c928bf1f7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="羊城杯 2023 re 复现"/></a><div class="content"><a class="title" href="/76ff2a77/" title="羊城杯 2023 re 复现">羊城杯 2023 re 复现</a><time datetime="2025-08-30T16:00:00.000Z" title="发表于 2025-08-31 00:00:00">2025-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/c656cf32/" title="L3HCTF 2024 [复现]"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/1086a721-7532-40ea-8229-785a9efa1da6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="L3HCTF 2024 [复现]"/></a><div class="content"><a class="title" href="/c656cf32/" title="L3HCTF 2024 [复现]">L3HCTF 2024 [复现]</a><time datetime="2025-08-28T16:00:00.000Z" title="发表于 2025-08-29 00:00:00">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/b22496bd/" title="L3HCTF 2025 wp"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/wps.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="L3HCTF 2025 wp"/></a><div class="content"><a class="title" href="/b22496bd/" title="L3HCTF 2025 wp">L3HCTF 2025 wp</a><time datetime="2025-08-20T16:00:00.000Z" title="发表于 2025-08-21 00:00:00">2025-08-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/de9c80c5/" title="DubheCTF 2024 re 复现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/a847d2e8-3959-45ff-ae49-6c6c928bf1f7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DubheCTF 2024 re 复现"/></a><div class="content"><a class="title" href="/de9c80c5/" title="DubheCTF 2024 re 复现">DubheCTF 2024 re 复现</a><time datetime="2025-07-28T16:00:00.000Z" title="发表于 2025-07-29 00:00:00">2025-07-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f1dd543a/" title="DASCTF 2025上半年赛-re"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DASCTF 2025上半年赛-re"/></a><div class="content"><a class="title" href="/f1dd543a/" title="DASCTF 2025上半年赛-re">DASCTF 2025上半年赛-re</a><time datetime="2025-07-01T16:00:00.000Z" title="发表于 2025-07-02 00:00:00">2025-07-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Matriy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank" href="https://hexo.io/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px"target="_blank" href="https://www.jsdelivr.com/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px"target="_blank" href="https://github.com/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p> <p>Hi, welcome to Matriy's <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.open-ctf.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo.open-ctf.top/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script async data-pjax src="/js/anzhiyu.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href="/music/"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>