<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>游戏逆向初探 | Matriy's blog</title><meta name="author" content="Matriy"><meta name="copyright" content="Matriy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="游戏逆向初探参考视频：线上培训 -先知社区 Unity3DUnity将来时：IL2CPP是什么？ - 知乎 Unity3D 是一个由 Unity Technologies 开发的 跨平台游戏引擎，主要用于制作 2D 和 3D 游戏、交互式模拟、虚拟现实（VR）、增强现实（AR）以及其他实时三维内容。 Unity3D 是一个 游戏引擎（Game Engine），简单来说，它是一个“做游戏的软件框架”">
<meta property="og:type" content="article">
<meta property="og:title" content="游戏逆向初探">
<meta property="og:url" content="http://matriy330.github.io/65f6ce99/index.html">
<meta property="og:site_name" content="Matriy&#39;s blog">
<meta property="og:description" content="游戏逆向初探参考视频：线上培训 -先知社区 Unity3DUnity将来时：IL2CPP是什么？ - 知乎 Unity3D 是一个由 Unity Technologies 开发的 跨平台游戏引擎，主要用于制作 2D 和 3D 游戏、交互式模拟、虚拟现实（VR）、增强现实（AR）以及其他实时三维内容。 Unity3D 是一个 游戏引擎（Game Engine），简单来说，它是一个“做游戏的软件框架”">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://matriy330.github.io/img/tx.jpg">
<meta property="article:published_time" content="2025-10-05T16:00:00.000Z">
<meta property="article:modified_time" content="2025-10-07T14:30:35.981Z">
<meta property="article:author" content="Matriy">
<meta property="article:tag" content="Re">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://matriy330.github.io/img/tx.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "游戏逆向初探",
  "url": "http://matriy330.github.io/65f6ce99/",
  "image": "http://matriy330.github.io/img/tx.jpg",
  "datePublished": "2025-10-05T16:00:00.000Z",
  "dateModified": "2025-10-07T14:30:35.981Z",
  "author": [
    {
      "@type": "Person",
      "name": "Matriy",
      "url": "http://matriy330.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/bitbug_favicon.ico"><link rel="canonical" href="http://matriy330.github.io/65f6ce99/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="G-ShTqjjywiLkL87Rg0PaiSsDVYymWStdQUO1wrM_VY"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: Matriy","link":"链接: ","source":"来源: Matriy's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}
</script><link rel="stylesheet" href="/css/custom.css"><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '游戏逆向初探',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/music.css"><link rel="stylesheet" href="/css/comment.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/img/bg.jpeg);"></div><div id="an_music_bg" style="background-image: url(/img/bg.jpeg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">224</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent;"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Matriy's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">游戏逆向初探</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">游戏逆向初探</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-05T16:00:00.000Z" title="发表于 2025-10-06 00:00:00">2025-10-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-07T14:30:35.981Z" title="更新于 2025-10-07 22:30:35">2025-10-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Re/">Re</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/65f6ce99/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="游戏逆向初探"><a href="#游戏逆向初探" class="headerlink" title="游戏逆向初探"></a>游戏逆向初探</h1><p>参考视频：<a target="_blank" rel="noopener" href="https://xz.aliyun.com/course-view?id=36">线上培训 -先知社区</a></p>
<h2 id="Unity3D"><a href="#Unity3D" class="headerlink" title="Unity3D"></a>Unity3D</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/19972689">Unity将来时：IL2CPP是什么？ - 知乎</a></p>
<p><strong>Unity3D</strong> 是一个由 <strong>Unity Technologies</strong> 开发的 <strong>跨平台游戏引擎</strong>，主要用于制作 <strong>2D 和 3D 游戏、交互式模拟、虚拟现实（VR）、增强现实（AR）以及其他实时三维内容</strong>。</p>
<p>Unity3D 是一个 <strong>游戏引擎（Game Engine）</strong>，简单来说，它是一个“做游戏的软件框架”。</p>
<p>使用 <strong>C#</strong> 编写逻辑控制（如人物移动、AI、UI响应等）。</p>
<p>Unity3D 中的 <strong>Mono</strong> 和 <strong>IL2CPP</strong> 是两种不同的<strong>脚本后端</strong>，它们负责将 C# 代码编译并运行在目标平台上。它们的主要区别在于编译方式、性能、兼容性、安全性等方面：</p>
<p><strong>平台支持与兼容性：</strong></p>
<ul>
<li><strong>Mono:</strong> 支持广泛的平台，但在一些<strong>特定平台或架构上受限</strong>：<ul>
<li><strong>iOS:<strong>不再被允许</strong>。Apple 禁止在 iOS 上使用 JIT 编译（安全原因）。因此 iOS 发布</strong>必须使用 IL2CPP。</li>
<li><strong>WebGL:</strong> 由于浏览器沙箱限制，无法进行 JIT 编译，因此 <strong>WebGL 必须使用 IL2CPP</strong>。</li>
<li><strong>某些主机&#x2F;嵌入式平台：</strong> 可能不支持 Mono 或其 JIT。</li>
</ul>
</li>
<li><strong>IL2CPP:<strong>平台支持更广泛且是未来的方向</strong>。它是支持 iOS、WebGL、Universal Windows Platform (UWP) 和一些主机平台的</strong>唯一选择。几乎支持所有 Unity 目标平台。(<strong>iOS 和 WebGL： 强制使用 IL2CPP。</strong>)</li>
</ul>
<p><strong>安全性：</strong></p>
<ul>
<li><strong>Mono:</strong> 托管字节码 (.dll) <strong>相对容易被反编译</strong>（使用工具如 ILSpy, dnSpy），代码逻辑和资源路径容易暴露。</li>
<li>**IL2CPP:**安全性大大提高。将 C# 代码转换为 C++ 代码，再编译成机器码，使得反编译回原始 C# 逻辑变得极其困难（虽然反汇编原生代码是可能的，但理解成本极高）。是保护游戏逻辑和知识产权的更好选择。</li>
</ul>
<p><strong>如果 Unity 项目没有使用 IL2CPP</strong>（而是使用 Mono 作为脚本后端），那么 <strong>主要的游戏逻辑代码</strong> 都在 <code>Assembly-CSharp.dll</code> 中</p>
<p>例如<a href="https://matriy330.github.io/63d050a6/">TSCTF-J 2024 | Matriy’s blog</a>的iPlayPingpang</p>
<p>对于一般的文件结构，都会有一个后缀为_Data的文件夹，并且里面有一个名为Managed的文件夹，而那个文件夹里的Assembly-CSharp.dll文件正是我们需要的东西，里面包含了作者的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/Managed/</span><br><span class="line">├── Assembly-CSharp.dll      ← 游戏脚本主逻辑</span><br><span class="line">├── Assembly-CSharp-firstpass.dll  ← 插件或早期编译的脚本</span><br><span class="line">├── UnityEngine.CoreModule.dll     ← Unity 官方 API</span><br><span class="line">├── mscorlib.dll             ← .NET 基础类库</span><br><span class="line">└── System.dll / System.Core.dll   ← .NET 组件</span><br></pre></td></tr></table></figure>

<p>再介绍IL2CPP前，先介绍下IL</p>
<p><strong>IL</strong> 的全称是 <strong>Intermediate Language（中间语言）</strong>它是 <strong>C# 编译后的中间形式</strong>，不是机器码，也不是源代码。</p>
<p>如一个C#代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Hello</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 C# 编译器（<code>csc.exe</code>）编译后，会生成一个 <code>Hello.exe</code> 或 <code>.dll</code>。但这个文件内部并不是 CPU 能直接运行的机器码，而是 IL 指令，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IL_0000: ldstr &quot;Hello, World!&quot;</span><br><span class="line">IL_0005: call void [System.Console]System.Console::WriteLine(string)</span><br><span class="line">IL_000a: ret</span><br></pre></td></tr></table></figure>

<p>这就是 IL：一种介于高级语言（C#）和底层机器码之间的中间层语言。</p>
<p>让程序与 CPU 架构无关（跨平台）可以被 <strong>CLR（Common Language Runtime）</strong> 或 <strong>Mono Runtime</strong> 即时编译（JIT）成机器码提供了更强的反编译可能性（这也是为什么 <code>.NET</code> 程序容易被反编译）</p>
<p>类似一个面向对象的汇编语言，并且它是完全基于堆栈的，它运行在虚拟机上（.Net Framework, Mono VM）的语言。</p>
<p>具体过程是：C#或者VB这样遵循CLI规范的高级语言，被先被各自的编译器编译成中间语言：IL（CIL），等到需要真正执行的时候，这些IL会被加载到运行时库，也就是VM中，由VM动态的编译成汇编代码（JIT）然后在执行。</p>
<p>本质上说，到了IL这一层级，它是由哪门高级语言创建的也不是那么重要了，你可以用C#，VB，Boo，Unity Script甚至C++，只要有相应的编译器能够将其编译成IL都行</p>
<p><strong>Mono 虚拟机</strong> 是一个用来执行 C#（IL）代码的跨平台运行时，类似于 Java 的 JVM。一般电脑不会自带，但 Unity 游戏会自动打包它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C# 源码</span><br><span class="line">  ↓</span><br><span class="line">C# 编译器 (Roslyn)</span><br><span class="line">  ↓</span><br><span class="line">生成 IL (中间语言)</span><br><span class="line">  ↓</span><br><span class="line">Mono 虚拟机（Mono Runtime）</span><br><span class="line">  ↓</span><br><span class="line">在运行时将 IL 即时编译成机器码（JIT）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JIT（即时编译）在运行时转换 IL → 机器码，有额外开销</p>
</blockquote>
<p><strong>IL2CPP</strong> 是 Unity 自己设计的一个编译后端，全称是 **Intermediate Language To C++**。它的作用就是把 <strong>IL（中间语言）转换成 C++ 代码</strong>，然后再编译成原生机器码。</p>
<p>简言之，就是把IL中间语言转换成CPP文件。大家如果看明白了上面动态语言的 CLI， IL以及VM，再看到IL2CPP一定心中充满了疑惑。现在的大趋势都是把语言加上动态特性，哪怕是c++这样的静态语言，也出现了适合IL的c++编译 器，为啥Unity要反其道而行之，把IL再弄回静态的CPP呢？</p>
<ol>
<li><p>Mono VM在各个平台移植，维护非常耗时，有时甚至不可能完成</p>
<p>Mono的跨平台是通过Mono VM实现的，有几个平台，就要实现几个VM，像Unity这样支持多平台的引擎，Mono官方的VM肯定是不能满足需求的。所以针对不同的新平 台，Unity的项目组就要把VM给移植一遍，同时解决VM里面发现的bug。这非常耗时耗力。这些能移植的平台还好说，还有比如WebGL这样基于浏览 器的平台。要让WebGL支持Mono的VM几乎是不可能的。</p>
</li>
<li><p>Mono版本授权受限</p>
<p>很多C#的新特性无法使用。这是因为Mono 授权受限，导致Unity无法升级Mono。如果换做是IL2CPP，IL2CPP VM这套完全自己开发的组件，就解决了这个问题。</p>
</li>
<li><p>提高运行效率：根据官方的实验数据，换成IL2CPP以后，程序的运行效率有了1.5-2.0倍的提升。</p>
</li>
</ol>
<p>既然 IL 是跨平台的，那为什么 Unity 还要舍弃它、转成 C++？这样不是反而变得更‘依赖平台’了吗？</p>
<p>Unity 引入 IL2CPP 的目的，其实不是“跨平台”，而是解决 <strong>性能</strong> 和 <strong>安全性</strong> 问题。</p>
<p>IL → C++：是“提前编译”（AOT），不是“放弃跨平台”</p>
<p>IL2CPP 并不是放弃跨平台，而是把“编译成机器码”的工作提前做好</p>
<blockquote>
<p>Unity 仍然“跨平台”，但跨平台的<strong>责任从运行时转移到了编译阶段</strong>。</p>
</blockquote>
<p>原来：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20251005162206178.png" alt="image-20251005162206178"></p>
<p>IL2CPP</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20251005162235376.png" alt="image-20251005162235376"></p>
<blockquote>
<p>PS：其实就是IL2CPP牺牲了Mono跨平台的优势来保证安全，快速</p>
</blockquote>
<p>C#的产出必须为IL，这个是绕不开的(C# 是个很复杂的语言（泛型、委托、LINQ、async、反射、属性、接口、多继承模型、GC……），如果C#要到C++差不多是重新设计一个语言，不如利用IL来做一下适配)</p>
<p>对比 Mono 模式（早期 Unity）</p>
<p>在 <strong>Mono 模式</strong> 下：</p>
<ul>
<li>游戏包里包含 <code>Assembly-CSharp.dll</code>（IL 字节码）。</li>
<li>游戏运行时自带 <strong>Mono 虚拟机</strong>。</li>
<li>Mono 会在运行时 <strong>即时编译（JIT）</strong> IL → 机器码。</li>
</ul>
<blockquote>
<p>也就是在你运行的时候Mono会翻译成机器码执行</p>
</blockquote>
<p>而IL2CPP不一样，它是开发者直接转化除了CPP然后编译好给你，针对不同平台如ubuntu,ios都给一个，相当于牺牲了部分跨平台的优势</p>
<p>旧 Unity（Mono） &#x3D; “运行时编译 IL”；</p>
<p>新 Unity（IL2CPP） &#x3D; “提前编译 IL”。</p>
<p>Mono 模式：</p>
<p>游戏包里包含：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/Managed/</span><br><span class="line"> ├─ Assembly-CSharp.dll   ← 脚本IL</span><br><span class="line"> ├─ mscorlib.dll</span><br><span class="line"> └─ UnityEngine.CoreModule.dll</span><br><span class="line">/Mono/</span><br><span class="line"> ├─ mono.dll              ← 虚拟机执行IL</span><br></pre></td></tr></table></figure>

<p>IL2CPP 模式：</p>
<p>游戏包里包含：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/libil2cpp.so             ← 已经编译好的C++机器码</span><br><span class="line">/global-metadata.dat      ← 元数据表</span><br></pre></td></tr></table></figure>

<blockquote>
<p>global-metadata.dat元数据表（类、方法、字符串等）</p>
</blockquote>
<p>如SUSCTF2025的一道题为例：xxx</p>
<p><strong>一般dll类型的unity游戏逆向，唯一核心就是逆向&#x2F;修改某个 dll 文件就可以了。而一般IL2CPP的Unity3D游戏的逆向，大多只需要根据global-metadata.dat和libil2cpp.so来进行就可以了。目标异常明确，这也是 Unity3D 和 其它安卓逆向不同的地方。</strong></p>
<p><a target="_blank" rel="noopener" href="https://mdr.skyeye.qianxin.com/forum/share/1294">奇安信攻防社区-浅谈CTF中的unity游戏逆向</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20251005164925430.png" alt="image-20251005164925430"></p>
<p>IL2CPP的一些工具</p>
<p>恢复globalmetadata.dat里的方法，可以导入到libil2cpp.so<a target="_blank" rel="noopener" href="https://github.com/Perfare/Il2CppDumper">Perfare&#x2F;Il2CppDumper: Unity il2cpp reverse engineer</a></p>
<p>恢复一个dump.cs：需要有root机<a target="_blank" rel="noopener" href="https://github.com/Perfare/Zygisk-Il2CppDumper">Perfare&#x2F;Zygisk-Il2CppDumper: Using Zygisk to dump il2cpp data at runtime</a></p>
<p>global-metadata主要内容</p>
<p>Il2CppGlobalMetadataHeader:文件头部，包含数据偏移等信息。</p>
<p>Il2CppClassDefinition:所有类的信息。</p>
<p>Il2CppMethodDefinition:所有方法的信息(方法索引、类索引、返回值等)。</p>
<p>Il2CppFieldDefinition:所有字段信息(名称、偏移等)Il2CppStringLiteral:字符串字面量表。</p>
<p>关键数据:</p>
<p>methodPointers[]数组</p>
<p>metadataUsages[]数组</p>
<p>global-metadata中metadataUsagePairs存储了metadataUsages[]的索引和类型信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────────┐</span><br><span class="line">│ MetadataHeader         │← 文件头：记录各段偏移与长度</span><br><span class="line">├────────────────────────┤</span><br><span class="line">│ Metadata Tables         │← 核心：各种定义表（Type/Method/Field等）</span><br><span class="line">├────────────────────────┤</span><br><span class="line">│ String Literal Section  │← 字符串字面量常量区（如类名、方法名）</span><br><span class="line">└────────────────────────┘</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct MetadataHeader &#123;</span><br><span class="line">    int signature;                // 魔数标识 (0xFAB11BAF)</span><br><span class="line">    int version;                  // 版本号（24~29等）</span><br><span class="line">    int stringLiteralOffset;</span><br><span class="line">    int stringLiteralCount;</span><br><span class="line">    int stringLiteralDataOffset;</span><br><span class="line">    int stringLiteralDataCount;</span><br><span class="line">    int stringOffset;</span><br><span class="line">    int stringCount;</span><br><span class="line">    int eventsOffset;</span><br><span class="line">    int eventsCount;</span><br><span class="line">    int propertiesOffset;</span><br><span class="line">    int propertiesCount;</span><br><span class="line">    int methodsOffset;</span><br><span class="line">    int methodsCount;</span><br><span class="line">    int parameterDefaultValuesOffset;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Unity一个比较显著的特点就是一切都由Manager实例进行管理。实际利用的时候，往往是找到对应类的get instance函数，直接获取该类实例的地址，然后调用其对应的成员函数，来获取实体列表等</p>
<p>在 Unity 引擎底层（尤其是 C++ 引擎代码中），所有子系统（场景、物理、渲染、音频、输入、资源等）都由各自的 <strong>Manager 类（管理器）</strong> 统一管理。</p>
<p>比如：</p>
<table>
<thead>
<tr>
<th>Manager 名称</th>
<th>管理的内容</th>
</tr>
</thead>
<tbody><tr>
<td><code>GameObjectManager</code></td>
<td>所有场景中的游戏对象（GameObject）</td>
</tr>
<tr>
<td><code>ComponentManager</code></td>
<td>所有组件（Component）</td>
</tr>
<tr>
<td><code>SceneManager</code></td>
<td>场景加载与切换</td>
</tr>
<tr>
<td><code>PhysicsManager</code></td>
<td>物理系统（刚体、碰撞体）</td>
</tr>
<tr>
<td><code>AudioManager</code></td>
<td>声音与音效</td>
</tr>
<tr>
<td><code>InputManager</code></td>
<td>键鼠&#x2F;手柄输入</td>
</tr>
<tr>
<td><code>ResourceManager</code></td>
<td>资源加载与卸载</td>
</tr>
<tr>
<td><code>PlayerLoopManager</code></td>
<td>主循环（每帧更新逻辑）</td>
</tr>
</tbody></table>
<p>这些类通常都被设计成 <strong>单例（Singleton）</strong>，<br> 也就是说：</p>
<blockquote>
<p>在游戏运行过程中，全局只存在一个实例。</p>
</blockquote>
<p>在单例模式中，一个类通常提供一个静态的访问方法，比如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GameObjectManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> GameObjectManager* GetInstance(); <span class="comment">// 获取唯一实例</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UpdateAllObjects</span>()</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当你在逆向分析 Unity 游戏时（尤其是 IL2CPP 或 Native 段），很多有用的数据都藏在这些 <strong>Manager 实例</strong> 里。</p>
<p>比如：</p>
<ul>
<li>所有当前场景的玩家对象（GameObject）</li>
<li>想枚举所有正在播放的音效</li>
<li>读取当前摄像机的参数</li>
</ul>
<p>这些数据都不是独立散落的，而是存储在某个 Manager 结构中。所以逆向时的流程通常是：</p>
<ol>
<li>找到 <code>XXXManager::GetInstance()</code> 的函数地址（单例获取器）</li>
<li>调用它，拿到全局 Manager 的内存地址</li>
<li>从该对象的成员变量中，访问各种列表、容器、实体对象</li>
</ol>
<p><strong>举个例子（伪代码）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1. 获取 GameObjectManager 的实例</span><br><span class="line">GameObjectManager* mgr = GameObjectManager::GetInstance();</span><br><span class="line"></span><br><span class="line">// 2. 调用成员函数或直接访问成员变量</span><br><span class="line">std::vector&lt;GameObject*&gt; allObjects = mgr-&gt;GetActiveObjects();</span><br><span class="line">for (auto obj : allObjects) &#123;</span><br><span class="line">    printf(&quot;Name = %s\n&quot;, obj-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在逆向时：</p>
<ul>
<li>你在 IDA 里定位 <code>GameObjectManager::GetInstance</code>；</li>
<li>Hook 或调用它；</li>
<li>从返回的地址（即单例实例）偏移出列表字段；</li>
<li>遍历得到所有对象指针。</li>
</ul>
<p>U3D的防御一般是global-metadata.dat的加密,函数名混淆等</p>
<h2 id="UE引擎"><a href="#UE引擎" class="headerlink" title="UE引擎"></a>UE引擎</h2><h3 id="UE简介"><a href="#UE简介" class="headerlink" title="UE简介"></a>UE简介</h3><p>UE 采用对象(UObject)管理系统，所有的UE反射系统管理的类都是UOject的继承，并由 UE的全局对象数组(GObjects)和名称表(GNames)进行管理。UE的反射系统存储了类、对象、变量、函数等信息，主要与GObjects和 GNames这两个全局数据结构有关。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20251005172923941.png" alt="image-20251005172923941"></p>
<blockquote>
<p>这让引擎能：</p>
<ul>
<li>在编辑器中自动显示属性；</li>
<li>支持序列化；</li>
<li>与蓝图交互；</li>
<li>实现运行时元信息访问。</li>
</ul>
</blockquote>
<p>UE 的底层是 <strong>纯 C++ 实现</strong> 的。游戏逻辑可以通过两种方式编写：</p>
<table>
<thead>
<tr>
<th>层</th>
<th>技术</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>高层</td>
<td>Blueprint 蓝图</td>
<td>可视化逻辑、易上手</td>
</tr>
<tr>
<td>底层</td>
<td>C++</td>
<td>性能高、可自定义引擎逻辑</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>比较项</th>
<th><strong>Unity3D</strong></th>
<th><strong>Unreal Engine 4</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>开发语言</strong></td>
<td>C#（托管语言，基于 Mono&#x2F;IL2CPP）</td>
<td>C++（原生代码） + Blueprint</td>
</tr>
<tr>
<td><strong>源码开放</strong></td>
<td>❌ 部分封闭（引擎不开源）</td>
<td>✅ 全部开源，可修改底层</td>
</tr>
<tr>
<td><strong>脚本层机制</strong></td>
<td>Mono 虚拟机 &#x2F; IL2CPP</td>
<td>反射系统（UObject）</td>
</tr>
<tr>
<td><strong>渲染能力</strong></td>
<td>中等偏上，适合中小型项目</td>
<td>顶级水准（AAA 级实时光照、PBR、Lumen）</td>
</tr>
<tr>
<td><strong>性能优化</strong></td>
<td>依赖 IL2CPP 与引擎优化</td>
<td>原生 C++，性能极高</td>
</tr>
<tr>
<td><strong>学习曲线</strong></td>
<td>简单（C# + 可视化 Editor）</td>
<td>较难（C++ + 架构复杂）</td>
</tr>
<tr>
<td><strong>典型用途</strong></td>
<td>独立游戏、移动游戏、教育、AR&#x2F;VR</td>
<td>3A 游戏、影视、仿真、虚拟制作</td>
</tr>
<tr>
<td><strong>代表作品</strong></td>
<td>《原神》《饥荒》《空洞骑士》</td>
<td>《堡垒之夜》《PUBG》《黑神话：悟空》《古墓丽影》</td>
</tr>
<tr>
<td><strong>资源生态</strong></td>
<td>Unity Asset Store</td>
<td>Unreal Marketplace</td>
</tr>
<tr>
<td><strong>平台适配</strong></td>
<td>非常广（移动端、WebGL）</td>
<td>偏向高性能设备（PC、主机）</td>
</tr>
</tbody></table>
<h3 id="Uworld"><a href="#Uworld" class="headerlink" title="Uworld"></a>Uworld</h3><p>管理关卡(Levels):1个 Uworld 包含多个ULevel，包括持久化关卡(PersistentLevel)和子关卡(Sub-Levels)。</p>
<p>管理所有的 Actor:AActor 是 游戏中的所有动态和静态对象 的基础:玩家、NPC、静态物体等等。拿到AActors列表也就拿到了当前游戏内的所有实体。其中AActor子类APawn是可由玩家或 AI控制的对象，通常就是需要拿到的玩家。</p>
<p>如下图，对于外挂而言，可以从UWord可以拿到所需要的几乎一切数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20251005173729067.png" alt="image-20251005173729067"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UWorld</span><br><span class="line"> ├── PersistentLevel              ← 当前持久关卡</span><br><span class="line"> │    ├── AActor (角色、物体)</span><br><span class="line"> │    │    └── UComponent（组件，如Mesh, Collider, etc.）</span><br><span class="line"> │    ├── PlayerController / Pawn / Camera</span><br><span class="line"> │    └── Light, Sky, Landscape...</span><br><span class="line"> ├── StreamingLevels[]            ← 流式加载的子关卡</span><br><span class="line"> ├── GameState / GameMode</span><br><span class="line"> ├── NavigationSystem             ← AI导航网格</span><br><span class="line"> ├── PhysicsScene / Scene         ← 物理世界</span><br><span class="line"> └── LevelScriptActor             ← 关卡逻辑脚本</span><br></pre></td></tr></table></figure>

<p>引擎大致会经历以下过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UWorld* World = NewObject&lt;UWorld&gt;();</span><br><span class="line">World-&gt;InitializeNewWorld();</span><br><span class="line">World-&gt;LoadPersistentLevel(MapName);</span><br><span class="line">World-&gt;BeginPlay();</span><br></pre></td></tr></table></figure>

<p><strong>蓝图（Blueprint）是 Unreal Engine 的可视化脚本系统（Visual Scripting System）。</strong>它允许你不用写 C++ 代码，就能用 <strong>拖拽节点</strong> 的方式来编写逻辑、控制游戏行为、操作对象。</p>
<p>可以把它理解为： 用图形化方式表示代码逻辑的脚本语言。</p>
<h3 id="UFunction"><a href="#UFunction" class="headerlink" title="UFunction"></a>UFunction</h3><p><code>UFunction</code> 是 Unreal 引擎中用来描述 C++ 函数元信息（metadata）的类。</p>
<p>它不是一个“函数本身”， 而是一个<strong>用于记录函数信息的对象</strong>——例如函数名、参数类型、返回值、访问标志、蓝图可见性、所属类等等。</p>
<p>它继承自 UE 的反射基类 <code>UField</code> → <code>UStruct</code> → <code>UFunction</code>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">UFunction</span> : <span class="title">public</span> <span class="title">UStruct</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    uint32 FunctionFlags;       <span class="comment">// 函数修饰符</span></span><br><span class="line">    uint8  NumParms;            <span class="comment">// 参数数量</span></span><br><span class="line">    uint16 ParmsSize;           <span class="comment">// 参数总字节数</span></span><br><span class="line">    uint16 ReturnValueOffset;   <span class="comment">// 返回值偏移</span></span><br><span class="line">    EFunctionFlags Flags;       <span class="comment">// 执行标志（Native, BlueprintCallable 等）</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>UE 的反射系统由三大支柱组成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UClass     → 描述类</span><br><span class="line">UProperty  → 描述类中的变量</span><br><span class="line">UFunction  → 描述类中的函数</span><br></pre></td></tr></table></figure>

<p>因此，<code>UFunction</code> 的作用可以概括为三点：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>反射调用</strong></td>
<td>允许在运行时通过函数名调用函数，而不依赖编译时符号。</td>
</tr>
<tr>
<td><strong>蓝图绑定</strong></td>
<td>让蓝图能够调用或实现 C++ 函数。</td>
</tr>
<tr>
<td><strong>网络与事件支持</strong></td>
<td>用于标记函数为 RPC（客户端 &#x2F; 服务器调用）。</td>
</tr>
</tbody></table>
<p>假设写了一个 C++ 类：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UCLASS()</span><br><span class="line"><span class="keyword">class</span> <span class="title">AMyCharacter</span> : <span class="title">public</span> <span class="title">ACharacter</span></span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UFUNCTION(BlueprintCallable, Category=<span class="string">&quot;Player&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">JumpHigher</span>(<span class="params"><span class="built_in">float</span> Power</span>)</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在编译时，UE 的反射系统（通过 UnrealHeaderTool）会自动为这个类生成元信息：</p>
<ul>
<li>创建一个 <code>UFunction</code> 对象描述 <code>JumpHigher</code>；</li>
<li>记录函数名、参数类型、返回值类型；</li>
<li>注册到 <code>AMyCharacter</code> 的 <code>UClass</code> 里。</li>
</ul>
<p>于是：</p>
<p>蓝图就能在节点里看到 “JumpHigher”；编辑器能知道它有一个 <code>float Power</code> 参数； 引擎运行时可以用字符串名调用它（反射）。</p>
<p> <strong>编译阶段</strong></p>
<ul>
<li>UnrealHeaderTool 解析 <code>.h</code> 文件中 <code>UFUNCTION()</code> 宏；</li>
<li>为函数生成注册代码；</li>
<li>在运行时创建对应的 <code>UFunction</code> 对象并挂在所属 <code>UClass</code> 上。</li>
</ul>
<p> <strong>运行时阶段</strong></p>
<ul>
<li>引擎通过 <code>UObject::FindFunction(FName(&quot;JumpHigher&quot;))</code> 找到对应的 <code>UFunction</code>；</li>
<li>然后调用 <code>UObject::ProcessEvent(UFunction* Function, void* Params)</code> 执行；</li>
<li>反射系统自动处理参数传递、返回值、事件广播等。</li>
</ul>
<p>UFunction 的底层结构（内部成员）</p>
<p>在引擎源码中（<code>UObject/Class.h</code>），<code>UFunction</code> 继承自 <code>UStruct</code>，它保存了函数的完整签名信息：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> UFunction : <span class="keyword">public</span> UStruct</span><br><span class="line">&#123;</span><br><span class="line">    EFunctionFlags FunctionFlags;   <span class="comment">// 标志（是否可蓝图、是否原生、是否RPC）</span></span><br><span class="line">    uint8 NumParms;                 <span class="comment">// 参数数量</span></span><br><span class="line">    uint16 ParmsSize;               <span class="comment">// 参数区大小</span></span><br><span class="line">    uint16 ReturnValueOffset;       <span class="comment">// 返回值偏移</span></span><br><span class="line">    uint8 RepOffset;                <span class="comment">// 网络同步偏移</span></span><br><span class="line">    FNativeFuncPtr Func;            <span class="comment">// 指向原生C++函数的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>特别重要的是这一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FNativeFuncPtr Func;</span><br></pre></td></tr></table></figure>

<p>它指向真正的 C++ 函数实现。反射系统在 <code>ProcessEvent</code> 时会用这个指针去调用底层实现。</p>
<p>在 C++ 层可以直接使用 <code>UFunction</code> 来调用函数：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UObject* Obj = GetSomeUObject();</span><br><span class="line">UFunction* Func = Obj-&gt;FindFunction(TEXT(<span class="string">&quot;JumpHigher&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (Func)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> Power;</span><br><span class="line">    &#125; Params;</span><br><span class="line">    Params.Power = <span class="number">100.0f</span>;</span><br><span class="line">    Obj-&gt;ProcessEvent(Func, &amp;Params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就实现了“用字符串名调用函数”的效果（类似于 C# 的反射调用）</p>
<h3 id="ProcessEvent"><a href="#ProcessEvent" class="headerlink" title="ProcessEvent"></a>ProcessEvent</h3><p>在源码中（<code>UObject/ScriptCore.cpp</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual void ProcessEvent(UFunction* Function, void* Parameters);</span><br></pre></td></tr></table></figure>

<p>给定一个函数描述（<code>UFunction</code>）和参数数据， <code>ProcessEvent</code> 就会执行这个函数，无论它是 C++ 实现、蓝图实现，还是网络 RPC。</p>
<blockquote>
<p> <code>ProcessEvent</code> &#x3D; “执行一个函数（UFunction）+ 自动处理参数传递 + 调度蓝图或原生逻辑”。</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UObject::ProcessEvent(UFunction* Function, <span class="keyword">void</span>* Parameters)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理网络RPC（Server/Client）</span></span><br><span class="line">    <span class="keyword">if</span> (Function-&gt;FunctionFlags &amp; FUNC_Net)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可能是远程调用，走网络同步流程</span></span><br><span class="line">        CallRemoteFunction(Function, Parameters);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用C++原生函数（如果有实现）</span></span><br><span class="line">    <span class="keyword">if</span> (Function-&gt;Func)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用真实C++函数指针</span></span><br><span class="line">        Function-&gt;Func(<span class="keyword">this</span>, Parameters);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 蓝图函数（无原生实现） → 由脚本VM执行</span></span><br><span class="line">        CallScriptFunction(Function, Parameters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设写了一个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UFUNCTION(BlueprintCallable)</span><br><span class="line">void JumpHigher(float Power);</span><br></pre></td></tr></table></figure>

<p>当蓝图中调用它时，流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">蓝图节点点击 → 蓝图虚拟机 → ProcessEvent()</span><br><span class="line">    ↓</span><br><span class="line">找到 JumpHigher 对应的 UFunction</span><br><span class="line">    ↓</span><br><span class="line">准备参数区 (float Power)</span><br><span class="line">    ↓</span><br><span class="line">ProcessEvent(JumpHigher, &amp;Params)</span><br><span class="line">    ↓</span><br><span class="line">调用 UFunction::Func (指向 C++ 实现)</span><br></pre></td></tr></table></figure>

<p><strong>换句话说：</strong></p>
<blockquote>
<p>蓝图、反射、RPC，全都用同一个执行路径：<code>UObject::ProcessEvent</code>。</p>
</blockquote>
<p>也可以在 C++ 中手动使用 <code>ProcessEvent</code> 调用任意函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UObject* Obj = GetSomeActor();</span><br><span class="line">UFunction* Func = Obj-&gt;FindFunction(TEXT(&quot;JumpHigher&quot;));</span><br><span class="line">if (Func)</span><br><span class="line">&#123;</span><br><span class="line">    struct</span><br><span class="line">    &#123;</span><br><span class="line">        float Power;</span><br><span class="line">    &#125; Params;</span><br><span class="line"></span><br><span class="line">    Params.Power = 500.f;</span><br><span class="line"></span><br><span class="line">    Obj-&gt;ProcessEvent(Func, &amp;Params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就相当于运行时通过反射调用了 <code>JumpHigher()</code>。</p>
<p>类似 C# 的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.GetType().GetMethod(&quot;JumpHigher&quot;).Invoke(obj, new object[]&#123;500&#125;);</span><br></pre></td></tr></table></figure>

<p>在 IL2CPP 或 UE Native 分析时：</p>
<ul>
<li><code>ProcessEvent</code> 是最常被 Hook 的函数之一；</li>
<li>它几乎会被调用成千上万次；</li>
<li>Hook 它可以打印出所有正在执行的蓝图&#x2F;C++ 函数名称与参数；</li>
<li>在作弊、调试、自动化脚本中非常常用。</li>
</ul>
<p>例如（伪代码）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void (*original_ProcessEvent)(UObject*, UFunction*, void*);</span><br><span class="line"></span><br><span class="line">void hooked_ProcessEvent(UObject* Obj, UFunction* Func, void* Params)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;[CALL] %s::%s\n&quot;, *Obj-&gt;GetName(), *Func-&gt;GetName());</span><br><span class="line">    original_ProcessEvent(Obj, Func, Params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这能让你实时看到游戏中执行的每个函数调用，非常有价值。</p>
<blockquote>
<p>为什么要通过ProcessEvent的方式去调用比如Obj-&gt;ProcessEvent(Func, &amp;Params);，不能直接new个对象然后对象.方法调用吗，这么做的意义在哪?</p>
</blockquote>
<p>假设我们在纯 C++ 世界里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AMyCharacter* Obj = new AMyCharacter();</span><br><span class="line">Obj-&gt;JumpHigher(100.f);</span><br></pre></td></tr></table></figure>

<p>这当然没问题，也最直接。编译器知道 <code>AMyCharacter</code> 类里有 <code>JumpHigher()</code> 方法，它能直接生成汇编调用代码，性能最高。</p>
<p>那为什么 UE 要绕一圈用 <code>ProcessEvent()</code> 呢？</p>
<blockquote>
<p>因为 Unreal Engine 是一个“<strong>反射式运行时系统</strong>”，而不是普通的静态 C++ 程序。</p>
</blockquote>
<p>UE 的目标不仅是跑一段逻辑，而是要：</p>
<ul>
<li>让编辑器（Blueprint、Sequencer、AI、UI 等）<strong>动态识别和调用函数</strong>；</li>
<li>让引擎<strong>支持脚本层调用 C++ 层逻辑</strong>；</li>
<li>让游戏<strong>支持事件广播、网络RPC、热重载</strong>；</li>
<li>让<strong>蓝图 &#x2F; 网络 &#x2F; 编辑器</strong> 在<strong>不知道类型的情况下也能调用函数</strong>。</li>
</ul>
<p>而普通的 <code>Obj-&gt;JumpHigher()</code> 是<strong>编译期绑定（compile-time binding）</strong>，在运行时是<strong>无法通过字符串或元信息去找到它的</strong>。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>调用方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>静态绑定（C++ 调用）</strong></td>
<td><code>Obj-&gt;JumpHigher(100)</code></td>
<td>编译时确定函数地址；快但死板</td>
</tr>
<tr>
<td><strong>动态绑定（反射调用）</strong></td>
<td><code>Obj-&gt;ProcessEvent(Func, &amp;Params)</code></td>
<td>运行时查找函数并调用；灵活但慢</td>
</tr>
</tbody></table>
<p>UE 设计的是一个<strong>可反射、可扩展的运行时系统</strong>，它必须能在<strong>不知道类型的情况下执行任意函数</strong>。</p>
<p>想象你做一个蓝图节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Call Function by Name]</span><br></pre></td></tr></table></figure>

<p>用户在蓝图里输入字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;JumpHigher&quot;</span><br></pre></td></tr></table></figure>

<p>然后节点要去调用这个函数。</p>
<p>此时你只能这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UFunction* Func = Obj-&gt;FindFunction(TEXT(&quot;JumpHigher&quot;));</span><br><span class="line">if (Func)</span><br><span class="line">&#123;</span><br><span class="line">    struct &#123; float Power; &#125; Params = &#123; 100.0f &#125;;</span><br><span class="line">    Obj-&gt;ProcessEvent(Func, &amp;Params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为编译时你根本不知道会调用哪个函数，只能通过运行时的 <strong>字符串 → UFunction → ProcessEvent</strong> 动态调用。</p>
<p>virtual void ProcessEvent(UFunction* Function, void* Parameters);</p>
<p>有两个参数：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Function</strong></td>
<td><code>UFunction*</code></td>
<td>描述要调用的函数的元信息对象</td>
</tr>
<tr>
<td><strong>Parameters</strong></td>
<td><code>void*</code></td>
<td>指向参数数据结构的指针（通常是一个栈结构或用户定义的 struct）</td>
</tr>
</tbody></table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20251006221156275.png" alt="image-20251006221156275"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UObject::ProcessEvent(UFunction* Func, void* Params)</span><br><span class="line">   └─(检查RPC/调试钩子等)→ 若为原生(Native)</span><br><span class="line">       └─ UFunction::Invoke(...) / CallFunction(...)</span><br><span class="line">            └─ (*FuncPtr)(Obj, Stack, RESULT_PARAM)      ← 这里的 FuncPtr 是函数指针</span><br><span class="line">                 └─ *.gen.cpp 里由 UHT 生成的 Thunk(桩函数)</span><br><span class="line">                      └─ 真正的 C++ 实现(你写的函数 / _Implementation)</span><br></pre></td></tr></table></figure>

<ol>
<li>ProcessEvent：统一入口</li>
</ol>
<ul>
<li><code>UObject::ProcessEvent(UFunction* Function, void* Params)</code> 是统一调度口：做网络 RPC 判断、蓝图&#x2F;原生分流、调试钩子等。</li>
<li>判断是“原生函数”就走 <strong>Native 路径</strong>，否则走蓝图 VM。</li>
</ul>
<ol start="2">
<li>UFunction::Invoke &#x2F; CallFunction</li>
</ol>
<ul>
<li>不同版本命名略有差异，本质是<strong>根据 <code>UFunction</code> 的元信息调用其绑定的原生函数指针</strong>。</li>
<li>这里会把 <code>void* Params</code>&#x2F;<code>FFrame Stack</code> 这样的参数区准备好，随后调用函数指针。</li>
</ul>
<ol start="3">
<li><code>(*Func)(Obj, Stack, RESULT_PARAM)</code></li>
</ol>
<ul>
<li><p><code>Func</code> 是 <code>UFunction</code> 里保存的 <strong>原生函数指针</strong>（类型一般是 <code>FNativeFuncPtr</code>）。</p>
</li>
<li><p>调用签名常见为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using FNativeFuncPtr = void(*)(UObject* Context, FFrame&amp; Stack, RESULT_DECL);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Obj/Context</code>：调用对象</li>
<li><code>Stack</code>：参数解析用的执行栈（从里面按元信息取出各参数）</li>
<li><code>RESULT_PARAM</code>&#x2F;<code>RESULT_DECL</code>：返回值写回位置</li>
</ul>
</li>
</ul>
<ol start="4">
<li>*.gen.cpp 的 Thunk（桩函数）</li>
</ol>
<ul>
<li>这个函数指针 <strong>不是直接指向你写的 C++ 方法</strong>，而是指向 <strong>UHT 生成的“Thunk”</strong>（桩函数），文件名形如 <code>YourClass.gen.cpp</code>。</li>
<li>Thunk 的职责：<ul>
<li>用宏从 <code>FFrame</code> 里<strong>解码参数</strong>（<code>P_GET_PROPERTY</code> &#x2F; <code>P_GET_OBJECT</code> 等）</li>
<li><code>P_FINISH;</code> 检查参数读取完毕</li>
<li>调用<strong>真正实现</strong>：<ul>
<li>普通 <code>UFUNCTION</code>：<code>P_THIS-&gt;YourFunc(DecodedParams...)</code></li>
<li><code>BlueprintNativeEvent</code>：调用 <code>YourFunc_Implementation(...)</code></li>
</ul>
</li>
<li>如果有返回值，写入 <code>RESULT_PARAM</code></li>
</ul>
</li>
</ul>
<p>典型生成代码（示意）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 定义由 UHT 生成的原生桩</span><br><span class="line">DEFINE_FUNCTION(AMyCharacter::execJumpHigher)</span><br><span class="line">&#123;</span><br><span class="line">    P_GET_PROPERTY(FFloatProperty, Z_Param_Power);</span><br><span class="line">    P_FINISH;</span><br><span class="line">    P_THIS-&gt;JumpHigher(Z_Param_Power);       // 调到你写的 C++ 实现</span><br><span class="line">    // 如有返回值：*(ReturnType*)RESULT_PARAM = Ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>“真正的 C++ 函数”</li>
</ol>
<ul>
<li><p>就是你在类里写的那个实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UFUNCTION(BlueprintCallable)</span><br><span class="line">void JumpHigher(float Power) &#123; /* 你的逻辑 */ &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若是 <code>BlueprintNativeEvent</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UFUNCTION(BlueprintNativeEvent)</span><br><span class="line">void DoX(int A);</span><br><span class="line">void DoX_Implementation(int A) &#123; /* 真正实现 */ &#125;</span><br><span class="line">// Thunk 会调用 _Implementation</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="6">
<li>为什么需要 Thunk？</li>
</ol>
<ul>
<li><strong>编组&#x2F;解组（marshalling）</strong>：把反射&#x2F;蓝图世界里的“无类型参数块(FFrame)”转换成强类型的 C++ 形参。</li>
<li><strong>统一通道</strong>：同一套机制兼容蓝图、RPC、编辑器调用、反射调用。</li>
<li><strong>元信息驱动</strong>：根据 <code>UFunction</code> 的 <code>Property</code> 链表解参数&#x2F;写返回值。</li>
<li><strong>隔离生成代码</strong>：参数处理、错误检查、默认值、标志处理都放在自动生成的桩里，你的业务函数保持干净。</li>
</ul>
<blockquote>
<p>LineTraceSingleLineOfSightToStaticFindObject(光线类的效果，判断是否遮挡)<br>K2 DrawText，K2 DrawLine(引擎绘制)</p>
</blockquote>
<h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p>UE开发中，对引擎做改动是比较困难的，目前的游戏厂商常用的有以下的方式:</p>
<p><strong>指针加密</strong></p>
<blockquote>
<p>在运行时不直接存放真实指针，而是存放加密后的值；每次使用前先解密，用完再丢弃或重新加密。</p>
</blockquote>
<p>假设原本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UWorld* GWorld;</span><br></pre></td></tr></table></figure>

<p>被修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t GWorld_Encrypted;</span><br><span class="line"></span><br><span class="line">UWorld* GetGWorld()</span><br><span class="line">&#123;</span><br><span class="line">    return reinterpret_cast&lt;UWorld*&gt;(GWorld_Encrypted ^ 0x5A5A5A5A5A5A5A5A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在引擎访问全局对象时，都通过一个 <strong>解密函数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto World = GetGWorld();</span><br><span class="line">World-&gt;Tick(...);</span><br></pre></td></tr></table></figure>

<p><strong>修改引擎关键结构体</strong></p>
<p>官方 UE4（简化）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct FUObjectItem &#123;</span><br><span class="line">    UObject* Object;</span><br><span class="line">    int32 Flags;</span><br><span class="line">    int32 ClusterRootIndex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>被厂商修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct FUObjectItem_Protected &#123;</span><br><span class="line">    uint64 EncodedPtr;   // Object指针被编码</span><br><span class="line">    uint32 Flags;</span><br><span class="line">    uint32 Magic;        // 新增无用字段</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或直接改偏移：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 原始偏移 0x10 改为 0x18</span><br><span class="line">UObject* Object = *(UObject**)((uintptr_t)item + 0x18);</span><br></pre></td></tr></table></figure>

<p>调换变量的顺序也行</p>
<p>所有现成的 SDK &#x2F; Dumper 工具失效；</p>
<p><strong>混淆函数名</strong></p>
<p>UE 的反射系统和蓝图系统依赖字符串（如 <code>UFunction</code>、<code>UClass</code> 名）。</p>
<p>在 <code>global-metadata.dat</code> 或 <code>GNames</code> 中可以看到很多原始函数名，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function /Script/Game.Character.Jump</span><br><span class="line">Function /Script/Game.Player.FireWeapon</span><br></pre></td></tr></table></figure>

<p>这些字符串在反编译或 SDK Dump 时非常显眼。混淆函数名的思路是：</p>
<blockquote>
<p>在打包或编译阶段对所有函数、类、属性名进行哈希或替换，保证引擎运行时可识别，但肉眼无法理解。</p>
</blockquote>
<p>编译前：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UFUNCTION(BlueprintCallable)</span><br><span class="line">void FireWeapon();</span><br></pre></td></tr></table></figure>

<p>混淆处理后（自动脚本）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UFUNCTION(BlueprintCallable)</span><br><span class="line">void a5F4E1C8();</span><br></pre></td></tr></table></figure>

<p>或者动态加密：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RegisterFunction(DecryptString(&quot;0xA93F1221B&quot;));</span><br></pre></td></tr></table></figure>

<p>最终在反射表中看到的函数名就变成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function /Script/Game.a5F4E1C8</span><br></pre></td></tr></table></figure>

<p>更多可以看</p>
<p><a target="_blank" rel="noopener" href="https://www.xianlongok.site/post/6605f9f/#UFUCTION">UE4 反射系统 | 十三</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-282857.htm">[原创]UE4.27SDK-Dump-软件逆向-看雪论坛-安全社区|非营利性质技术交流社区</a></p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1456734-1-1.html">记录一次虚幻4(UE4)手游逆向 - 吾爱破解 - 52pojie.cn</a></p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1838396-1-1.html">逆向UE4最简单的一集 - 吾爱破解 - 52pojie.cn</a></p>
<p>这些博客</p>
<h2 id="外挂原理"><a href="#外挂原理" class="headerlink" title="外挂原理"></a>外挂原理</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20251006223212793.png" alt="image-20251006223212793"></p>
<p>外挂主要有两种方式，跨进程和注入式dll</p>
<p><strong>跨进程（External）</strong>：作弊程序驻外部进程，通过读取&#x2F;写入目标进程的内存、模拟输入、或监听渲染帧来实现功能；不把代码直接放入游戏进程。</p>
<p><strong>做法</strong></p>
<ul>
<li>外部进程使用系统API（例如 Windows 的 <code>ReadProcessMemory</code> &#x2F; <code>WriteProcessMemory</code>、<code>GetWindowRect</code>、<code>SendInput</code>、DirectX hook 外挂用的显存读取或重放）访问或影响目标。</li>
<li>通过画面采样、内存读取或图像识别（OCR&#x2F;模板匹配）来获得游戏状态。</li>
<li>模拟鼠标&#x2F;键盘输入或通过网络包修改（如果可能）来实现动作。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>不直接修改目标进程代码，风险较低（崩溃&#x2F;暴露面较小）。</li>
<li>实现门槛低（不用解决注入&#x2F;进程内同步复杂性）。</li>
<li>容易用普通权限运行（不需要内核权限）。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>能力受限：不能直接调用内部函数或拦截渲染管线（功能受限，信息采集可能不完整）。</li>
<li>性能和精确度可能低（例如帧间延迟、画面识别误判）。</li>
<li>某些反作弊对跨进程访问检测严格（如检测异常的 OpenProcess&#x2F;ReadProcessMemory 调用、异常句柄等）。</li>
</ul>
<p><strong>检测点（反作弊）</strong></p>
<ul>
<li>监控外部进程对游戏的 OpenProcess&#x2F;ReadProcessMemory&#x2F;WriteProcessMemory&#x2F;WriteFile&#x2F;SetWindowsHookEx 等调用或异常句柄&#x2F;命名对象。</li>
<li>检测鼠标&#x2F;键盘输入的可疑模式（硬件生成 vs 软件注入差异）。</li>
<li>检测画面采样&#x2F;帧缓冲读取或重复的屏幕抓取行为。</li>
</ul>
<p><strong>注入式 DLL（Injected）</strong>：把一段 DLL 或代码注入到游戏进程地址空间中，代码直接运行在游戏上下文里，能直接调用游戏内部函数 &#x2F; 操作内存 &#x2F; 截获渲染与输入。</p>
<p><strong>做法（高层）</strong></p>
<ul>
<li>将自定义 DLL 注入到游戏进程（通过 CreateRemoteThread+LoadLibrary、SetWindowsHookEx、APC、manual mapping 等方式），在进程内加载后直接 hook 函数、patch 内存、截获 DirectX&#x2F;OpenGL&#x2F;Vulkan 调用或直接修改游戏状态（内存&#x2F;对象指针）。</li>
<li>也可能用 inline hook、vtable hook、IAT hook、inline patch、函数 trampolines 等技术直接替换&#x2F;拦截函数。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>功能强大：可以直接操作游戏对象、调用内核函数、拦截渲染&#x2F;网络栈，精确度高、延迟低。</li>
<li>可以实现隐蔽的“内部”逻辑（例如修改游戏状态而不触发外部可见的访问）。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>风险更高：进程崩溃、符号暴露、注入行为容易被检测到（例如扫描已加载模块、异常页属性、线程注入痕迹）。</li>
<li>反作弊防护（内核防护、签名白名单、完整性校验）会重点拦截注入行为。</li>
<li>注入技术和绕过反作弊往往触及安全&#x2F;法律灰区。</li>
</ul>
<p><strong>检测点（反作弊）</strong></p>
<ul>
<li>检查进程模块列表（不应出现未知模块），校验模块签名&#x2F;完整性（代码签名或哈希）。</li>
<li>监控进程创建线程&#x2F;远程加载库等操作的来源。</li>
<li>使用内核级驱动（或防护内核模式签名）来检测和阻断注入（例如禁止未签名驱动、阻断 CreateRemoteThread 目标进程等）。</li>
</ul>
<p>其他常见变体（补充）</p>
<ul>
<li><strong>内核级外挂（Kernel-mode &#x2F; Driver cheats）</strong>：通过安装驱动绕过用户态检查（可读写任意进程内存、隐藏进程、hook 内核函数）。能力极强但需要签名&#x2F;权限，且更容易被检测&#x2F;追责。</li>
<li><strong>网络层作弊（Packet manipulation &#x2F; MITM）</strong>：拦截&#x2F;修改网络数据包（可能在客户端和服务器间伪造状态）。</li>
<li><strong>模拟器&#x2F;客户端修改</strong>：在模拟器或改造的客户端上直接修改逻辑（例如改协议、修改资源文件）。</li>
<li><strong>外部硬件或辅助设备</strong>：硬件宏、专用操控器、FPGA 等在硬件层面模拟或加速作弊动作。</li>
</ul>
<p>待补充…</p>
<h2 id="Ring3常见反作弊手段"><a href="#Ring3常见反作弊手段" class="headerlink" title="Ring3常见反作弊手段"></a>Ring3常见反作弊手段</h2><p>“<strong>Ring3</strong>” 是操作系统底层架构中的一个非常重要的概念，尤其是在安全、逆向、驱动开发中经常出现。要理解它，先要从 CPU 的 <strong>特权级（Privilege Level）</strong> 机制讲起。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>特权级别</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Ring0</strong></td>
<td>最高权限</td>
<td>操作系统内核（Kernel Mode）</td>
</tr>
<tr>
<td><strong>Ring1</strong></td>
<td>较高权限</td>
<td>旧架构中用于驱动（现代系统很少用）</td>
</tr>
<tr>
<td><strong>Ring2</strong></td>
<td>较低中间层</td>
<td>保留或未使用</td>
</tr>
<tr>
<td><strong>Ring3</strong></td>
<td>最低权限</td>
<td>用户程序运行环境（User Mode）</td>
</tr>
</tbody></table>
<p>大多数现代操作系统（如 Windows、Linux）只实际使用：</p>
<ul>
<li><strong>Ring0：内核态</strong></li>
<li><strong>Ring3：用户态</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────┐</span><br><span class="line">│  Ring0         │ ← 内核态（最高权限）</span><br><span class="line">│  操作系统内核   │</span><br><span class="line">│  驱动程序       │</span><br><span class="line">├───────────────┤</span><br><span class="line">│  Ring3         │ ← 用户态（最低权限）</span><br><span class="line">│  应用程序       │</span><br><span class="line">│  游戏 / 浏览器  │</span><br><span class="line">└───────────────┘</span><br></pre></td></tr></table></figure>

<p>详见<a href="https://matriy330.github.io/32958ffb/">逆向常见反调试总结 | Matriy’s blog</a></p>
<p><strong>VT</strong> 全称是 **Intel VT-x (Virtualization Technology)**，AMD 的对应技术叫 <strong>AMD-V</strong>。</p>
<p>它是 <strong>硬件级虚拟化支持</strong>，允许一个物理 CPU 通过硬件机制运行多个“虚拟机” (Virtual Machine)。</p>
<blockquote>
<p>简单说：VT 就是让虚拟机（如 VMware、VirtualBox、Hyper-V）能高效运行的“硬件加速层”。</p>
</blockquote>
<p>许多分析人员、CTF 环境、恶意代码研究者，都在虚拟机里运行样本（方便快照和隔离）。</p>
<p>于是，<strong>恶意程序会想办法检测自己是不是运行在虚拟机环境中</strong>。这类技术叫做 **反虚拟化 (Anti-VM)**，也经常和反调试配合使用。</p>
<p>当 VT开启时，CPU 允许进入一种叫 <strong>VMX root &#x2F; non-root mode</strong> 的模式：</p>
<ul>
<li><strong>Root mode</strong>：运行 VMM（虚拟机管理器，例如 VMware &#x2F; Hyper-V）</li>
<li><strong>Non-root mode</strong>：运行虚拟机里的客体系统（guest OS）</li>
</ul>
<p>当虚拟机里执行某些敏感指令（如 CPUID、SIDT、SGDT、IN、OUT 等）时，CPU 会把控制权交还给 VMM —— 这就是所谓的 <strong>VM exit</strong>。</p>
<p>在硬件虚拟化（Intel VT-x 或 AMD-V）体系中，CPU 和 内存 被划分为三个逻辑层：</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>名称</th>
<th>运行内容</th>
<th>特征</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Host（宿主机）</strong></td>
<td>宿主操作系统 &#x2F; Hypervisor</td>
<td>真实运行在物理硬件上</td>
<td>拥有最高控制权</td>
</tr>
<tr>
<td><strong>Guest（客户机）</strong></td>
<td>被虚拟化出来的“虚拟电脑”</td>
<td>运行自己的 OS（例如虚拟机中的 Windows 或 Linux）</td>
<td>受 Hypervisor 控制</td>
</tr>
<tr>
<td><strong>Hardware（物理层）</strong></td>
<td>CPU、内存、I&#x2F;O 设备</td>
<td>由 VT 机制分时提供给各 Guest</td>
<td>提供虚拟化支持指令（VMX &#x2F; SVM）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>VM-entry</strong></td>
<td>CPU 从 Hypervisor 进入 Guest 开始执行 → Guest 代码运行在 VMX non-root mode。</td>
</tr>
<tr>
<td><strong>VM-exit</strong></td>
<td>当 Guest 执行敏感指令（如 IO、CPUID、HLT、VMCALL 等）或发生异常时，CPU 自动退出 Guest 模式，把控制权交回 Hypervisor （Host）。</td>
</tr>
<tr>
<td><strong>Hypervisor 处理事件</strong></td>
<td>Hypervisor 检查发生了什么（例如 Guest 访问了被禁止的寄存器），修改状态或模拟结果。</td>
</tr>
<tr>
<td><strong>再次 VM-entry</strong></td>
<td>Hypervisor 处理完毕后再让 CPU 返回 Guest 继续执行。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>术语</th>
<th>含义</th>
<th>所在层级</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Host</strong></td>
<td>物理机 + 宿主操作系统</td>
<td>真实硬件</td>
</tr>
<tr>
<td><strong>Hypervisor (VMM)</strong></td>
<td>虚拟机监控器，调度 Guest 运行</td>
<td>VMX root mode</td>
</tr>
<tr>
<td><strong>Guest</strong></td>
<td>被虚拟化出来的操作系统或程序</td>
<td>VMX non-root mode</td>
</tr>
</tbody></table>
<p>如</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>谁在做</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Host（宿主）</strong></td>
<td>你的物理机系统，比如 Windows 11 或 Linux + VMware Workstation</td>
</tr>
<tr>
<td><strong>Hypervisor（虚拟机管理器）</strong></td>
<td>VMware 内核驱动或 Hyper-V 核心</td>
</tr>
<tr>
<td><strong>Guest（客户机）</strong></td>
<td>VMware 中的 Windows 10；它的 kernel 在 CPU 的 VMX non-root mode 运行</td>
</tr>
</tbody></table>
<p><strong>单步异常在 VT 下导致 RIP 指向错误（RIP 指向超前）</strong></p>
<p>在裸机上，CPU 单步（trap on single-step &#x2F; TF 标志）会在每条指令后产生 <code>#DB</code>（debug exception），由调试器&#x2F;操作系统处理；处理完通常把 <code>RIP</code> 指向下一条要执行的指令（或按调试器修改的上下文继续）。</p>
<p>在硬件虚拟化（VT-x&#x2F;AMD-V）场景下，guest 的某些异常或控制事件需要由 hypervisor 处理：这会产生 <strong>VM-exit</strong>（把执行从 guest 切回到 hypervisor&#x2F;host），hypervisor 处理完后再 VM-entry 回到 guest。</p>
<p>如果 hypervisor（或虚拟化实现）在处理 VM-exit&#x2F;VM-entry 时的上下文恢复&#x2F;单步逻辑有 bug（比如没有正确更新或保存 guest 的 TF、RIP、或没有把单步后的指令指针正确设置），那么当异常&#x2F;单步完成后，guest 的 <code>RIP</code> 可能不会精确指向“应该执行的下一条指令”，而是“超前”到更后面的指令，从而跳过某些指令（例如 <code>nop</code> 后面的指令被执行，或相反）。</p>
<p><strong>为什么会发生</strong></p>
<ul>
<li>VM-exit&#x2F;entry 路径要保存&#x2F;恢复大量 CPU 状态（RIP、RFLAGS、寄存器、MSR 等）。实现复杂、边界条件多。某些 hypervisor&#x2F;虚拟化产品在处理单步（TF）或调试中断时逻辑不完善或优化错误，就会把 RIP 恢复错位。</li>
<li>有时 hypervisor 为了“优化”对单步的支持，会通过硬件单步模拟、软件插桩或修改跳转逻辑来避免大量 VM-exit，但这样更容易出错。</li>
</ul>
<p>典型现象</p>
<blockquote>
<p>在真实情况下，单步后 RIP 应该指向 <code>nop</code> 指令（或下一条指令）；但在有些 VT 实现中，单步返回后 RIP 指向 <code>nop</code> 之后的下一条有效指令（也就是跳过了 <code>nop</code> 的执行点或多执行了一条），造成控制流不一致。</p>
</blockquote>
<p><strong>EPThook（EPT Hook）检测与时间侧信道</strong></p>
<p>EPT 简单回顾</p>
<ul>
<li>EPT（Intel 的 Extended Page Table）是 hypervisor 用来把 Guest-physical 映射到 Host-physical 的硬件页表（第二层页表）。Hypervisor 可以通过修改 EPT 条目控制某个 guest 页面是否可读&#x2F;可写&#x2F;可执行，并在访问被禁止时触发 EPT violation → VM-exit。</li>
<li>基于 EPT 的 hook（EPThook）通常做法：把目标页的 EPT 条目去掉 execute 权或读写权限。Guest 一旦尝试<strong>执行</strong>该页面或<strong>读写</strong>该页面，就会触发 EPT-violation（VM-exit），由 hypervisor 在 host 端处理（记录、修改、跳转等），然后再返回 guest。</li>
</ul>
<p>一些VT会开启EPTHook，要检测EPTHook，和检测VT状态的思路一致。当一个页面被EPTHook了，执行所需的时间远比读取页面的时间要长。因为读取页面不需要频繁的换入换出页面，而先读写后执行则会在在执行和读取页面之间交替换入换出，从而浪费大量时间。</p>
<p><strong>cpu_id检测</strong></p>
<p><code>CPUID</code> 是一条 <strong>x86 架构的处理器指令</strong>  用于<strong>查询 CPU 的信息</strong>（厂商、型号、功能支持、虚拟化状态、缓存大小、是否有超线程等）。</p>
<blockquote>
<p>很多虚拟化平台（VMware、VirtualBox、Hyper-V、QEMU）以及沙箱环境都会在 <code>CPUID</code> 的返回值中留下特征。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 1</span><br><span class="line">cpuid</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>ECX bit31</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>物理机（bare-metal）</td>
</tr>
<tr>
<td>1</td>
<td>虚拟化环境（VMware&#x2F;VirtualBox&#x2F;Hyper-V 等）</td>
</tr>
</tbody></table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://luhaoblog.oss-cn-hangzhou.aliyuncs.com/img1/image-20251007200842968.png" alt="image-20251007200842968"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cpu_info[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ① 调用 CPUID(EAX=1) 获取基本 CPU 功能信息</span></span><br><span class="line">__cpuid(cpu_info, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ② 检查 ECX[31] (bit 31)：Hypervisor bit</span></span><br><span class="line"><span class="keyword">if</span> ( (cpu_info[<span class="number">2</span>] &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span> ) &#123;           <span class="comment">// 存在 Hypervisor</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清零寄存器（可选）</span></span><br><span class="line">    cpu_info[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    cpu_info[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    cpu_info[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ③ 调用 CPUID(EAX=0x40000000) 获取 hypervisor vendor ID</span></span><br><span class="line">    __cpuid(cpu_info, <span class="number">0x40000000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 EBX, ECX, EDX 是否为 &quot;Microsoft Hv&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (cpu_info[<span class="number">1</span>] == <span class="number">0x7263694d</span> &amp;&amp;  <span class="comment">// &quot;Micr&quot;</span></span><br><span class="line">        cpu_info[<span class="number">2</span>] == <span class="number">0x666f736f</span> &amp;&amp;  <span class="comment">// &quot;osoft&quot;</span></span><br><span class="line">        cpu_info[<span class="number">3</span>] == <span class="number">0x76482074</span>) &#123;  <span class="comment">// &quot; Hv&quot; + &quot;t&quot;（Microsoft Hv）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再调用 CPUID(EAX=0x40000003) 获取 Hyper-V 特定功能信息</span></span><br><span class="line">        __cpuid(cpu_info, <span class="number">0x40000003</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ④ 检查 EBX bit0：root partition flag</span></span><br><span class="line">        <span class="keyword">if</span> (cpu_info[<span class="number">1</span>] &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 在 Hyper-V 的 root 分区（宿主层）</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">// 在 Hyper-V 的子分区（虚拟机中）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 没检测到 Hyper-V</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>E8 检查（E8 Check）</strong> 是一种经典的 <strong>反外挂 &#x2F; 反破解 &#x2F; 调用完整性检查机制</strong>，它的名字来源于 x86 指令集中 <code>CALL</code> 指令的机器码 **<code>0xE8</code>**。</p>
<p>节 <code>E8</code> 表示一条相对调用（<code>CALL rel32</code>），后面跟 4 字节相对偏移。</p>
<p>当 CPU 执行 <code>CALL</code> 时，会做两件事：</p>
<ol>
<li><strong>把下一条指令的地址压入栈（即返回地址）</strong>；</li>
<li><strong>跳转到目标函数</strong>。</li>
</ol>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00401000: E8 1B 00 00 00    call 00401020</span><br><span class="line">00401005: 90                nop</span><br><span class="line">00401006: ...</span><br></pre></td></tr></table></figure>

<p>当执行 <code>call 00401020</code> 时，CPU 会：</p>
<ul>
<li>压栈返回地址：<code>00401005</code>；</li>
<li>跳转到 <code>00401020</code>。</li>
</ul>
<p><strong>E8 检查 &#x3D; 检查调用栈中返回地址的前一条指令是否真的是 CALL（E8 开头）。</strong></p>
<p>例如游戏里某个敏感函数 <code>GetKey()</code>，只允许被合法逻辑调用。</p>
<p>外挂可能想绕过逻辑直接“跳过去”调用，于是手工修改栈或直接 JMP 到 <code>GetKey</code>，不走真正的 <code>CALL</code>。</p>
<p>程序为了防御这种“伪造调用”，就在函数开头做检查：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GetKey:</span><br><span class="line">    mov eax, [esp]          ; 取返回地址</span><br><span class="line">    dec eax                 ; 返回地址 - 1 （指向 CALL 的 E8 字节）</span><br><span class="line">    cmp byte ptr [eax], 0xE8 ; 检查是不是 E8 CALL</span><br><span class="line">    jne  IllegalCallDetected</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果返回地址前一字节确实是 0xE8 → 说明这个函数是通过 <code>CALL</code> 指令正常被调用的。</p>
<p>如果不是 → 说明是外挂或异常跳转 → 触发异常 &#x2F; 拒绝执行。</p>
</blockquote>
<p><strong>按机器特征分发可执行文件 + GetKey</strong></p>
<blockquote>
<p>“返回地址检查由客户端分发游戏文件，根据机器某些软硬件特征分发不同的可执行文件，让 <code>GetKey</code> 函数对不同用户不同，外挂不得不调用该函数来获取解密密钥。”</p>
</blockquote>
<p>解释：</p>
<ul>
<li>服务端根据机器指纹（例如 CPU id、硬盘序列号、MAC、TPM 等）为每台机器生成<strong>不同的可执行文件</strong>或不同的 key&#x2F;逻辑。</li>
<li>游戏里有一个 <code>GetKey()</code>（或类似）函数负责根据本机特征生成&#x2F;返回解密密钥或解密流程的关键信息。</li>
<li>这样，外挂如果要解密&#x2F;获得游戏内部关键数据，就必须<strong>在进程内</strong>以正确方式调用 <code>GetKey()</code>（或模拟其逻辑）。外部简单修改同一文件在别的机器上不一定生效，从而提高逆向门槛。</li>
</ul>
<p>用途：这是“按机打包 + 绑定密钥”的反破解手段——增加每台机器的差异，降低通用补丁&#x2F;外挂的可用性。</p>
<p><strong>之前的绕过思路（在没有 E8 检查时）</strong></p>
<blockquote>
<p>“在没有 E8 检查之前，可以找到主模块内某一个 <code>ret</code> 指令的地址，将当前位置压栈、压入 <code>ret</code> 指令地址、jmp到目标函数。”</p>
</blockquote>
<p>解释（高层）：</p>
<ul>
<li>攻击者在游戏的主模块里找一个合适的 <code>ret</code> 指令地址（或者任意可返回的地址），构造栈上返回地址，然后直接 <code>jmp</code> 到目标函数（比如 <code>GetKey</code>）去调用它。</li>
<li>手法本质上是<strong>伪造调用栈：把“返回地址”放到栈上并跳转</strong>，让目标函数执行完后以伪造的返回地址回到某处，从而避开正常调用约束或上下文检查。</li>
<li>这种方法通常用于“进程内调用”但不走正常调用路径（绕过某些前置检查、非法构造调用上下文）。</li>
</ul>
<p>这是在没有更严格检测时一种常见的内存&#x2F;控制流操纵技巧。</p>
<p><strong>加入 E8 检查后老方法作废</strong></p>
<p>“对抗：用 Zyais 框架动态分析指令，去除返回地址检查，修补变量地址后调用。” —— 高层含义</p>
<ul>
<li>这句话意思不是说具体如何去做绕过，而是在描述一种高级逆向&#x2F;动态分析思路的<strong>概念性流程</strong>：<ol>
<li>用动态二进制分析&#x2F;执行框架（提到的 “Zyais”——理解为某种动态分析或动态二进制翻译&#x2F;插桩工具）对程序运行时的二进制指令进行<strong>动态跟踪&#x2F;修改</strong>。</li>
<li>找到并识别出“返回地址检查”的那段代码（即验证 <code>E8</code> 的检测逻辑）。</li>
<li>在运行时把这段检查<strong>绕过或修改</strong>（去除&#x2F;补丁），或者直接在内存中修补相关变量&#x2F;校验数据，使检查通过。</li>
<li>修补完检测&#x2F;上下文后，再安全地调用目标函数（例如 <code>GetKey</code>）。</li>
</ol>
</li>
<li>换句话说：利用动态分析与内存&#x2F;指令级修补，在运行时<strong>消除或中和</strong>防护逻辑，从而恢复对目标函数的可控调用。</li>
</ul>
<p>防止hook:</p>
<p><strong>CRC32检查和其他定时对.text段进行CRC32完整性检查，</strong></p>
<p><strong>对抗</strong>:硬件断点VEH HOOK</p>
<p>攻击者不会直接在目标函数序列上打软件补丁（修改 <code>.text</code>），而是通过<strong>硬件断点（CPU Debug Registers）</strong>或注册 <strong>VEH（Vectored Exception Handler）</strong> 来拦截执行流并在运行时修改寄存器&#x2F;内存或模拟函数结果。</p>
<p>这样做好处是：<code>.text</code> 没有永久被改写（CRC 在内存视图上仍然是原始），检查 <code>.text</code> 的哈希会通过；但是实际运行时可以在断点触发处动态改变行为（比如在函数入口前拦截并直接返回）。</p>
<p><strong>对抗</strong>:NtQuerySystemInformation查询添加的VEH</p>
<p>有人会尝试用系统查询接口来“发现”某些异常处理器或调试对象（比如枚举句柄&#x2F;系统句柄表来发现调试器&#x2F;VEH 的痕迹），而攻击者会 hook&#x2F;伪造这些系统调用来隐藏自己。</p>
<p><strong>对抗</strong>:下硬件断点，HookKiUserExceptionHandler不经过异常分派直接处理异常</p>
<p>内核或 NTDLL 里有一条把异常分派给用户态的“桥”&#x2F;入口（例如 <code>KiUserExceptionDispatcher</code> &#x2F; <code>RtlDispatchException</code> 等在异常分派链上关键函数）。</p>
<p>攻击者可以 hook 或替换该路径（例如替换 <code>KiUserExceptionDispatcher</code> 指向的地址或在内核安装 hook），使得当异常发生时 <strong>不经过正常的异常分派链</strong>（VEH&#x2F;SEH）而被攻击者的代码直接处理，从而绕过被用于检测的 handler。</p>
<p>另一种是直接在内核 &#x2F; ntdll 层挂钩并自己处理异常，或把异常转交给调试器，令目标程序的检测逻辑根本看不到异常发生（或在异常到达检测点前被“吞掉”）。</p>
<p><strong>对抗</strong>:添加自己的异常处理器，主动用INT3触发异常，检测分派到自己的异常处理后的寄存器，并进行栈回溯</p>
<ul>
<li>防护代码在进程内部注册自己的 VEH&#x2F;SEH，并主动触发一个受控异常（例如 <code>INT3</code> 或 <code>RaiseException</code>）。该异常在正常情况下会先到达系统&#x2F;调试层，再进到进程的 VEH&#x2F;SEH。</li>
<li><strong>检测点</strong>：在自家的 handler 中，防护逻辑会检查：<ul>
<li><strong>寄存器上下文</strong>（例如 RIP&#x2F;EIP、RSP&#x2F;ESP、寄存器值）是否和触发点一致（或是否被篡改）；</li>
<li><strong>栈回溯（call stack&#x2F;backtrace）</strong>，验证异常来源是预期的调用序列（比如返回地址点位于本模块 <code>.text</code> 的合法位置，并且调用者不是第三方模块）；</li>
<li><strong>返回地址&#x2F;调用序列的完整性</strong>（比如前面你提过的 E8 检查，或更强的 call-stack hash）。</li>
</ul>
</li>
</ul>
<p>如果这些检查发现异常在到达 handler 前被拦截、修改或被不合法的上下文处理（例如寄存器被替换，返回地址不合法），就可以判定存在 hook&#x2F;中间人（例如 VEH 被拦截，或 KiUserExceptionDispatcher 被 Hook）。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://matriy330.github.io">Matriy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://matriy330.github.io/65f6ce99/">http://matriy330.github.io/65f6ce99/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://matriy330.github.io" target="_blank">Matriy's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Re/">Re</a></div><div class="post-share"><div class="social-share" data-image="/img/tx.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/zsm.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/zsm.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/zfb.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/zfb.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/41a159b6/" title="Angr 学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-02</div><div class="info-item-2">Angr 学习</div></div><div class="info-2"><div class="info-item-1">Angr 学习文章参考：angr初探 | moyaoxueの小屋和Angr入门和Angr：一个具有动态符号执行和静态分析的二进制分析工具-腾讯云开发者社区-腾讯云 Angr简介angr是一个支持多处理架构的用于二进制文件分析的工具包，它提供了动态符号执行的能力以及多种静态分析的能力。项目创建的初衷，是为了整合此前多种二进制分析方式的优点，并开发一个平台，以供二进制分析人员比较不同二进制分析方式的优劣，并根据自身需要开发新的二进制分析系统和方式。 也正是因为angr是一个二进制文件分析的工具包，因此它可以被使用者扩展，用于自动化逆向工程、漏洞挖掘等多个方面。 angr 官方文档 angr_ctf项目GitHub - jakespringer&#x2F;angr_ctf  angr_ctf则是一个专门针对angr的项目，里面有17个angr相关的题目。这些题目只有一个唯一的要求：你需要找出能够使程序输出“Good Job”的输入，这也是符号执行常见的应用场景。  本系列教程是angr的入门教程，将通过做angr_ctf中的题目的形式来介绍angr。 Angr初探Angr...</div></div></div></a><a class="pagination-related" href="/21e5b258/" title="CTF逆向常见反调试技术总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-07</div><div class="info-item-2">CTF逆向常见反调试技术总结</div></div><div class="info-2"><div class="info-item-1">CTF逆向常见反调试技术总结反调试主要为了干扰动态调试 反调试是一种用于阻碍程序动态调试的技术，首先大致说明一下反调试的工作原理。 在操作系统内部提供了一些API，用于调试器调试。当调试器调用这些API时系统就会在被调试的进程内存中留下与调试器相关的信息。一部分信息是可以被抹除的，也有一部分信息是难以抹除的。 当调试器附加到目标程序后，用户的很多行为将优先被调试器捕捉和处理。其中大部分是通过异常捕获通信的，包括断点的本质就是异常。如果调试器遇到不想处理的信息，一种方式是忽略，另一种方式是交给操作系统处理。 那么目前为止，程序就有两种方式检测自己是否被调试：  检测内存中是否有调试器的信息。 通过特定的指令或触发特定异常，检测返回结果。  通常来说，存在反调试的程序，当检测到自身处于调试状态时，就会控制程序绕过关键代码，防止关键代码被调试，或者干脆直接退出程序。 API反调试1BOOL IsDebuggerPresent();  返回值为1表示当前进程被调试的状态，反之为0. 123call IsDebuggerPresenttest al, aljne...</div></div></div></a><a class="pagination-related" href="/32958ffb/" title="CTF逆向常见加密算法总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-01</div><div class="info-item-2">CTF逆向常见加密算法总结</div></div><div class="info-2"><div class="info-item-1">CTF逆向常见加密算法总结流密码系列 只要识别出流密码，我们就可以选择动态调试获取密钥流或者直接把目标密文 patch 进去拿输出就可以了  RC4比较常见，原理不赘述，可以看我的RC4&amp;RSA | Matriy’s blog RC4常见时会有一个初始化256个的S盒操作 解密代码 12345678910111213141516171819202122232425262728293031key = list(&#x27;RC4_1s_4w3s0m3&#x27;)content = [0xA7, 0x1A, 0x68, 0xEC, 0xD8, 0x27, 0x11, 0xCC, 0x8C, 0x9B, 0x16, 0x15, 0x5C, 0xD2, 0x67, 0x3E, 0x82, 0xAD,           0xCE, 0x75, 0xD4, 0xBC, 0x57, 0x56, 0xC2, 0x8A, 0x52, 0xB8, 0x6B, 0xD6, 0xCC, 0xF8, 0xA4, 0xBA, 0x72, 0x2F,           0xE0, 0x57,...</div></div></div></a><a class="pagination-related" href="/f05d2f57/" title="IDAPython脚本(7.5以上)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-29</div><div class="info-item-2">IDAPython脚本(7.5以上)</div></div><div class="info-2"><div class="info-item-1">IDAPython脚本(7.5以上)IDAPython是很强大的功能. 但是在7.5支持python3之后很多函数都改变了. 所以从头开始学一下. IDAPython官方函数文档: IDAPython官方文档函数查询 IDC函数官方文档查询: IDC函数 IDA版本与版本之间的差异化函数查询: IDA版本函数差异化 指令相关 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from idaapi import *from ida_dbg import *from ida_bytes import *# 返回目标地址指向的指令的前一条指令的地址# 参数一是查找的开始地址，参数二是往前查找的最小地址（在范围内）prev_1 = prev_head(0x00007FF6A1AA2577, 1)prev_2 = prev_head(0x00007FF6A1AA257a,...</div></div></div></a><a class="pagination-related" href="/d932918b/" title="ios逆向初探"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-27</div><div class="info-item-2">ios逆向初探</div></div><div class="info-2"><div class="info-item-1">ios逆向初探ios 信息iOS的越狱（Jailbreaking）是指通过绕过Apple设备上的操作系统限制，从而获得对设备操作系统更深层次的访问权限的过程。这通常是为了能够安装和运行未经Apple认证的第三方应用程序和修改系统设置，提供更大的自由度。 iOS砸壳是指通过技术手段解密和破解iOS应用程序的加密保护，以便绕过App Store的审查机制，查看应用的内部代码，或修改其行为。  解密IPA文件：iOS应用程序通常以IPA文件格式存在，其中包含了应用的二进制文件、资源和相关数据。这些文件在发布到App Store之前，Apple会对其进行加密处理，以防止逆向工程和破解。砸壳的目的是通过绕过或破解这种加密，提取出应用的二进制文件。 绕过代码签名：iOS应用程序在执行时需要通过Apple的代码签名验证，确保应用来自合法开发者且未被篡改。砸壳通常包括绕过这个签名机制，使应用可以在越狱设备或非App Store渠道上运行。  ios一般逆向流程 一般来说流程为...</div></div></div></a><a class="pagination-related" href="/d7022eaa/" title="花指令详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-30</div><div class="info-item-2">花指令详解</div></div><div class="info-2"><div class="info-item-1">花指令详解参考文章：  逆向分析基础 — 花指令实现及清除_jmp花指令逆向-CSDN博客  花指令是企图隐藏掉不想被逆向工程的代码块(或其它功能)的一种方法，在真实代码中插入一些垃圾代码的同时还保证原有程序的正确执行，而程序无法很好地反编译, 难以理解程序内容，达到混淆视听的效果。 简单的说就是在代码中混入一些垃圾数据阻碍你静态分析 常用的两类反汇编算法：  线性扫描算法：逐行反汇编（无法将数据和内容进行区分） 递归行进算法：按照代码可能的执行顺序进行反汇编程序。   最简单的花指令： 123456789101112131415161718//源码#include&lt;stdio.h&gt;#include&lt;windows.h&gt;int main(int argc, char* argv[])&#123;	int a = MessageBox(NULL,&quot;Hello&quot;,&quot;main&quot;,MB_OK);	int b,c,d,e;   //这部分为花指令部分	__asm&#123;_emit 0xe8&#125;  ...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Matriy</div><div class="author-info-description">不积硅步，无以至千里</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">224</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Matriy330"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">正在学习安卓逆向 (*^_^*)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2"><span class="toc-text">游戏逆向初探</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity3D"><span class="toc-text">Unity3D</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UE%E5%BC%95%E6%93%8E"><span class="toc-text">UE引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UE%E7%AE%80%E4%BB%8B"><span class="toc-text">UE简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Uworld"><span class="toc-text">Uworld</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UFunction"><span class="toc-text">UFunction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ProcessEvent"><span class="toc-text">ProcessEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1"><span class="toc-text">防御</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E6%8C%82%E5%8E%9F%E7%90%86"><span class="toc-text">外挂原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ring3%E5%B8%B8%E8%A7%81%E5%8F%8D%E4%BD%9C%E5%BC%8A%E6%89%8B%E6%AE%B5"><span class="toc-text">Ring3常见反作弊手段</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/21e5b258/" title="CTF逆向常见反调试技术总结">CTF逆向常见反调试技术总结</a><time datetime="2025-10-06T16:00:00.000Z" title="发表于 2025-10-07 00:00:00">2025-10-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/65f6ce99/" title="游戏逆向初探">游戏逆向初探</a><time datetime="2025-10-05T16:00:00.000Z" title="发表于 2025-10-06 00:00:00">2025-10-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2ade85f8/" title="DASCTF 2023 10 wp">DASCTF 2023 10 wp</a><time datetime="2025-10-02T16:00:00.000Z" title="发表于 2025-10-03 00:00:00">2025-10-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/41a159b6/" title="Angr 学习">Angr 学习</a><time datetime="2025-10-01T16:00:00.000Z" title="发表于 2025-10-02 00:00:00">2025-10-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/32958ffb/" title="CTF逆向常见加密算法总结">CTF逆向常见加密算法总结</a><time datetime="2025-09-30T16:00:00.000Z" title="发表于 2025-10-01 00:00:00">2025-10-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Matriy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank" href="https://hexo.io/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px"target="_blank" href="https://www.jsdelivr.com/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px"target="_blank" href="https://github.com/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p> <p>Hi, welcome to Matriy's <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.open-ctf.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo.open-ctf.top/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script async data-pjax src="/js/anzhiyu.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href="/music/"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>